<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.9.1"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>CUGL 2.0: cugl::UniformBuffer Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">CUGL 2.0
   </div>
   <div id="projectbrief">Cornell University Game Library</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.1 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search','.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespacecugl.html">cugl</a></li><li class="navelem"><a class="el" href="classcugl_1_1_uniform_buffer.html">UniformBuffer</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-static-methods">Static Public Member Functions</a> &#124;
<a href="#pub-static-attribs">Static Public Attributes</a> &#124;
<a href="classcugl_1_1_uniform_buffer-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">cugl::UniformBuffer Class Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p><code>#include &lt;<a class="el" href="_c_u_uniform_buffer_8h_source.html">CUUniformBuffer.h</a>&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a6df2acfc29a44a632881f6e8bec6f8b1"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1_uniform_buffer.html#a6df2acfc29a44a632881f6e8bec6f8b1">UniformBuffer</a> ()</td></tr>
<tr class="separator:a6df2acfc29a44a632881f6e8bec6f8b1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1be46d1dfa079bb430275bcd6a4263b7"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1_uniform_buffer.html#a1be46d1dfa079bb430275bcd6a4263b7">~UniformBuffer</a> ()</td></tr>
<tr class="separator:a1be46d1dfa079bb430275bcd6a4263b7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7549945d0e6ad989e8a18f3dd2af1f84"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1_uniform_buffer.html#a7549945d0e6ad989e8a18f3dd2af1f84">dispose</a> ()</td></tr>
<tr class="separator:a7549945d0e6ad989e8a18f3dd2af1f84"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeb0e16167c2665445e21d8274b89263f"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1_uniform_buffer.html#aeb0e16167c2665445e21d8274b89263f">init</a> (GLsizei capacity)</td></tr>
<tr class="separator:aeb0e16167c2665445e21d8274b89263f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae9870f6c9bc95ce0a6d1c6ae9f2d9377"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1_uniform_buffer.html#ae9870f6c9bc95ce0a6d1c6ae9f2d9377">init</a> (GLsizei capacity, GLuint blocks)</td></tr>
<tr class="separator:ae9870f6c9bc95ce0a6d1c6ae9f2d9377"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeeae70345a7add5292e5de7b4ee35c90"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1_uniform_buffer.html#aeeae70345a7add5292e5de7b4ee35c90">setName</a> (std::string name)</td></tr>
<tr class="separator:aeeae70345a7add5292e5de7b4ee35c90"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aba2868f5cb7cf42be2a1b9abbf9dcb4c"><td class="memItemLeft" align="right" valign="top">const std::string &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1_uniform_buffer.html#aba2868f5cb7cf42be2a1b9abbf9dcb4c">getName</a> () const</td></tr>
<tr class="separator:aba2868f5cb7cf42be2a1b9abbf9dcb4c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a20bb17bed4873a29e6d74a53ef4e1c03"><td class="memItemLeft" align="right" valign="top">GLenum&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1_uniform_buffer.html#a20bb17bed4873a29e6d74a53ef4e1c03">getDrawType</a> () const</td></tr>
<tr class="separator:a20bb17bed4873a29e6d74a53ef4e1c03"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1d2185f2b4665ef52dc81bf493c3f30c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1_uniform_buffer.html#a1d2185f2b4665ef52dc81bf493c3f30c">setDrawType</a> (GLenum type)</td></tr>
<tr class="separator:a1d2185f2b4665ef52dc81bf493c3f30c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a26e893f81d76465cfb3e46cc3ab62ee4"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1_uniform_buffer.html#a26e893f81d76465cfb3e46cc3ab62ee4">isReady</a> () const</td></tr>
<tr class="separator:a26e893f81d76465cfb3e46cc3ab62ee4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a60998a2b0cd7243e20d12469ee60328f"><td class="memItemLeft" align="right" valign="top">GLuint&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1_uniform_buffer.html#a60998a2b0cd7243e20d12469ee60328f">getBlockCount</a> () const</td></tr>
<tr class="separator:a60998a2b0cd7243e20d12469ee60328f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acffec26117318df5c4ed59e23dfe84dc"><td class="memItemLeft" align="right" valign="top">GLsizei&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1_uniform_buffer.html#acffec26117318df5c4ed59e23dfe84dc">getBlockSize</a> () const</td></tr>
<tr class="separator:acffec26117318df5c4ed59e23dfe84dc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3a9142b71cc559e42e1e051f7c0c4eae"><td class="memItemLeft" align="right" valign="top">GLsizei&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1_uniform_buffer.html#a3a9142b71cc559e42e1e051f7c0c4eae">getBlockStride</a> () const</td></tr>
<tr class="separator:a3a9142b71cc559e42e1e051f7c0c4eae"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a751b11f89e7b56e36d76a026fa129c40"><td class="memItemLeft" align="right" valign="top">char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1_uniform_buffer.html#a751b11f89e7b56e36d76a026fa129c40">getData</a> ()</td></tr>
<tr class="separator:a751b11f89e7b56e36d76a026fa129c40"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9a3369ffdfd5c97bc3d8cfe15871f9ac"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1_uniform_buffer.html#a9a3369ffdfd5c97bc3d8cfe15871f9ac">getAutoflush</a> () const</td></tr>
<tr class="separator:a9a3369ffdfd5c97bc3d8cfe15871f9ac"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a97e481e2420a9c5bc92fe6fe5a486d2b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1_uniform_buffer.html#a97e481e2420a9c5bc92fe6fe5a486d2b">setAutoflush</a> (bool style)</td></tr>
<tr class="separator:a97e481e2420a9c5bc92fe6fe5a486d2b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af369c5096161873d307f4a2fe65193bb"><td class="memItemLeft" align="right" valign="top">GLuint&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1_uniform_buffer.html#af369c5096161873d307f4a2fe65193bb">getBuffer</a> () const</td></tr>
<tr class="separator:af369c5096161873d307f4a2fe65193bb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3b25c17e3f3f7df5a77d5af44501c44a"><td class="memItemLeft" align="right" valign="top">GLuint&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1_uniform_buffer.html#a3b25c17e3f3f7df5a77d5af44501c44a">getBindPoint</a> () const</td></tr>
<tr class="separator:a3b25c17e3f3f7df5a77d5af44501c44a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab0ba21941d07fce5e6ee45c940ad982f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1_uniform_buffer.html#ab0ba21941d07fce5e6ee45c940ad982f">setBindPoint</a> (GLuint point)</td></tr>
<tr class="separator:ab0ba21941d07fce5e6ee45c940ad982f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a16230fbbf58106e9e8881da2a86a82b5"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1_uniform_buffer.html#a16230fbbf58106e9e8881da2a86a82b5">bind</a> (bool <a class="el" href="classcugl_1_1_uniform_buffer.html#a7974ed746e52d57ba810ca509631b41c">activate</a>=true)</td></tr>
<tr class="separator:a16230fbbf58106e9e8881da2a86a82b5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af4dd4de6563477582eae6a04c666f96e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1_uniform_buffer.html#af4dd4de6563477582eae6a04c666f96e">unbind</a> ()</td></tr>
<tr class="separator:af4dd4de6563477582eae6a04c666f96e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7974ed746e52d57ba810ca509631b41c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1_uniform_buffer.html#a7974ed746e52d57ba810ca509631b41c">activate</a> ()</td></tr>
<tr class="separator:a7974ed746e52d57ba810ca509631b41c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adb7bf9cb16825a743de8b30779d1d66b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1_uniform_buffer.html#adb7bf9cb16825a743de8b30779d1d66b">deactivate</a> ()</td></tr>
<tr class="separator:adb7bf9cb16825a743de8b30779d1d66b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a98a1cb7695737fc5371c8b942f583fc8"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1_uniform_buffer.html#a98a1cb7695737fc5371c8b942f583fc8">isBound</a> () const</td></tr>
<tr class="separator:a98a1cb7695737fc5371c8b942f583fc8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac39d2c44af1f53ede5b548a0c48dc793"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1_uniform_buffer.html#ac39d2c44af1f53ede5b548a0c48dc793">isActive</a> () const</td></tr>
<tr class="separator:ac39d2c44af1f53ede5b548a0c48dc793"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a493d45001989fa69263b782ff3342d94"><td class="memItemLeft" align="right" valign="top">GLuint&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1_uniform_buffer.html#a493d45001989fa69263b782ff3342d94">getBlock</a> () const</td></tr>
<tr class="separator:a493d45001989fa69263b782ff3342d94"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adee489553cacc3a1a31b16ac0c490ebb"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1_uniform_buffer.html#adee489553cacc3a1a31b16ac0c490ebb">setBlock</a> (GLuint block)</td></tr>
<tr class="separator:adee489553cacc3a1a31b16ac0c490ebb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa66e2e1025f650d84101d35991ebac10"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1_uniform_buffer.html#aa66e2e1025f650d84101d35991ebac10">flush</a> ()</td></tr>
<tr class="separator:aa66e2e1025f650d84101d35991ebac10"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aed42e022b292a290dc9447e02c9240a2"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1_uniform_buffer.html#aed42e022b292a290dc9447e02c9240a2">setOffset</a> (const std::string name, GLsizei offset)</td></tr>
<tr class="separator:aed42e022b292a290dc9447e02c9240a2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a436f81a164c289cc2cf531234be2450b"><td class="memItemLeft" align="right" valign="top">GLsizei&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1_uniform_buffer.html#a436f81a164c289cc2cf531234be2450b">getOffset</a> (const std::string name) const</td></tr>
<tr class="separator:a436f81a164c289cc2cf531234be2450b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af69bc16e9ab02e898c82b7b1fc77d09b"><td class="memItemLeft" align="right" valign="top">std::vector&lt; std::string &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1_uniform_buffer.html#af69bc16e9ab02e898c82b7b1fc77d09b">getOffsets</a> () const</td></tr>
<tr class="separator:af69bc16e9ab02e898c82b7b1fc77d09b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aab597256d45930bb612ab00e5296badc"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1_uniform_buffer.html#aab597256d45930bb612ab00e5296badc">setUniformVec2</a> (GLint block, GLsizei offset, const <a class="el" href="classcugl_1_1_vec2.html">Vec2</a> vec)</td></tr>
<tr class="separator:aab597256d45930bb612ab00e5296badc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1b8283b3c0e5d9a991e05daf14967aeb"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1_uniform_buffer.html#a1b8283b3c0e5d9a991e05daf14967aeb">setUniformVec2</a> (GLint block, const std::string name, const <a class="el" href="classcugl_1_1_vec2.html">Vec2</a> vec)</td></tr>
<tr class="separator:a1b8283b3c0e5d9a991e05daf14967aeb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab80e96cd1f47a1283805ad0016056bf3"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1_uniform_buffer.html#ab80e96cd1f47a1283805ad0016056bf3">getUniformVec2</a> (GLuint block, GLsizei offset, <a class="el" href="classcugl_1_1_vec2.html">Vec2</a> &amp;vec) const</td></tr>
<tr class="separator:ab80e96cd1f47a1283805ad0016056bf3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3d360d4a4be43f62eb287d9081ab67e9"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1_uniform_buffer.html#a3d360d4a4be43f62eb287d9081ab67e9">getUniformVec2</a> (GLuint block, const std::string name, <a class="el" href="classcugl_1_1_vec2.html">Vec2</a> &amp;vec) const</td></tr>
<tr class="separator:a3d360d4a4be43f62eb287d9081ab67e9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a94f549d8afd5afaf5ac9696b0f435d7b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1_uniform_buffer.html#a94f549d8afd5afaf5ac9696b0f435d7b">setUniformVec3</a> (GLint block, GLsizei offset, const <a class="el" href="classcugl_1_1_vec3.html">Vec3</a> vec)</td></tr>
<tr class="separator:a94f549d8afd5afaf5ac9696b0f435d7b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7fc283070b91fa356c6981524badc21f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1_uniform_buffer.html#a7fc283070b91fa356c6981524badc21f">setUniformVec3</a> (GLint block, const std::string name, const <a class="el" href="classcugl_1_1_vec3.html">Vec3</a> vec)</td></tr>
<tr class="separator:a7fc283070b91fa356c6981524badc21f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a508b60eee43b492033c16fef84023381"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1_uniform_buffer.html#a508b60eee43b492033c16fef84023381">getUniformVec3</a> (GLuint block, GLsizei offset, <a class="el" href="classcugl_1_1_vec3.html">Vec3</a> &amp;vec) const</td></tr>
<tr class="separator:a508b60eee43b492033c16fef84023381"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2eac01c4d8e52cefce2e85092886351f"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1_uniform_buffer.html#a2eac01c4d8e52cefce2e85092886351f">getUniformVec3</a> (GLuint block, const std::string name, <a class="el" href="classcugl_1_1_vec3.html">Vec3</a> &amp;vec) const</td></tr>
<tr class="separator:a2eac01c4d8e52cefce2e85092886351f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7734c167c62d1379bc9703e8dce1bc43"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1_uniform_buffer.html#a7734c167c62d1379bc9703e8dce1bc43">setUniformVec4</a> (GLint block, GLsizei offset, const <a class="el" href="classcugl_1_1_vec4.html">Vec4</a> vec)</td></tr>
<tr class="separator:a7734c167c62d1379bc9703e8dce1bc43"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab2b88e5bdb47bba55e4818fe4932c4aa"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1_uniform_buffer.html#ab2b88e5bdb47bba55e4818fe4932c4aa">setUniformVec4</a> (GLint block, const std::string name, const <a class="el" href="classcugl_1_1_vec4.html">Vec4</a> vec)</td></tr>
<tr class="separator:ab2b88e5bdb47bba55e4818fe4932c4aa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a996f1b35ea549c56ba83995ecc912a0d"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1_uniform_buffer.html#a996f1b35ea549c56ba83995ecc912a0d">getUniformVec4</a> (GLuint block, GLsizei offset, <a class="el" href="classcugl_1_1_vec4.html">Vec4</a> &amp;vec) const</td></tr>
<tr class="separator:a996f1b35ea549c56ba83995ecc912a0d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab7a9c069eb155c074b2b455da49b244f"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1_uniform_buffer.html#ab7a9c069eb155c074b2b455da49b244f">getUniformVec4</a> (GLuint block, const std::string name, <a class="el" href="classcugl_1_1_vec4.html">Vec4</a> &amp;vec) const</td></tr>
<tr class="separator:ab7a9c069eb155c074b2b455da49b244f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a50b886de241b785c610ddeb11520e28e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1_uniform_buffer.html#a50b886de241b785c610ddeb11520e28e">setUniformColor4</a> (GLint block, GLsizei offset, const <a class="el" href="classcugl_1_1_color4.html">Color4</a> color)</td></tr>
<tr class="separator:a50b886de241b785c610ddeb11520e28e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a26c7449c0a0f5cbf9ccaa588c3a5dae8"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1_uniform_buffer.html#a26c7449c0a0f5cbf9ccaa588c3a5dae8">setUniformColor4</a> (GLint block, const std::string name, const <a class="el" href="classcugl_1_1_color4.html">Color4</a> color)</td></tr>
<tr class="separator:a26c7449c0a0f5cbf9ccaa588c3a5dae8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaf917141168bdee807e888f925f75480"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1_uniform_buffer.html#aaf917141168bdee807e888f925f75480">getUniformColor4</a> (GLuint block, GLsizei offset, <a class="el" href="classcugl_1_1_color4.html">Color4</a> &amp;color) const</td></tr>
<tr class="separator:aaf917141168bdee807e888f925f75480"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a42d2313a343d7d31aa28bb88bd810020"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1_uniform_buffer.html#a42d2313a343d7d31aa28bb88bd810020">getUniformColor4</a> (GLuint block, const std::string name, <a class="el" href="classcugl_1_1_color4.html">Color4</a> &amp;color) const</td></tr>
<tr class="separator:a42d2313a343d7d31aa28bb88bd810020"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a186f638a39b302cc03060759148f67b2"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1_uniform_buffer.html#a186f638a39b302cc03060759148f67b2">setUniformColor4f</a> (GLint block, GLsizei offset, const <a class="el" href="classcugl_1_1_color4f.html">Color4f</a> color)</td></tr>
<tr class="separator:a186f638a39b302cc03060759148f67b2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a684327147f266dac95a43423bc1e9f52"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1_uniform_buffer.html#a684327147f266dac95a43423bc1e9f52">setUniformColor4f</a> (GLint block, const std::string name, const <a class="el" href="classcugl_1_1_color4f.html">Color4f</a> color)</td></tr>
<tr class="separator:a684327147f266dac95a43423bc1e9f52"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afb92a19678fc78d55d24c864f3ac33c4"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1_uniform_buffer.html#afb92a19678fc78d55d24c864f3ac33c4">getUniformColor4f</a> (GLuint block, GLsizei offset, <a class="el" href="classcugl_1_1_color4f.html">Color4f</a> &amp;color) const</td></tr>
<tr class="separator:afb92a19678fc78d55d24c864f3ac33c4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae8ee157471e06dec9c384797d1c1ca5b"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1_uniform_buffer.html#ae8ee157471e06dec9c384797d1c1ca5b">getUniformColor4f</a> (GLuint block, const std::string name, <a class="el" href="classcugl_1_1_color4f.html">Color4f</a> &amp;color) const</td></tr>
<tr class="separator:ae8ee157471e06dec9c384797d1c1ca5b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0eda643b5f389bc666389140140c55e0"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1_uniform_buffer.html#a0eda643b5f389bc666389140140c55e0">setUniformMat4</a> (GLint block, GLsizei offset, const <a class="el" href="classcugl_1_1_mat4.html">Mat4</a> &amp;mat)</td></tr>
<tr class="separator:a0eda643b5f389bc666389140140c55e0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:add1822ef27f4addcc56069f7c5e7b010"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1_uniform_buffer.html#add1822ef27f4addcc56069f7c5e7b010">setUniformMat4</a> (GLint block, const std::string name, const <a class="el" href="classcugl_1_1_mat4.html">Mat4</a> &amp;mat)</td></tr>
<tr class="separator:add1822ef27f4addcc56069f7c5e7b010"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6efdd633e8b50074f6062a950534745e"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1_uniform_buffer.html#a6efdd633e8b50074f6062a950534745e">getUniformMat4</a> (GLuint block, GLsizei offset, <a class="el" href="classcugl_1_1_mat4.html">Mat4</a> &amp;mat) const</td></tr>
<tr class="separator:a6efdd633e8b50074f6062a950534745e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4a414b17bf6c41f6786b895410757030"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1_uniform_buffer.html#a4a414b17bf6c41f6786b895410757030">getUniformMat4</a> (GLuint block, const std::string name, <a class="el" href="classcugl_1_1_mat4.html">Mat4</a> &amp;mat) const</td></tr>
<tr class="separator:a4a414b17bf6c41f6786b895410757030"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a275b40a13e2042de0956329a57fdd119"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1_uniform_buffer.html#a275b40a13e2042de0956329a57fdd119">setUniformAffine2</a> (GLint block, GLsizei offset, const <a class="el" href="classcugl_1_1_affine2.html">Affine2</a> &amp;mat)</td></tr>
<tr class="separator:a275b40a13e2042de0956329a57fdd119"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa741c324cd94642054b6905fb86ced49"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1_uniform_buffer.html#aa741c324cd94642054b6905fb86ced49">setUniformAffine2</a> (GLint block, const std::string name, const <a class="el" href="classcugl_1_1_affine2.html">Affine2</a> &amp;mat)</td></tr>
<tr class="separator:aa741c324cd94642054b6905fb86ced49"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaf73e69021c2fb108c4e40103f67cee5"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1_uniform_buffer.html#aaf73e69021c2fb108c4e40103f67cee5">getUniformAffine2</a> (GLuint block, GLsizei offset, <a class="el" href="classcugl_1_1_affine2.html">Affine2</a> &amp;mat) const</td></tr>
<tr class="separator:aaf73e69021c2fb108c4e40103f67cee5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1b923c0af38f19b329df0bcd35e5c85b"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1_uniform_buffer.html#a1b923c0af38f19b329df0bcd35e5c85b">getUniformAffine2</a> (GLuint block, const std::string name, <a class="el" href="classcugl_1_1_affine2.html">Affine2</a> &amp;mat) const</td></tr>
<tr class="separator:a1b923c0af38f19b329df0bcd35e5c85b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7e882ce4fd1467844cc7883a72829ee1"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1_uniform_buffer.html#a7e882ce4fd1467844cc7883a72829ee1">setUniformQuaternion</a> (GLint block, GLsizei offset, const <a class="el" href="classcugl_1_1_quaternion.html">Quaternion</a> &amp;quat)</td></tr>
<tr class="separator:a7e882ce4fd1467844cc7883a72829ee1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac2f3e0a8823f74c9e1f41608a96f876a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1_uniform_buffer.html#ac2f3e0a8823f74c9e1f41608a96f876a">setUniformQuaternion</a> (GLint block, const std::string name, const <a class="el" href="classcugl_1_1_quaternion.html">Quaternion</a> &amp;quat)</td></tr>
<tr class="separator:ac2f3e0a8823f74c9e1f41608a96f876a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abef5d36832880437b9dff598a20722cc"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1_uniform_buffer.html#abef5d36832880437b9dff598a20722cc">getUniformQuaternion</a> (GLuint block, GLsizei offset, <a class="el" href="classcugl_1_1_quaternion.html">Quaternion</a> &amp;quat) const</td></tr>
<tr class="separator:abef5d36832880437b9dff598a20722cc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad28201c16e7d2710929bb00df20e1d41"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1_uniform_buffer.html#ad28201c16e7d2710929bb00df20e1d41">getUniformQuaternion</a> (GLuint block, const std::string name, <a class="el" href="classcugl_1_1_quaternion.html">Quaternion</a> &amp;quat) const</td></tr>
<tr class="separator:ad28201c16e7d2710929bb00df20e1d41"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3f181fb47f4f06eb501249bea90b9078"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1_uniform_buffer.html#a3f181fb47f4f06eb501249bea90b9078">setUniformfv</a> (GLint block, GLsizei offset, GLsizei size, const GLfloat *values)</td></tr>
<tr class="separator:a3f181fb47f4f06eb501249bea90b9078"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7731edaf46e80729336400493b19544b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1_uniform_buffer.html#a7731edaf46e80729336400493b19544b">setUniformfv</a> (GLint block, const std::string name, GLsizei size, const GLfloat *values)</td></tr>
<tr class="separator:a7731edaf46e80729336400493b19544b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a25cb2eed88f62b1bb8f3d180cb69e42b"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1_uniform_buffer.html#a25cb2eed88f62b1bb8f3d180cb69e42b">getUniformfv</a> (GLuint block, GLsizei offset, GLsizei size, GLfloat *values) const</td></tr>
<tr class="separator:a25cb2eed88f62b1bb8f3d180cb69e42b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a10eeafae80398f83374e75094e26596e"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1_uniform_buffer.html#a10eeafae80398f83374e75094e26596e">getUniformfv</a> (GLuint block, const std::string name, GLsizei size, GLfloat *values) const</td></tr>
<tr class="separator:a10eeafae80398f83374e75094e26596e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a60e6b165aca7efd45c0a70d9208f23ef"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1_uniform_buffer.html#a60e6b165aca7efd45c0a70d9208f23ef">setUniformiv</a> (GLint block, GLsizei offset, GLsizei size, const GLint *values)</td></tr>
<tr class="separator:a60e6b165aca7efd45c0a70d9208f23ef"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7a5c1971b0f197936989e1387ecc2a2e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1_uniform_buffer.html#a7a5c1971b0f197936989e1387ecc2a2e">setUniformiv</a> (GLint block, const std::string name, GLsizei size, const GLint *values)</td></tr>
<tr class="separator:a7a5c1971b0f197936989e1387ecc2a2e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af7d7f3b9ea4f652a49eba56201237fc0"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1_uniform_buffer.html#af7d7f3b9ea4f652a49eba56201237fc0">getUniformiv</a> (GLuint block, GLsizei offset, GLsizei size, GLint *values) const</td></tr>
<tr class="separator:af7d7f3b9ea4f652a49eba56201237fc0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a98f271b2960a92f6ef68629055b79149"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1_uniform_buffer.html#a98f271b2960a92f6ef68629055b79149">getUniformiv</a> (GLuint block, const std::string name, GLsizei size, GLint *values) const</td></tr>
<tr class="separator:a98f271b2960a92f6ef68629055b79149"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa34011d0cfd0987b621119e472819c0d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1_uniform_buffer.html#aa34011d0cfd0987b621119e472819c0d">setUniformuiv</a> (GLint block, GLsizei offset, GLsizei size, const GLuint *values)</td></tr>
<tr class="separator:aa34011d0cfd0987b621119e472819c0d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a82d59ef3e01db2eb76a74a157ef00a6c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1_uniform_buffer.html#a82d59ef3e01db2eb76a74a157ef00a6c">setUniformuiv</a> (GLint block, const std::string name, GLsizei size, const GLuint *values)</td></tr>
<tr class="separator:a82d59ef3e01db2eb76a74a157ef00a6c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7e563620de2fb4ae8306463b8104dbe5"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1_uniform_buffer.html#a7e563620de2fb4ae8306463b8104dbe5">getUniformuiv</a> (GLuint block, GLsizei offset, GLsizei size, GLuint *values) const</td></tr>
<tr class="separator:a7e563620de2fb4ae8306463b8104dbe5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a355d6b0e62d6a18a6bbcab783100a8d1"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1_uniform_buffer.html#a355d6b0e62d6a18a6bbcab783100a8d1">getUniformuiv</a> (GLuint block, const std::string name, GLsizei size, GLuint *values) const</td></tr>
<tr class="separator:a355d6b0e62d6a18a6bbcab783100a8d1"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-static-methods"></a>
Static Public Member Functions</h2></td></tr>
<tr class="memitem:aee89a389f16aa17ee54e863bf8e26496"><td class="memItemLeft" align="right" valign="top">static std::shared_ptr&lt; <a class="el" href="classcugl_1_1_uniform_buffer.html">UniformBuffer</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1_uniform_buffer.html#aee89a389f16aa17ee54e863bf8e26496">alloc</a> (GLsizei capacity)</td></tr>
<tr class="separator:aee89a389f16aa17ee54e863bf8e26496"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a02ceb0affb7550cb8a3f077759efca94"><td class="memItemLeft" align="right" valign="top">static std::shared_ptr&lt; <a class="el" href="classcugl_1_1_uniform_buffer.html">UniformBuffer</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1_uniform_buffer.html#a02ceb0affb7550cb8a3f077759efca94">alloc</a> (GLsizei capacity, GLuint blocks)</td></tr>
<tr class="separator:a02ceb0affb7550cb8a3f077759efca94"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-static-attribs"></a>
Static Public Attributes</h2></td></tr>
<tr class="memitem:a59861c4ebccea912dd9b32cc101787f8"><td class="memItemLeft" align="right" valign="top">static GLsizei&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1_uniform_buffer.html#a59861c4ebccea912dd9b32cc101787f8">INVALID_OFFSET</a></td></tr>
<tr class="separator:a59861c4ebccea912dd9b32cc101787f8"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>This class defines a uniform block buffer for shader optimization.</p>
<p>Like <a class="el" href="classcugl_1_1_texture.html">Texture</a>, shaders and uniform buffers have a many-to-many relationship. This many-to-many relationship is captured by bind points. A uniform buffer is associated with a bind point and a shader associates a binding point with a uniform struct. That uniform struct then pulls data from the uniform buffer.</p>
<p>When discussing the relationship between a shader and a uniform buffer, we talk about a buffer being bound and a buffer being active. A bound buffer is one that is associated with a shader; the shader will pull from the uniform buffer to populate its uniform variables. An active buffer is one that is capable of receiving data from the CPU. A buffer must be active if the user wants to change any of the data in the buffer. These are two separate concepts and are treated separately in this class.</p>
<p>Technically, a shader is associated with a uniform block, not a uniform buffer, since a uniform buffer may have multiple blocks. In the case of a uniform buffer with multiple blocks, the current block is managed by the method <a class="el" href="classcugl_1_1_uniform_buffer.html#adee489553cacc3a1a31b16ac0c490ebb">setBlock</a>.</p>
<p>Uniform buffers are ideal in two use cases. First of all, they are great for uniforms that are shared across multiple shaders. But it is also worthwhile to have a buffer for a single shader if (1) that shader has a large number of uniforms and (2) those uniforms change semi-frequently through out a render pass. In that case, the uniform buffer should be allocated with enough blocks so that all of the possible uniform values can be assigned at the start of the render pass, each to a different block. Once the shader starts to receive vertices, the uniforms should be managed via the <a class="el" href="classcugl_1_1_uniform_buffer.html#adee489553cacc3a1a31b16ac0c490ebb">setBlock</a> method. </p>
</div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="a6df2acfc29a44a632881f6e8bec6f8b1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6df2acfc29a44a632881f6e8bec6f8b1">&#9670;&nbsp;</a></span>UniformBuffer()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">cugl::UniformBuffer::UniformBuffer </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Creates an uninitialized uniform buffer.</p>
<p>You must initialize the uniform buffer to allocate memory. </p>

</div>
</div>
<a id="a1be46d1dfa079bb430275bcd6a4263b7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1be46d1dfa079bb430275bcd6a4263b7">&#9670;&nbsp;</a></span>~UniformBuffer()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">cugl::UniformBuffer::~UniformBuffer </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Deletes this uniform buffer, disposing all resources. </p>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="a7974ed746e52d57ba810ca509631b41c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7974ed746e52d57ba810ca509631b41c">&#9670;&nbsp;</a></span>activate()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void cugl::UniformBuffer::activate </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Activates this uniform block so that if can receive data.</p>
<p>This method makes this uniform block the active uniform buffer. This means that changes made to the data in this uniform buffer will be pushed to the graphics card. If there were are any pending changes to the uniform buffer (made when it was not active), they will be pushed immediately when this method is called.</p>
<p>This method does not bind the uniform block to a bind point. That must be done with a call to <a class="el" href="classcugl_1_1_uniform_buffer.html#a16230fbbf58106e9e8881da2a86a82b5">bind</a>.</p>
<p>This call is reentrant. If can be safely called multiple times. </p>

</div>
</div>
<a id="aee89a389f16aa17ee54e863bf8e26496"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aee89a389f16aa17ee54e863bf8e26496">&#9670;&nbsp;</a></span>alloc() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static std::shared_ptr&lt;<a class="el" href="classcugl_1_1_uniform_buffer.html">UniformBuffer</a>&gt; cugl::UniformBuffer::alloc </td>
          <td>(</td>
          <td class="paramtype">GLsizei&#160;</td>
          <td class="paramname"><em>capacity</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns a new uniform block to support a block of the given capacity.</p>
<p>This uniform buffer will only support a single block. The block capacity is measured in bytes. In std140 format, all scalars are 4 bytes, vectors are 8 or 16 bytes, and matrices are treated as an array of 8 or 16 byte column vectors.</p>
<p>The drawtype is GL_STATIC_DRAW, GL_DYNAMIC_DRAW, or GL_STREAM_DRAW. If the uniform values change often, the difference between GL_STATIC_DRAW and GL_STREAM_DRAW is 1-2 orders of magnitude.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">capacity</td><td>The block capacity in bytes</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a new uniform block to support a block of the given capacity. </dd></dl>

</div>
</div>
<a id="a02ceb0affb7550cb8a3f077759efca94"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a02ceb0affb7550cb8a3f077759efca94">&#9670;&nbsp;</a></span>alloc() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static std::shared_ptr&lt;<a class="el" href="classcugl_1_1_uniform_buffer.html">UniformBuffer</a>&gt; cugl::UniformBuffer::alloc </td>
          <td>(</td>
          <td class="paramtype">GLsizei&#160;</td>
          <td class="paramname"><em>capacity</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">GLuint&#160;</td>
          <td class="paramname"><em>blocks</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns a new uniform buffer to support multiple blocks of the given capacity.</p>
<p>The block capacity is measured in bytes. In std140 format, all scalars are 4 bytes, vectors are 8 or 16 bytes, and matrices are treated as an array of 8 or 16 byte column vectors.</p>
<p>Keep in mind that uniform buffer blocks must be aligned, and so this may take significantly more memory than the number of blocks times the capacity. If the graphics card cannot support that many blocks, this method will return nullptr.</p>
<p>The drawtype is GL_STATIC_DRAW, GL_DYNAMIC_DRAW, or GL_STREAM_DRAW. If the uniform values change often, the difference between GL_STATIC_DRAW and GL_STREAM_DRAW is 1-2 orders of magnitude.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">capacity</td><td>The block capacity in bytes </td></tr>
    <tr><td class="paramname">blocks</td><td>The number of blocks to support</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a new uniform buffer to support multiple blocks of the given capacity. </dd></dl>

</div>
</div>
<a id="a16230fbbf58106e9e8881da2a86a82b5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a16230fbbf58106e9e8881da2a86a82b5">&#9670;&nbsp;</a></span>bind()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void cugl::UniformBuffer::bind </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>activate</em> = <code>true</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Binds this uniform buffer to its bind point.</p>
<p>Unlike <a class="el" href="classcugl_1_1_texture.html">Texture</a>, it is possible to bind a uniform buffer to its bind point without making it the active uniform buffer. An inactive buffer will still stream data to the shader, though its data cannot be altered without making it active.</p>
<p>Binding a buffer to a bind point replaces the uniform block originally there. So this buffer can be unbound without a call to <a class="el" href="classcugl_1_1_uniform_buffer.html#af4dd4de6563477582eae6a04c666f96e">unbind</a>. However, if another buffer is bound to a different bind point than this block, it will not affect this buffer's relationship with the shader.</p>
<p>For compatibility reasons with <a class="el" href="classcugl_1_1_texture.html">Texture</a> we allow this method to both bind and activate the uniform buffer in one call.</p>
<p>This call is reentrant. If can be safely called multiple times.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">activate</td><td>Whether to activate this buffer in addition to binding. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="adb7bf9cb16825a743de8b30779d1d66b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adb7bf9cb16825a743de8b30779d1d66b">&#9670;&nbsp;</a></span>deactivate()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void cugl::UniformBuffer::deactivate </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Deactivates this uniform block, making it no longer active.</p>
<p>This method will not unbind the buffer from its bind point (assuming it is bound to one). It simply means that it is no longer the active uniform buffer and cannot receive new data. Data sent to this buffer will be cached and sent to the graphics card once the buffer is reactivated. However, the shader will use the current graphics card data until that happens.</p>
<p>This call is reentrant. If can be safely called multiple times. </p>

</div>
</div>
<a id="a7549945d0e6ad989e8a18f3dd2af1f84"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7549945d0e6ad989e8a18f3dd2af1f84">&#9670;&nbsp;</a></span>dispose()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void cugl::UniformBuffer::dispose </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Deletes the uniform buffer, freeing all resources.</p>
<p>You must reinitialize the uniform buffer to use it. </p>

</div>
</div>
<a id="aa66e2e1025f650d84101d35991ebac10"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa66e2e1025f650d84101d35991ebac10">&#9670;&nbsp;</a></span>flush()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void cugl::UniformBuffer::flush </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Flushes any changes in the backing byte buffer to the graphics card.</p>
<p>This method must be called if any changes have been made to the buffer data and auto-flush is not turned on (which is the default). Even if auto-flush is turned on, it must be called if the user has accessed the backing byte buffer directly via <a class="el" href="classcugl_1_1_uniform_buffer.html#a751b11f89e7b56e36d76a026fa129c40">getData</a>.</p>
<p>This method requires the byte buffer to be active. </p>

</div>
</div>
<a id="a9a3369ffdfd5c97bc3d8cfe15871f9ac"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9a3369ffdfd5c97bc3d8cfe15871f9ac">&#9670;&nbsp;</a></span>getAutoflush()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool cugl::UniformBuffer::getAutoflush </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns true if this uniform buffer supports autoflushing.</p>
<p>Active, auto-flushed buffers write data directly to the graphics card as soon as it is provided to the buffer. A buffer than does not auto-flush will not write to the graphics card until <a class="el" href="classcugl_1_1_uniform_buffer.html#aa66e2e1025f650d84101d35991ebac10">flush</a> is called, even if it is active.</p>
<p>By default, autoflushing is turned off.</p>
<dl class="section return"><dt>Returns</dt><dd>true if this uniform buffer supports autoflushing. </dd></dl>

</div>
</div>
<a id="a3b25c17e3f3f7df5a77d5af44501c44a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3b25c17e3f3f7df5a77d5af44501c44a">&#9670;&nbsp;</a></span>getBindPoint()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">GLuint cugl::UniformBuffer::getBindPoint </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns the bind point for this uniform buffer.</p>
<p>Uniform buffers and shaders have a many-to-many relationship. This means that connecting them requires an intermediate table. The positions in this table are called bind points. A uniform buffer is associated with a bind point and a shader associates a bind point with a uniform struct. That uniform struct then pulls data from the active block of the uniform buffer. By default this value is 0.</p>
<dl class="section return"><dt>Returns</dt><dd>the bind point for for this uniform block. </dd></dl>

</div>
</div>
<a id="a493d45001989fa69263b782ff3342d94"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a493d45001989fa69263b782ff3342d94">&#9670;&nbsp;</a></span>getBlock()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">GLuint cugl::UniformBuffer::getBlock </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns the active uniform block in this buffer.</p>
<p>The active uniform block is the block from which the shader will pull uniform values. This value can be altered even if the buffer is not active (or even bound)</p>
<dl class="section return"><dt>Returns</dt><dd>the active uniform block in this buffer. </dd></dl>

</div>
</div>
<a id="a60998a2b0cd7243e20d12469ee60328f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a60998a2b0cd7243e20d12469ee60328f">&#9670;&nbsp;</a></span>getBlockCount()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">GLuint cugl::UniformBuffer::getBlockCount </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns the number of blocks supported by this buffer.</p>
<p>A uniform buffer can support multiple uniform blocks at once. The active block is identify by the method <a class="el" href="classcugl_1_1_uniform_buffer.html#a493d45001989fa69263b782ff3342d94">getBlock</a>.</p>
<dl class="section return"><dt>Returns</dt><dd>the number of blocks supported by this buffer. </dd></dl>

</div>
</div>
<a id="acffec26117318df5c4ed59e23dfe84dc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acffec26117318df5c4ed59e23dfe84dc">&#9670;&nbsp;</a></span>getBlockSize()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">GLsizei cugl::UniformBuffer::getBlockSize </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns the capacity of a single block in this uniform buffer.</p>
<p>The block size is the amount of data necessary to populate the uniforms for a single block. It is measured in bytes.</p>
<dl class="section return"><dt>Returns</dt><dd>the capacity of a single block in this uniform buffer. </dd></dl>

</div>
</div>
<a id="a3a9142b71cc559e42e1e051f7c0c4eae"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3a9142b71cc559e42e1e051f7c0c4eae">&#9670;&nbsp;</a></span>getBlockStride()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">GLsizei cugl::UniformBuffer::getBlockStride </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns the stride of a single block in this uniform buffer.</p>
<p>The stride measures the alignment (in bytes) of a block. It is at least as large as the block capacity, but may be more.</p>
<dl class="section return"><dt>Returns</dt><dd>the stride of a single block in this uniform buffer. </dd></dl>

</div>
</div>
<a id="af369c5096161873d307f4a2fe65193bb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af369c5096161873d307f4a2fe65193bb">&#9670;&nbsp;</a></span>getBuffer()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">GLuint cugl::UniformBuffer::getBuffer </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns the OpenGL buffer for this uniform buffer.</p>
<p>The buffer is a value assigned by OpenGL when the uniform buffer was allocated. This method will return 0 if the block is not initialized. This method is provided to allow the user direct access to the buffer for maximum flexibility.</p>
<dl class="section return"><dt>Returns</dt><dd>the OpenGL buffer for this unform block. </dd></dl>

</div>
</div>
<a id="a751b11f89e7b56e36d76a026fa129c40"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a751b11f89e7b56e36d76a026fa129c40">&#9670;&nbsp;</a></span>getData()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">char* cugl::UniformBuffer::getData </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns the backing byte-buffer for the uniform buffer</p>
<p>The byte buffer is used to store pending changes while the buffer is active (and is kept synchronized when it is active). This method allows direct access for bulk writes the buffer. However, the graphics card will not be aware of any of these changes until <a class="el" href="classcugl_1_1_uniform_buffer.html#aa66e2e1025f650d84101d35991ebac10">flush()</a> is called.</p>
<p>The buffer returned will have a capacity of (block count) x (block stride).</p>
<dl class="section return"><dt>Returns</dt><dd>the backing byte-buffer for the uniform buffer </dd></dl>

</div>
</div>
<a id="a20bb17bed4873a29e6d74a53ef4e1c03"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a20bb17bed4873a29e6d74a53ef4e1c03">&#9670;&nbsp;</a></span>getDrawType()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">GLenum cugl::UniformBuffer::getDrawType </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns the draw type for this buffer</p>
<p>The drawtype is GL_STATIC_DRAW, GL_DYNAMIC_DRAW, or GL_STREAM_DRAW. If the uniform values change often, the difference between GL_STATIC_DRAW and GL_STREAM_DRAW is 1-2 orders of magnitude.</p>
<p>By default, the draw type is GL_STREAM_DRAW.</p>
<dl class="section return"><dt>Returns</dt><dd>the draw type for this buffer </dd></dl>

</div>
</div>
<a id="aba2868f5cb7cf42be2a1b9abbf9dcb4c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aba2868f5cb7cf42be2a1b9abbf9dcb4c">&#9670;&nbsp;</a></span>getName()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const std::string&amp; cugl::UniformBuffer::getName </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns the name of this uniform buffer.</p>
<p>A name is a user-defined way of identifying a buffer. It is typically the appropriate shader variable name, but this is not necessary for it to function properly.</p>
<dl class="section return"><dt>Returns</dt><dd>the name of this uniform block. </dd></dl>

</div>
</div>
<a id="a436f81a164c289cc2cf531234be2450b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a436f81a164c289cc2cf531234be2450b">&#9670;&nbsp;</a></span>getOffset()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">GLsizei cugl::UniformBuffer::getOffset </td>
          <td>(</td>
          <td class="paramtype">const std::string&#160;</td>
          <td class="paramname"><em>name</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns the byte offset for the given name.</p>
<p>This method requires that name be previously associated with an offset via <a class="el" href="classcugl_1_1_uniform_buffer.html#aed42e022b292a290dc9447e02c9240a2">setOffset</a>. If it has not been associated with an offset, then this method will return <a class="el" href="classcugl_1_1_uniform_buffer.html#a59861c4ebccea912dd9b32cc101787f8">INVALID_OFFSET</a> instead.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">name</td><td>The variable name to query for an offset</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the byte offset of the given struct variable. </dd></dl>

</div>
</div>
<a id="af69bc16e9ab02e898c82b7b1fc77d09b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af69bc16e9ab02e898c82b7b1fc77d09b">&#9670;&nbsp;</a></span>getOffsets()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;std::string&gt; cugl::UniformBuffer::getOffsets </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns the offsets defined for this buffer</p>
<p>The vector returned will include the name of every variable set by the method <a class="el" href="classcugl_1_1_uniform_buffer.html#aed42e022b292a290dc9447e02c9240a2">setOffset</a>.</p>
<dl class="section return"><dt>Returns</dt><dd>the offsets defined for this buffer </dd></dl>

</div>
</div>
<a id="a1b923c0af38f19b329df0bcd35e5c85b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1b923c0af38f19b329df0bcd35e5c85b">&#9670;&nbsp;</a></span>getUniformAffine2() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool cugl::UniformBuffer::getUniformAffine2 </td>
          <td>(</td>
          <td class="paramtype">GLuint&#160;</td>
          <td class="paramname"><em>block</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classcugl_1_1_affine2.html">Affine2</a> &amp;&#160;</td>
          <td class="paramname"><em>mat</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns true if it can access the given uniform variable as an affine transform.</p>
<p>Affine transforms are read from a uniform block as a 4x3 matrix on homogenous coordinates. That is because the columns must be 4*sizeof(float) bytes for alignment reasons. The buffer must have 12*sizeof(float) bytes available for this read.</p>
<p>This method requires that the uniform name be previously bound to a byte offset with the call <a class="el" href="classcugl_1_1_uniform_buffer.html#aed42e022b292a290dc9447e02c9240a2">setOffset</a>. The buffer does not have to be active to call this method. If it is not active and there are pending changes to this uniform variable, this method will read those changes and not the current value in the graphics card.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">block</td><td>The block in this uniform buffer to access </td></tr>
    <tr><td class="paramname">name</td><td>The name of the uniform variable </td></tr>
    <tr><td class="paramname">mat</td><td>The matrix to store the result</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if it can access the given uniform variable as an affine transform. </dd></dl>

</div>
</div>
<a id="aaf73e69021c2fb108c4e40103f67cee5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaf73e69021c2fb108c4e40103f67cee5">&#9670;&nbsp;</a></span>getUniformAffine2() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool cugl::UniformBuffer::getUniformAffine2 </td>
          <td>(</td>
          <td class="paramtype">GLuint&#160;</td>
          <td class="paramname"><em>block</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">GLsizei&#160;</td>
          <td class="paramname"><em>offset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classcugl_1_1_affine2.html">Affine2</a> &amp;&#160;</td>
          <td class="paramname"><em>mat</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns true if it can access the given uniform variable as an affine transform.</p>
<p>Affine transforms are read from a uniform block as a 4x3 matrix on homogenous coordinates. That is because the columns must be 4*sizeof(float) bytes for alignment reasons. The buffer must have 12*sizeof(float) bytes available for this read.</p>
<p>The buffer does not have to be active to call this method. If it is not active and there are pending changes to this uniform variable, this method will read those changes and not the current value in the graphics card.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">block</td><td>The block in this uniform buffer to access </td></tr>
    <tr><td class="paramname">offset</td><td>The offset within the block </td></tr>
    <tr><td class="paramname">mat</td><td>The matrix to store the result</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if it can access the given uniform variable as an affine transform. </dd></dl>

</div>
</div>
<a id="a42d2313a343d7d31aa28bb88bd810020"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a42d2313a343d7d31aa28bb88bd810020">&#9670;&nbsp;</a></span>getUniformColor4() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool cugl::UniformBuffer::getUniformColor4 </td>
          <td>(</td>
          <td class="paramtype">GLuint&#160;</td>
          <td class="paramname"><em>block</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classcugl_1_1_color4.html">Color4</a> &amp;&#160;</td>
          <td class="paramname"><em>color</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns true if it can access the given uniform variable as a color.</p>
<p>This method requires that the uniform name be previously bound to a byte offset with the call <a class="el" href="classcugl_1_1_uniform_buffer.html#aed42e022b292a290dc9447e02c9240a2">setOffset</a>. This method will read the color as 4*sizeof(float) bytes to the appropriate buffer location (and the buffer must have the appropriate capacity).</p>
<p>The buffer does not have to be active to call this method. If it is not active and there are pending changes to this uniform variable, this method will read those changes and not the current value in the graphics card.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">block</td><td>The block in this uniform buffer to access </td></tr>
    <tr><td class="paramname">name</td><td>The name of the uniform variable </td></tr>
    <tr><td class="paramname">color</td><td>The color to store the result</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if it can access the given uniform variable as a vector. </dd></dl>

</div>
</div>
<a id="aaf917141168bdee807e888f925f75480"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaf917141168bdee807e888f925f75480">&#9670;&nbsp;</a></span>getUniformColor4() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool cugl::UniformBuffer::getUniformColor4 </td>
          <td>(</td>
          <td class="paramtype">GLuint&#160;</td>
          <td class="paramname"><em>block</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">GLsizei&#160;</td>
          <td class="paramname"><em>offset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classcugl_1_1_color4.html">Color4</a> &amp;&#160;</td>
          <td class="paramname"><em>color</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns true if it can access the given uniform variable as a color.</p>
<p>This method will read the color as 4*sizeof(float) bytes to the appropriate buffer location (and the buffer must have the appropriate capacity).</p>
<p>The buffer does not have to be active to call this method. If it is not active and there are pending changes to this uniform variable, this method will read those changes and not the current value in the graphics card.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">block</td><td>The block in this uniform buffer to access </td></tr>
    <tr><td class="paramname">offset</td><td>The offset within the block </td></tr>
    <tr><td class="paramname">color</td><td>The color to store the result</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if it can access the given uniform variable as a color. </dd></dl>

</div>
</div>
<a id="ae8ee157471e06dec9c384797d1c1ca5b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae8ee157471e06dec9c384797d1c1ca5b">&#9670;&nbsp;</a></span>getUniformColor4f() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool cugl::UniformBuffer::getUniformColor4f </td>
          <td>(</td>
          <td class="paramtype">GLuint&#160;</td>
          <td class="paramname"><em>block</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classcugl_1_1_color4f.html">Color4f</a> &amp;&#160;</td>
          <td class="paramname"><em>color</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns true if it can access the given uniform variable as a color.</p>
<p>This method requires that the uniform name be previously bound to a byte offset with the call <a class="el" href="classcugl_1_1_uniform_buffer.html#aed42e022b292a290dc9447e02c9240a2">setOffset</a>. This method will read the color as 4*sizeof(float) bytes to the appropriate buffer location (and the buffer must have the appropriate capacity).</p>
<p>The buffer does not have to be active to call this method. If it is not active and there are pending changes to this uniform variable, this method will read those changes and not the current value in the graphics card.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">block</td><td>The block in this uniform buffer to access </td></tr>
    <tr><td class="paramname">name</td><td>The name of the uniform variable </td></tr>
    <tr><td class="paramname">color</td><td>The color to store the result</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if it can access the given uniform variable as a color. </dd></dl>

</div>
</div>
<a id="afb92a19678fc78d55d24c864f3ac33c4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afb92a19678fc78d55d24c864f3ac33c4">&#9670;&nbsp;</a></span>getUniformColor4f() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool cugl::UniformBuffer::getUniformColor4f </td>
          <td>(</td>
          <td class="paramtype">GLuint&#160;</td>
          <td class="paramname"><em>block</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">GLsizei&#160;</td>
          <td class="paramname"><em>offset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classcugl_1_1_color4f.html">Color4f</a> &amp;&#160;</td>
          <td class="paramname"><em>color</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns true if it can access the given uniform variable as a color.</p>
<p>This method will read the color as 4*sizeof(float) bytes to the appropriate buffer location (and the buffer must have the appropriate capacity).</p>
<p>The buffer does not have to be active to call this method. If it is not active and there are pending changes to this uniform variable, this method will read those changes and not the current value in the graphics card.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">block</td><td>The block in this uniform buffer to access </td></tr>
    <tr><td class="paramname">offset</td><td>The offset within the block </td></tr>
    <tr><td class="paramname">color</td><td>The color to store the result</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if it can access the given uniform variable as a color. </dd></dl>

</div>
</div>
<a id="a10eeafae80398f83374e75094e26596e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a10eeafae80398f83374e75094e26596e">&#9670;&nbsp;</a></span>getUniformfv() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool cugl::UniformBuffer::getUniformfv </td>
          <td>(</td>
          <td class="paramtype">GLuint&#160;</td>
          <td class="paramname"><em>block</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">GLsizei&#160;</td>
          <td class="paramname"><em>size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">GLfloat *&#160;</td>
          <td class="paramname"><em>values</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns true if it can access the given buffer location as an array of floats</p>
<p>This method requires that the uniform name be previously bound to a byte offset with the call <a class="el" href="classcugl_1_1_uniform_buffer.html#aed42e022b292a290dc9447e02c9240a2">setOffset</a>. The buffer does not have to be active to call this method. If it is not active and there are pending changes to this uniform variable, this method will read those changes and not the current value in the graphics card.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">block</td><td>The block in this uniform buffer to access </td></tr>
    <tr><td class="paramname">name</td><td>The name of the uniform variable </td></tr>
    <tr><td class="paramname">size</td><td>The available size of the value array </td></tr>
    <tr><td class="paramname">values</td><td>The array to receive the values</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if data was successfully read into values </dd></dl>

</div>
</div>
<a id="a25cb2eed88f62b1bb8f3d180cb69e42b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a25cb2eed88f62b1bb8f3d180cb69e42b">&#9670;&nbsp;</a></span>getUniformfv() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool cugl::UniformBuffer::getUniformfv </td>
          <td>(</td>
          <td class="paramtype">GLuint&#160;</td>
          <td class="paramname"><em>block</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">GLsizei&#160;</td>
          <td class="paramname"><em>offset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">GLsizei&#160;</td>
          <td class="paramname"><em>size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">GLfloat *&#160;</td>
          <td class="paramname"><em>values</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns true if it can access the given buffer offset as an array of floats</p>
<p>The buffer does not have to be active to call this method. If it is not active and there are pending changes to this uniform variable, this method will read those changes and not the current value in the graphics card.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">block</td><td>The block in this uniform buffer to access </td></tr>
    <tr><td class="paramname">offset</td><td>The offset within the block </td></tr>
    <tr><td class="paramname">size</td><td>The available size of the value array </td></tr>
    <tr><td class="paramname">values</td><td>The array to receive the values</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if data was successfully read into values </dd></dl>

</div>
</div>
<a id="a98f271b2960a92f6ef68629055b79149"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a98f271b2960a92f6ef68629055b79149">&#9670;&nbsp;</a></span>getUniformiv() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool cugl::UniformBuffer::getUniformiv </td>
          <td>(</td>
          <td class="paramtype">GLuint&#160;</td>
          <td class="paramname"><em>block</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">GLsizei&#160;</td>
          <td class="paramname"><em>size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">GLint *&#160;</td>
          <td class="paramname"><em>values</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns true if it can access the given buffer location as an array of integers</p>
<p>This method requires that the uniform name be previously bound to a byte offset with the call <a class="el" href="classcugl_1_1_uniform_buffer.html#aed42e022b292a290dc9447e02c9240a2">setOffset</a>. The buffer does not have to be active to call this method. If it is not active and there are pending changes to this uniform variable, this method will read those changes and not the current value in the graphics card.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">block</td><td>The block in this uniform buffer to access </td></tr>
    <tr><td class="paramname">name</td><td>The name of the uniform variable </td></tr>
    <tr><td class="paramname">size</td><td>The available size of the value array </td></tr>
    <tr><td class="paramname">values</td><td>The array to receive the values</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if data was successfully read into values </dd></dl>

</div>
</div>
<a id="af7d7f3b9ea4f652a49eba56201237fc0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af7d7f3b9ea4f652a49eba56201237fc0">&#9670;&nbsp;</a></span>getUniformiv() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool cugl::UniformBuffer::getUniformiv </td>
          <td>(</td>
          <td class="paramtype">GLuint&#160;</td>
          <td class="paramname"><em>block</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">GLsizei&#160;</td>
          <td class="paramname"><em>offset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">GLsizei&#160;</td>
          <td class="paramname"><em>size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">GLint *&#160;</td>
          <td class="paramname"><em>values</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns true if it can access the given buffer offset as an array of integers</p>
<p>The buffer does not have to be active to call this method. If it is not active and there are pending changes to this uniform variable, this method will read those changes and not the current value in the graphics card.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">block</td><td>The block in this uniform buffer to access </td></tr>
    <tr><td class="paramname">offset</td><td>The offset within the block </td></tr>
    <tr><td class="paramname">size</td><td>The available size of the value array </td></tr>
    <tr><td class="paramname">values</td><td>The array to receive the values</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if data was successfully read into values </dd></dl>

</div>
</div>
<a id="a4a414b17bf6c41f6786b895410757030"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4a414b17bf6c41f6786b895410757030">&#9670;&nbsp;</a></span>getUniformMat4() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool cugl::UniformBuffer::getUniformMat4 </td>
          <td>(</td>
          <td class="paramtype">GLuint&#160;</td>
          <td class="paramname"><em>block</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classcugl_1_1_mat4.html">Mat4</a> &amp;&#160;</td>
          <td class="paramname"><em>mat</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns true if it can access the given uniform variable as a matrix.</p>
<p>This method requires that the uniform name be previously bound to a byte offset with the call <a class="el" href="classcugl_1_1_uniform_buffer.html#aed42e022b292a290dc9447e02c9240a2">setOffset</a>. This method will read the matrix as 16*sizeof(float) bytes to the appropriate buffer location (and the buffer must have the appropriate capacity).</p>
<p>The buffer does not have to be active to call this method. If it is not active and there are pending changes to this uniform variable, this method will read those changes and not the current value in the graphics card.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">block</td><td>The block in this uniform buffer to access </td></tr>
    <tr><td class="paramname">name</td><td>The name of the uniform variable </td></tr>
    <tr><td class="paramname">mat</td><td>The matrix to store the result</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if it can access the given uniform variable as a matrix. </dd></dl>

</div>
</div>
<a id="a6efdd633e8b50074f6062a950534745e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6efdd633e8b50074f6062a950534745e">&#9670;&nbsp;</a></span>getUniformMat4() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool cugl::UniformBuffer::getUniformMat4 </td>
          <td>(</td>
          <td class="paramtype">GLuint&#160;</td>
          <td class="paramname"><em>block</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">GLsizei&#160;</td>
          <td class="paramname"><em>offset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classcugl_1_1_mat4.html">Mat4</a> &amp;&#160;</td>
          <td class="paramname"><em>mat</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns true if it can access the given uniform variable as a matrix.</p>
<p>This method will read the matrix as 16*sizeof(float) bytes to the appropriate buffer location (and the buffer must have the appropriate capacity).</p>
<p>The buffer does not have to be active to call this method. If it is not active and there are pending changes to this uniform variable, this method will read those changes and not the current value in the graphics card.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">block</td><td>The block in this uniform buffer to access </td></tr>
    <tr><td class="paramname">offset</td><td>The offset within the block </td></tr>
    <tr><td class="paramname">mat</td><td>The matrix to store the result</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if it can access the given uniform variable as a matrix. </dd></dl>

</div>
</div>
<a id="ad28201c16e7d2710929bb00df20e1d41"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad28201c16e7d2710929bb00df20e1d41">&#9670;&nbsp;</a></span>getUniformQuaternion() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool cugl::UniformBuffer::getUniformQuaternion </td>
          <td>(</td>
          <td class="paramtype">GLuint&#160;</td>
          <td class="paramname"><em>block</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classcugl_1_1_quaternion.html">Quaternion</a> &amp;&#160;</td>
          <td class="paramname"><em>quat</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns true if it can access the given uniform variable as a quaternion.</p>
<p>This method requires that the uniform name be previously bound to a byte offset with the call <a class="el" href="classcugl_1_1_uniform_buffer.html#aed42e022b292a290dc9447e02c9240a2">setOffset</a>. This method will read the quaternion as 4*sizeof(float) bytes to the appropriate buffer location (and the buffer must have the appropriate capacity).</p>
<p>The buffer does not have to be active to call this method. If it is not active and there are pending changes to this uniform variable, this method will read those changes and not the current value in the graphics card.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">block</td><td>The block in this uniform buffer to access </td></tr>
    <tr><td class="paramname">name</td><td>The name of the uniform variable </td></tr>
    <tr><td class="paramname">quat</td><td>The quaternion to store the result</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if it can access the given uniform variable as a quaternion. </dd></dl>

</div>
</div>
<a id="abef5d36832880437b9dff598a20722cc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abef5d36832880437b9dff598a20722cc">&#9670;&nbsp;</a></span>getUniformQuaternion() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool cugl::UniformBuffer::getUniformQuaternion </td>
          <td>(</td>
          <td class="paramtype">GLuint&#160;</td>
          <td class="paramname"><em>block</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">GLsizei&#160;</td>
          <td class="paramname"><em>offset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classcugl_1_1_quaternion.html">Quaternion</a> &amp;&#160;</td>
          <td class="paramname"><em>quat</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns true if it can access the given uniform variable as a quaternion.</p>
<p>This method will read the quaternion as 4*sizeof(float) bytes to the appropriate buffer location (and the buffer must have the appropriate capacity).</p>
<p>The buffer does not have to be active to call this method. If it is not active and there are pending changes to this uniform variable, this method will read those changes and not the current value in the graphics card.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">block</td><td>The block in this uniform buffer to access </td></tr>
    <tr><td class="paramname">offset</td><td>The offset within the block </td></tr>
    <tr><td class="paramname">quat</td><td>The quaternion to store the result</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if it can access the given uniform variable as a quaternion. </dd></dl>

</div>
</div>
<a id="a355d6b0e62d6a18a6bbcab783100a8d1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a355d6b0e62d6a18a6bbcab783100a8d1">&#9670;&nbsp;</a></span>getUniformuiv() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool cugl::UniformBuffer::getUniformuiv </td>
          <td>(</td>
          <td class="paramtype">GLuint&#160;</td>
          <td class="paramname"><em>block</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">GLsizei&#160;</td>
          <td class="paramname"><em>size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">GLuint *&#160;</td>
          <td class="paramname"><em>values</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns true if it can access the buffer location as an array of unsigned integers</p>
<p>This method requires that the uniform name be previously bound to a byte offset with the call <a class="el" href="classcugl_1_1_uniform_buffer.html#aed42e022b292a290dc9447e02c9240a2">setOffset</a>. The buffer does not have to be active to call this method. If it is not active and there are pending changes to this uniform variable, this method will read those changes and not the current value in the graphics card.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">block</td><td>The block in this uniform buffer to access </td></tr>
    <tr><td class="paramname">name</td><td>The name of the uniform variable </td></tr>
    <tr><td class="paramname">size</td><td>The available size of the value array </td></tr>
    <tr><td class="paramname">values</td><td>The array to receive the values</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if data was successfully read into values </dd></dl>

</div>
</div>
<a id="a7e563620de2fb4ae8306463b8104dbe5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7e563620de2fb4ae8306463b8104dbe5">&#9670;&nbsp;</a></span>getUniformuiv() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool cugl::UniformBuffer::getUniformuiv </td>
          <td>(</td>
          <td class="paramtype">GLuint&#160;</td>
          <td class="paramname"><em>block</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">GLsizei&#160;</td>
          <td class="paramname"><em>offset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">GLsizei&#160;</td>
          <td class="paramname"><em>size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">GLuint *&#160;</td>
          <td class="paramname"><em>values</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns true if it can access the buffer offset as an array of unsigned integers</p>
<p>The buffer does not have to be active to call this method. If it is not active and there are pending changes to this uniform variable, this method will read those changes and not the current value in the graphics card.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">block</td><td>The block in this uniform buffer to access </td></tr>
    <tr><td class="paramname">offset</td><td>The offset within the block </td></tr>
    <tr><td class="paramname">size</td><td>The available size of the value array </td></tr>
    <tr><td class="paramname">values</td><td>The array to receive the values</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if data was successfully read into values </dd></dl>

</div>
</div>
<a id="a3d360d4a4be43f62eb287d9081ab67e9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3d360d4a4be43f62eb287d9081ab67e9">&#9670;&nbsp;</a></span>getUniformVec2() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool cugl::UniformBuffer::getUniformVec2 </td>
          <td>(</td>
          <td class="paramtype">GLuint&#160;</td>
          <td class="paramname"><em>block</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classcugl_1_1_vec2.html">Vec2</a> &amp;&#160;</td>
          <td class="paramname"><em>vec</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns true if it can access the given uniform variable as a vector.</p>
<p>This method requires that the uniform name be previously bound to a byte offset with the call <a class="el" href="classcugl_1_1_uniform_buffer.html#aed42e022b292a290dc9447e02c9240a2">setOffset</a>. This method will read the vector as 2*sizeof(float) bytes to the appropriate buffer location (and the buffer must have the appropriate capacity).</p>
<p>The buffer does not have to be active to call this method. If it is not active and there are pending changes to this uniform variable, this method will read those changes and not the current value in the graphics card.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">block</td><td>The block in this uniform buffer to access </td></tr>
    <tr><td class="paramname">name</td><td>The name of the uniform variable </td></tr>
    <tr><td class="paramname">vec</td><td>The vector to store the result</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if it can access the given uniform variable as a vector. </dd></dl>

</div>
</div>
<a id="ab80e96cd1f47a1283805ad0016056bf3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab80e96cd1f47a1283805ad0016056bf3">&#9670;&nbsp;</a></span>getUniformVec2() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool cugl::UniformBuffer::getUniformVec2 </td>
          <td>(</td>
          <td class="paramtype">GLuint&#160;</td>
          <td class="paramname"><em>block</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">GLsizei&#160;</td>
          <td class="paramname"><em>offset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classcugl_1_1_vec2.html">Vec2</a> &amp;&#160;</td>
          <td class="paramname"><em>vec</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns true if it can access the given uniform variable as a vector.</p>
<p>This method will read the vector as 2*sizeof(float) bytes to the appropriate buffer location (and the buffer must have the appropriate capacity).</p>
<p>The buffer does not have to be active to call this method. If it is not active and there are pending changes to this uniform variable, this method will read those changes and not the current value in the graphics card.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">block</td><td>The block in this uniform buffer to access </td></tr>
    <tr><td class="paramname">offset</td><td>The offset within the block </td></tr>
    <tr><td class="paramname">vec</td><td>The vector to store the result</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if it can access the given uniform variable as a vector. </dd></dl>

</div>
</div>
<a id="a2eac01c4d8e52cefce2e85092886351f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2eac01c4d8e52cefce2e85092886351f">&#9670;&nbsp;</a></span>getUniformVec3() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool cugl::UniformBuffer::getUniformVec3 </td>
          <td>(</td>
          <td class="paramtype">GLuint&#160;</td>
          <td class="paramname"><em>block</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classcugl_1_1_vec3.html">Vec3</a> &amp;&#160;</td>
          <td class="paramname"><em>vec</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns true if it can access the given uniform variable as a vector.</p>
<p>This method requires that the uniform name be previously bound to a byte offset with the call <a class="el" href="classcugl_1_1_uniform_buffer.html#aed42e022b292a290dc9447e02c9240a2">setOffset</a>. This method will read the vector as 3*sizeof(float) bytes to the appropriate buffer location (and the buffer must have the appropriate capacity).</p>
<p>The buffer does not have to be active to call this method. If it is not active and there are pending changes to this uniform variable, this method will read those changes and not the current value in the graphics card.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">block</td><td>The block in this uniform buffer to access </td></tr>
    <tr><td class="paramname">name</td><td>The name of the uniform variable </td></tr>
    <tr><td class="paramname">vec</td><td>The vector to store the result</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if it can access the given uniform variable as a vector. </dd></dl>

</div>
</div>
<a id="a508b60eee43b492033c16fef84023381"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a508b60eee43b492033c16fef84023381">&#9670;&nbsp;</a></span>getUniformVec3() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool cugl::UniformBuffer::getUniformVec3 </td>
          <td>(</td>
          <td class="paramtype">GLuint&#160;</td>
          <td class="paramname"><em>block</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">GLsizei&#160;</td>
          <td class="paramname"><em>offset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classcugl_1_1_vec3.html">Vec3</a> &amp;&#160;</td>
          <td class="paramname"><em>vec</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns true if it can access the given uniform variable as a vector.</p>
<p>This method will read the vector as 3*sizeof(float) bytes to the appropriate buffer location (and the buffer must have the appropriate capacity).</p>
<p>The buffer does not have to be active to call this method. If it is not active and there are pending changes to this uniform variable, this method will read those changes and not the current value in the graphics card.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">block</td><td>The block in this uniform buffer to access </td></tr>
    <tr><td class="paramname">offset</td><td>The offset within the block </td></tr>
    <tr><td class="paramname">vec</td><td>The vector to store the result</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if it can access the given uniform variable as a vector. </dd></dl>

</div>
</div>
<a id="ab7a9c069eb155c074b2b455da49b244f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab7a9c069eb155c074b2b455da49b244f">&#9670;&nbsp;</a></span>getUniformVec4() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool cugl::UniformBuffer::getUniformVec4 </td>
          <td>(</td>
          <td class="paramtype">GLuint&#160;</td>
          <td class="paramname"><em>block</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classcugl_1_1_vec4.html">Vec4</a> &amp;&#160;</td>
          <td class="paramname"><em>vec</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns true if it can access the given uniform variable as a vector.</p>
<p>This method requires that the uniform name be previously bound to a byte offset with the call <a class="el" href="classcugl_1_1_uniform_buffer.html#aed42e022b292a290dc9447e02c9240a2">setOffset</a>. This method will read the vector as 4*sizeof(float) bytes to the appropriate buffer location (and the buffer must have the appropriate capacity).</p>
<p>The buffer does not have to be active to call this method. If it is not active and there are pending changes to this uniform variable, this method will read those changes and not the current value in the graphics card.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">block</td><td>The block in this uniform buffer to access </td></tr>
    <tr><td class="paramname">name</td><td>The name of the uniform variable </td></tr>
    <tr><td class="paramname">vec</td><td>The vector to store the result</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if it can access the given uniform variable as a vector. </dd></dl>

</div>
</div>
<a id="a996f1b35ea549c56ba83995ecc912a0d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a996f1b35ea549c56ba83995ecc912a0d">&#9670;&nbsp;</a></span>getUniformVec4() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool cugl::UniformBuffer::getUniformVec4 </td>
          <td>(</td>
          <td class="paramtype">GLuint&#160;</td>
          <td class="paramname"><em>block</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">GLsizei&#160;</td>
          <td class="paramname"><em>offset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classcugl_1_1_vec4.html">Vec4</a> &amp;&#160;</td>
          <td class="paramname"><em>vec</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns true if it can access the given uniform variable as a vector.</p>
<p>This method will read the vector as 4*sizeof(float) bytes to the appropriate buffer location (and the buffer must have the appropriate capacity).</p>
<p>The buffer does not have to be active to call this method. If it is not active and there are pending changes to this uniform variable, this method will read those changes and not the current value in the graphics card.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">block</td><td>The block in this uniform buffer to access </td></tr>
    <tr><td class="paramname">offset</td><td>The offset within the block </td></tr>
    <tr><td class="paramname">vec</td><td>The vector to store the result</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if it can access the given uniform variable as a vector. </dd></dl>

</div>
</div>
<a id="aeb0e16167c2665445e21d8274b89263f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aeb0e16167c2665445e21d8274b89263f">&#9670;&nbsp;</a></span>init() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool cugl::UniformBuffer::init </td>
          <td>(</td>
          <td class="paramtype">GLsizei&#160;</td>
          <td class="paramname"><em>capacity</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Initializes this uniform buffer to support a block of the given capacity.</p>
<p>This uniform buffer will only support a single block. The block capacity is measured in bytes. In std140 format, all scalars are 4 bytes, vectors are 8 or 16 bytes, and matrices are treated as an array of 8 or 16 byte column vectors.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">capacity</td><td>The block capacity in bytes</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if initialization was successful. </dd></dl>

</div>
</div>
<a id="ae9870f6c9bc95ce0a6d1c6ae9f2d9377"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae9870f6c9bc95ce0a6d1c6ae9f2d9377">&#9670;&nbsp;</a></span>init() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool cugl::UniformBuffer::init </td>
          <td>(</td>
          <td class="paramtype">GLsizei&#160;</td>
          <td class="paramname"><em>capacity</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">GLuint&#160;</td>
          <td class="paramname"><em>blocks</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Initializes this uniform buffer to support multiple blocks of the given capacity.</p>
<p>The block capacity is measured in bytes. In std140 format, all scalars are 4 bytes, vectors are 8 or 16 bytes, and matrices are treated as an array of 8 or 16 byte column vectors.</p>
<p>Keep in mind that uniform buffer blocks must be aligned, and so this may take significantly more memory than the number of blocks times the capacity. If the graphics card cannot support that many blocks, this method will return false.</p>
<p>The drawtype is GL_STATIC_DRAW, GL_DYNAMIC_DRAW, or GL_STREAM_DRAW. If the uniform values change often, the difference between GL_STATIC_DRAW and GL_STREAM_DRAW is 1-2 orders of magnitude.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">capacity</td><td>The block capacity in bytes </td></tr>
    <tr><td class="paramname">blocks</td><td>The number of blocks to support</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if initialization was successful. </dd></dl>

</div>
</div>
<a id="ac39d2c44af1f53ede5b548a0c48dc793"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac39d2c44af1f53ede5b548a0c48dc793">&#9670;&nbsp;</a></span>isActive()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool cugl::UniformBuffer::isActive </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns true if this uniform buffer is currently active.</p>
<p>An active uniform block is the one that pushes changes in data directly to the graphics card. If the buffer is not active, then many of the setter methods in this class will cache changes but delay applying them until the buffer is reactivated.</p>
<p>Unlike <a class="el" href="classcugl_1_1_texture.html">Texture</a>, it is possible for a uniform buffer to be active but not bound.</p>
<dl class="section return"><dt>Returns</dt><dd>true if this uniform block is currently active. </dd></dl>

</div>
</div>
<a id="a98a1cb7695737fc5371c8b942f583fc8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a98a1cb7695737fc5371c8b942f583fc8">&#9670;&nbsp;</a></span>isBound()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool cugl::UniformBuffer::isBound </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns true if this uniform buffer is currently bound.</p>
<p>A uniform buffer is bound if it is attached to a bind point. That means that the shader will pull its data for that bind point from this buffer. A uniform block can be bound without being active.</p>
<dl class="section return"><dt>Returns</dt><dd>true if this uniform block is currently bound. </dd></dl>

</div>
</div>
<a id="a26e893f81d76465cfb3e46cc3ab62ee4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a26e893f81d76465cfb3e46cc3ab62ee4">&#9670;&nbsp;</a></span>isReady()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool cugl::UniformBuffer::isReady </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns true if this uniform buffer has been properly initialized.</p>
<dl class="section return"><dt>Returns</dt><dd>true if this uniform buffer has been properly initialized. </dd></dl>

</div>
</div>
<a id="a97e481e2420a9c5bc92fe6fe5a486d2b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a97e481e2420a9c5bc92fe6fe5a486d2b">&#9670;&nbsp;</a></span>setAutoflush()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void cugl::UniformBuffer::setAutoflush </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>style</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Sets whether this uniform buffer supports autoflushing.</p>
<p>Active, auto-flushed buffers write data directly to the graphics card as soon as it is provided to the buffer. A buffer than does not auto-flush will not write to the graphics card until <a class="el" href="classcugl_1_1_uniform_buffer.html#aa66e2e1025f650d84101d35991ebac10">flush</a> is called, even if it is active.</p>
<p>By default, autoflushing is turned off.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">style</td><td>Whether this uniform buffer supports autoflushing. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ab0ba21941d07fce5e6ee45c940ad982f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab0ba21941d07fce5e6ee45c940ad982f">&#9670;&nbsp;</a></span>setBindPoint()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void cugl::UniformBuffer::setBindPoint </td>
          <td>(</td>
          <td class="paramtype">GLuint&#160;</td>
          <td class="paramname"><em>point</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Sets the bind point for this uniform buffer.</p>
<p>Uniform buffers and shaders have a many-to-many relationship. This means that connecting them requires an intermediate table. The positions in this table are called bind points. A uniform buffer is associated with a bind point and a shader associates a bind point with a uniform struct. That uniform struct then pulls data from the active block of the uniform buffer. By default this value is 0.</p>
<p>The uniform buffer does not need to be active to call this method. This method only sets the bind point preference and does not actually <a class="el" href="classcugl_1_1_uniform_buffer.html#a16230fbbf58106e9e8881da2a86a82b5">bind</a> the buffer. However, if the buffer is bound to another bind point, then it will be unbound from that point.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">point</td><td>The bind point for for this uniform buffer. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="adee489553cacc3a1a31b16ac0c490ebb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adee489553cacc3a1a31b16ac0c490ebb">&#9670;&nbsp;</a></span>setBlock()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void cugl::UniformBuffer::setBlock </td>
          <td>(</td>
          <td class="paramtype">GLuint&#160;</td>
          <td class="paramname"><em>block</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Sets the active uniform block in this buffer.</p>
<p>The active uniform block is the block from which the shader will pull uniform values. This value can only be altered if this buffer is bound (though it need not be active).</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">block</td><td>The active uniform block in this buffer. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a1d2185f2b4665ef52dc81bf493c3f30c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1d2185f2b4665ef52dc81bf493c3f30c">&#9670;&nbsp;</a></span>setDrawType()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void cugl::UniformBuffer::setDrawType </td>
          <td>(</td>
          <td class="paramtype">GLenum&#160;</td>
          <td class="paramname"><em>type</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Sets the draw type for this buffer</p>
<p>The drawtype is GL_STATIC_DRAW, GL_DYNAMIC_DRAW, or GL_STREAM_DRAW. If the uniform values change often, the difference between GL_STATIC_DRAW and GL_STREAM_DRAW is 1-2 orders of magnitude.</p>
<p>By default, the draw type is GL_STREAM_DRAW.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">type</td><td>The draw type for this buffer </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aeeae70345a7add5292e5de7b4ee35c90"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aeeae70345a7add5292e5de7b4ee35c90">&#9670;&nbsp;</a></span>setName()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void cugl::UniformBuffer::setName </td>
          <td>(</td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>name</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Sets the name of this uniform buffer.</p>
<p>A name is a user-defined way of identifying a buffer. It is typically the appropriate shader variable name, but this is not necessary for it to function properly.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">name</td><td>The name of this uniform block. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aed42e022b292a290dc9447e02c9240a2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aed42e022b292a290dc9447e02c9240a2">&#9670;&nbsp;</a></span>setOffset()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void cugl::UniformBuffer::setOffset </td>
          <td>(</td>
          <td class="paramtype">const std::string&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">GLsizei&#160;</td>
          <td class="paramname"><em>offset</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Defines the byte offset of the given buffer variable.</p>
<p>It is not necessary to call this method to use the uniform buffer. It is always possible to pass data to the uniform block by specifying the byte offset. The shader uses byte offsets to pull data from the uniform buffer and assign it to the appropriate struct variable.</p>
<p>However, this method makes use of the uniform buffer easier to follow. It explicitly assigns a variable name to a byte offset. This variable name can now be used in place of the byte offset with passing data to this uniform block.</p>
<p>Use of this method does not require the uniform buffer to be bound or even active.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">name</td><td>The variable name to use for this offset </td></tr>
    <tr><td class="paramname">offset</td><td>The buffer offset in bytes </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aa741c324cd94642054b6905fb86ced49"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa741c324cd94642054b6905fb86ced49">&#9670;&nbsp;</a></span>setUniformAffine2() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void cugl::UniformBuffer::setUniformAffine2 </td>
          <td>(</td>
          <td class="paramtype">GLint&#160;</td>
          <td class="paramname"><em>block</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classcugl_1_1_affine2.html">Affine2</a> &amp;&#160;</td>
          <td class="paramname"><em>mat</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Sets the given uniform variable to an affine transform.</p>
<p>Affine transforms are passed to a uniform block as a 4x3 matrix on homogenous coordinates. That is because the columns must be 4*sizeof(float) bytes for alignment reasons. The buffer must have 12*sizeof(float) bytes available for this write.</p>
<p>This method requires that the uniform name be previously bound to a byte offset with the call <a class="el" href="classcugl_1_1_uniform_buffer.html#aed42e022b292a290dc9447e02c9240a2">setOffset</a>. Values set by this method will not be sent to the graphics card until the buffer is flushed. However, if the buffer is active and auto-flush is turned on, it will be written immediately.</p>
<p>If block is -1, it sets this value in every block in this uniform buffer. This is a potentially expensive operation if the block is active. For mass changes, it is better to deactivate the buffer, and have them apply once the buffer is reactivated.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">block</td><td>The block in this uniform buffer to access </td></tr>
    <tr><td class="paramname">name</td><td>The name of the uniform variable </td></tr>
    <tr><td class="paramname">mat</td><td>The value for the uniform </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a275b40a13e2042de0956329a57fdd119"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a275b40a13e2042de0956329a57fdd119">&#9670;&nbsp;</a></span>setUniformAffine2() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void cugl::UniformBuffer::setUniformAffine2 </td>
          <td>(</td>
          <td class="paramtype">GLint&#160;</td>
          <td class="paramname"><em>block</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">GLsizei&#160;</td>
          <td class="paramname"><em>offset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classcugl_1_1_affine2.html">Affine2</a> &amp;&#160;</td>
          <td class="paramname"><em>mat</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Sets the given uniform variable to an affine transform.</p>
<p>Affine transforms are passed to a uniform block as a 4x3 matrix on homogenous coordinates. That is because the columns must be 4*sizeof(float) bytes for alignment reasons. The buffer must have 12*sizeof(float) bytes available for this write.</p>
<p>Values set by this method will not be sent to the graphics card until the buffer is flushed. However, if the buffer is active and auto-flush is turned on, it will be written immediately.</p>
<p>If block is -1, it sets this value in every block in this uniform buffer. This is a potentially expensive operation if the block is active. For mass changes, it is better to deactivate the buffer, and have them apply once the buffer is reactivated.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">block</td><td>The block in this uniform buffer to access </td></tr>
    <tr><td class="paramname">offset</td><td>The offset within the block </td></tr>
    <tr><td class="paramname">mat</td><td>The value for the uniform </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a26c7449c0a0f5cbf9ccaa588c3a5dae8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a26c7449c0a0f5cbf9ccaa588c3a5dae8">&#9670;&nbsp;</a></span>setUniformColor4() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void cugl::UniformBuffer::setUniformColor4 </td>
          <td>(</td>
          <td class="paramtype">GLint&#160;</td>
          <td class="paramname"><em>block</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classcugl_1_1_color4.html">Color4</a>&#160;</td>
          <td class="paramname"><em>color</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Sets the given uniform variable to a color value.</p>
<p>This method requires that the uniform name be previously bound to a byte offset with the call <a class="el" href="classcugl_1_1_uniform_buffer.html#aed42e022b292a290dc9447e02c9240a2">setOffset</a>. This method will write the color as 4*sizeof(float) bytes to the appropriate buffer location (and the buffer must have the appropriate capacity).</p>
<p>Values set by this method will not be sent to the graphics card until the buffer is flushed. However, if the buffer is active and auto-flush is turned on, it will be written immediately.</p>
<p>If block is -1, it sets this value in every block in this uniform buffer. This is a potentially expensive operation if the block is active. For mass changes, it is better to deactivate the buffer, and have them apply once the buffer is reactivated.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">block</td><td>The block in this uniform buffer to access </td></tr>
    <tr><td class="paramname">name</td><td>The name of the uniform variable </td></tr>
    <tr><td class="paramname">color</td><td>The value for the uniform </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a50b886de241b785c610ddeb11520e28e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a50b886de241b785c610ddeb11520e28e">&#9670;&nbsp;</a></span>setUniformColor4() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void cugl::UniformBuffer::setUniformColor4 </td>
          <td>(</td>
          <td class="paramtype">GLint&#160;</td>
          <td class="paramname"><em>block</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">GLsizei&#160;</td>
          <td class="paramname"><em>offset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classcugl_1_1_color4.html">Color4</a>&#160;</td>
          <td class="paramname"><em>color</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Sets the given uniform variable to a color value.</p>
<p>This method will write the color as 4*sizeof(float) bytes to the appropriate buffer location (and the buffer must have the appropriate capacity).</p>
<p>Values set by this method will not be sent to the graphics card until the buffer is flushed. However, if the buffer is active and auto-flush is turned on, it will be written immediately.</p>
<p>If block is -1, it sets this value in every block in this uniform buffer. This is a potentially expensive operation if the block is active. For mass changes, it is better to deactivate the buffer, and have them apply once the buffer is reactivated.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">block</td><td>The block in this uniform buffer to access </td></tr>
    <tr><td class="paramname">offset</td><td>The offset within the block </td></tr>
    <tr><td class="paramname">color</td><td>The value for the uniform </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a684327147f266dac95a43423bc1e9f52"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a684327147f266dac95a43423bc1e9f52">&#9670;&nbsp;</a></span>setUniformColor4f() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void cugl::UniformBuffer::setUniformColor4f </td>
          <td>(</td>
          <td class="paramtype">GLint&#160;</td>
          <td class="paramname"><em>block</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classcugl_1_1_color4f.html">Color4f</a>&#160;</td>
          <td class="paramname"><em>color</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Sets the given uniform variable to a color value.</p>
<p>This method requires that the uniform name be previously bound to a byte offset with the call <a class="el" href="classcugl_1_1_uniform_buffer.html#aed42e022b292a290dc9447e02c9240a2">setOffset</a>. This method will write the color as 4*sizeof(float) bytes to the appropriate buffer location (and the buffer must have the appropriate capacity).</p>
<p>Values set by this method will not be sent to the graphics card until the buffer is flushed. However, if the buffer is active and auto-flush is turned on, it will be written immediately.</p>
<p>If block is -1, it sets this value in every block in this uniform buffer. This is a potentially expensive operation if the block is active. For mass changes, it is better to deactivate the buffer, and have them apply once the buffer is reactivated.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">block</td><td>The block in this uniform buffer to access </td></tr>
    <tr><td class="paramname">name</td><td>The name of the uniform variable </td></tr>
    <tr><td class="paramname">color</td><td>The value for the uniform </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a186f638a39b302cc03060759148f67b2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a186f638a39b302cc03060759148f67b2">&#9670;&nbsp;</a></span>setUniformColor4f() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void cugl::UniformBuffer::setUniformColor4f </td>
          <td>(</td>
          <td class="paramtype">GLint&#160;</td>
          <td class="paramname"><em>block</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">GLsizei&#160;</td>
          <td class="paramname"><em>offset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classcugl_1_1_color4f.html">Color4f</a>&#160;</td>
          <td class="paramname"><em>color</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Sets the given uniform variable to a color value.</p>
<p>This method will write the color as 4*sizeof(float) bytes to the appropriate buffer location (and the buffer must have the appropriate capacity).</p>
<p>Values set by this method will not be sent to the graphics card until the buffer is flushed. However, if the buffer is active and auto-flush is turned on, it will be written immediately.</p>
<p>If block is -1, it sets this value in every block in this uniform buffer. This is a potentially expensive operation if the block is active. For mass changes, it is better to deactivate the buffer, and have them apply once the buffer is reactivated.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">block</td><td>The block in this uniform buffer to access </td></tr>
    <tr><td class="paramname">offset</td><td>The offset within the block </td></tr>
    <tr><td class="paramname">color</td><td>The value for the uniform </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a7731edaf46e80729336400493b19544b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7731edaf46e80729336400493b19544b">&#9670;&nbsp;</a></span>setUniformfv() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void cugl::UniformBuffer::setUniformfv </td>
          <td>(</td>
          <td class="paramtype">GLint&#160;</td>
          <td class="paramname"><em>block</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">GLsizei&#160;</td>
          <td class="paramname"><em>size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const GLfloat *&#160;</td>
          <td class="paramname"><em>values</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Sets the given buffer location to an array of float values</p>
<p>This method requires that the uniform name be previously bound to a byte offset with the call <a class="el" href="classcugl_1_1_uniform_buffer.html#aed42e022b292a290dc9447e02c9240a2">setOffset</a>. Values set by this method will not be sent to the graphics card until the buffer is flushed. However, if the buffer is active and auto-flush is turned on, it will be written immediately.</p>
<p>If block is -1, it sets this value in every block in this uniform buffer. This is a potentially expensive operation if the block is active. For mass changes, it is better to deactivate the buffer, and have them apply once the buffer is reactivated.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">block</td><td>The block in this uniform buffer to access </td></tr>
    <tr><td class="paramname">name</td><td>The name of the uniform variable </td></tr>
    <tr><td class="paramname">size</td><td>The number of values to write to the buffer </td></tr>
    <tr><td class="paramname">values</td><td>The values to write </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a3f181fb47f4f06eb501249bea90b9078"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3f181fb47f4f06eb501249bea90b9078">&#9670;&nbsp;</a></span>setUniformfv() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void cugl::UniformBuffer::setUniformfv </td>
          <td>(</td>
          <td class="paramtype">GLint&#160;</td>
          <td class="paramname"><em>block</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">GLsizei&#160;</td>
          <td class="paramname"><em>offset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">GLsizei&#160;</td>
          <td class="paramname"><em>size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const GLfloat *&#160;</td>
          <td class="paramname"><em>values</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Sets the given buffer offset to an array of float values</p>
<p>Values set by this method will not be sent to the graphics card until the buffer is flushed. However, if the buffer is active and auto-flush is turned on, it will be written immediately.</p>
<p>If block is -1, it sets this value in every block in this uniform buffer. This is a potentially expensive operation if the block is active. For mass changes, it is better to deactivate the buffer, and have them apply once the buffer is reactivated.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">block</td><td>The block in this uniform buffer to access </td></tr>
    <tr><td class="paramname">offset</td><td>The offset within the block </td></tr>
    <tr><td class="paramname">size</td><td>The number of values to write to the buffer </td></tr>
    <tr><td class="paramname">values</td><td>The values to write </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a7a5c1971b0f197936989e1387ecc2a2e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7a5c1971b0f197936989e1387ecc2a2e">&#9670;&nbsp;</a></span>setUniformiv() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void cugl::UniformBuffer::setUniformiv </td>
          <td>(</td>
          <td class="paramtype">GLint&#160;</td>
          <td class="paramname"><em>block</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">GLsizei&#160;</td>
          <td class="paramname"><em>size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const GLint *&#160;</td>
          <td class="paramname"><em>values</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Sets the given buffer location to an array of integer values</p>
<p>This method requires that the uniform name be previously bound to a byte offset with the call <a class="el" href="classcugl_1_1_uniform_buffer.html#aed42e022b292a290dc9447e02c9240a2">setOffset</a>. Values set by this method will not be sent to the graphics card until the buffer is flushed. However, if the buffer is active and auto-flush is turned on, it will be written immediately.</p>
<p>If block is -1, it sets this value in every block in this uniform buffer. This is a potentially expensive operation if the block is active. For mass changes, it is better to deactivate the buffer, and have them apply once the buffer is reactivated.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">block</td><td>The block in this uniform buffer to access </td></tr>
    <tr><td class="paramname">name</td><td>The name of the uniform variable </td></tr>
    <tr><td class="paramname">size</td><td>The number of values to write to the buffer </td></tr>
    <tr><td class="paramname">values</td><td>The values to write </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a60e6b165aca7efd45c0a70d9208f23ef"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a60e6b165aca7efd45c0a70d9208f23ef">&#9670;&nbsp;</a></span>setUniformiv() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void cugl::UniformBuffer::setUniformiv </td>
          <td>(</td>
          <td class="paramtype">GLint&#160;</td>
          <td class="paramname"><em>block</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">GLsizei&#160;</td>
          <td class="paramname"><em>offset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">GLsizei&#160;</td>
          <td class="paramname"><em>size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const GLint *&#160;</td>
          <td class="paramname"><em>values</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Sets the given buffer offset to an array of integer values</p>
<p>Values set by this method will not be sent to the graphics card until the buffer is flushed. However, if the buffer is active and auto-flush is turned on, it will be written immediately.</p>
<p>If block is -1, it sets this value in every block in this uniform buffer. This is a potentially expensive operation if the block is active. For mass changes, it is better to deactivate the buffer, and have them apply once the buffer is reactivated.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">block</td><td>The block in this uniform buffer to access </td></tr>
    <tr><td class="paramname">offset</td><td>The offset within the block </td></tr>
    <tr><td class="paramname">size</td><td>The number of values to write to the buffer </td></tr>
    <tr><td class="paramname">values</td><td>The values to write </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="add1822ef27f4addcc56069f7c5e7b010"></a>
<h2 class="memtitle"><span class="permalink"><a href="#add1822ef27f4addcc56069f7c5e7b010">&#9670;&nbsp;</a></span>setUniformMat4() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void cugl::UniformBuffer::setUniformMat4 </td>
          <td>(</td>
          <td class="paramtype">GLint&#160;</td>
          <td class="paramname"><em>block</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classcugl_1_1_mat4.html">Mat4</a> &amp;&#160;</td>
          <td class="paramname"><em>mat</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Sets the given uniform variable to a matrix value.</p>
<p>This method requires that the uniform name be previously bound to a byte offset with the call <a class="el" href="classcugl_1_1_uniform_buffer.html#aed42e022b292a290dc9447e02c9240a2">setOffset</a>. This method will write the matrix as 16*sizeof(float) bytes to the appropriate buffer location (and the buffer must have the appropriate capacity).</p>
<p>Values set by this method will not be sent to the graphics card until the buffer is flushed. However, if the buffer is active and auto-flush is turned on, it will be written immediately.</p>
<p>If block is -1, it sets this value in every block in this uniform buffer. This is a potentially expensive operation if the block is active. For mass changes, it is better to deactivate the buffer, and have them apply once the buffer is reactivated.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">block</td><td>The block in this uniform buffer to access </td></tr>
    <tr><td class="paramname">name</td><td>The name of the uniform variable </td></tr>
    <tr><td class="paramname">mat</td><td>The value for the uniform </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a0eda643b5f389bc666389140140c55e0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0eda643b5f389bc666389140140c55e0">&#9670;&nbsp;</a></span>setUniformMat4() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void cugl::UniformBuffer::setUniformMat4 </td>
          <td>(</td>
          <td class="paramtype">GLint&#160;</td>
          <td class="paramname"><em>block</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">GLsizei&#160;</td>
          <td class="paramname"><em>offset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classcugl_1_1_mat4.html">Mat4</a> &amp;&#160;</td>
          <td class="paramname"><em>mat</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Sets the given uniform variable to a matrix value.</p>
<p>This method will write the matrix as 16*sizeof(float) bytes to the appropriate buffer location (and the buffer must have the appropriate capacity).</p>
<p>Values set by this method will not be sent to the graphics card until the buffer is flushed. However, if the buffer is active and auto-flush is turned on, it will be written immediately.</p>
<p>If block is -1, it sets this value in every block in this uniform buffer. This is a potentially expensive operation if the block is active. For mass changes, it is better to deactivate the buffer, and have them apply once the buffer is reactivated.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">block</td><td>The block in this uniform buffer to access </td></tr>
    <tr><td class="paramname">offset</td><td>The offset within the block </td></tr>
    <tr><td class="paramname">mat</td><td>The value for the uniform </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ac2f3e0a8823f74c9e1f41608a96f876a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac2f3e0a8823f74c9e1f41608a96f876a">&#9670;&nbsp;</a></span>setUniformQuaternion() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void cugl::UniformBuffer::setUniformQuaternion </td>
          <td>(</td>
          <td class="paramtype">GLint&#160;</td>
          <td class="paramname"><em>block</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classcugl_1_1_quaternion.html">Quaternion</a> &amp;&#160;</td>
          <td class="paramname"><em>quat</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Sets the given uniform variable to a quaternion</p>
<p>This method requires that the uniform name be previously bound to a byte offset with the call <a class="el" href="classcugl_1_1_uniform_buffer.html#aed42e022b292a290dc9447e02c9240a2">setOffset</a>. This method will write the quaternion as 4*sizeof(float) bytes to the appropriate buffer location (and the buffer must have the appropriate capacity).</p>
<p>Values set by this method will not be sent to the graphics card until the buffer is flushed. However, if the buffer is active and auto-flush is turned on, it will be written immediately.</p>
<p>If block is -1, it sets this value in every block in this uniform buffer. This is a potentially expensive operation if the block is active. For mass changes, it is better to deactivate the buffer, and have them apply once the buffer is reactivated.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">block</td><td>The block in this uniform buffer to access </td></tr>
    <tr><td class="paramname">name</td><td>The name of the uniform variable </td></tr>
    <tr><td class="paramname">quat</td><td>The value for the uniform </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a7e882ce4fd1467844cc7883a72829ee1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7e882ce4fd1467844cc7883a72829ee1">&#9670;&nbsp;</a></span>setUniformQuaternion() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void cugl::UniformBuffer::setUniformQuaternion </td>
          <td>(</td>
          <td class="paramtype">GLint&#160;</td>
          <td class="paramname"><em>block</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">GLsizei&#160;</td>
          <td class="paramname"><em>offset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classcugl_1_1_quaternion.html">Quaternion</a> &amp;&#160;</td>
          <td class="paramname"><em>quat</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Sets the given uniform variable to a quaternion.</p>
<p>This method will write the quaternion as 4*sizeof(float) bytes to the appropriate buffer location (and the buffer must have the appropriate capacity).</p>
<p>Values set by this method will not be sent to the graphics card until the buffer is flushed. However, if the buffer is active and auto-flush is turned on, it will be written immediately.</p>
<p>If block is -1, it sets this value in every block in this uniform buffer. This is a potentially expensive operation if the block is active. For mass changes, it is better to deactivate the buffer, and have them apply once the buffer is reactivated.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">block</td><td>The block in this uniform buffer to access </td></tr>
    <tr><td class="paramname">offset</td><td>The offset within the block </td></tr>
    <tr><td class="paramname">quat</td><td>The value for the uniform </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a82d59ef3e01db2eb76a74a157ef00a6c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a82d59ef3e01db2eb76a74a157ef00a6c">&#9670;&nbsp;</a></span>setUniformuiv() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void cugl::UniformBuffer::setUniformuiv </td>
          <td>(</td>
          <td class="paramtype">GLint&#160;</td>
          <td class="paramname"><em>block</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">GLsizei&#160;</td>
          <td class="paramname"><em>size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const GLuint *&#160;</td>
          <td class="paramname"><em>values</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Sets the given buffer location to an array of unsigned integer values</p>
<p>This method requires that the uniform name be previously bound to a byte offset with the call <a class="el" href="classcugl_1_1_uniform_buffer.html#aed42e022b292a290dc9447e02c9240a2">setOffset</a>. Values set by this method will not be sent to the graphics card until the buffer is flushed. However, if the buffer is active and auto-flush is turned on, it will be written immediately.</p>
<p>If block is -1, it sets this value in every block in this uniform buffer. This is a potentially expensive operation if the block is active. For mass changes, it is better to deactivate the buffer, and have them apply once the buffer is reactivated.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">block</td><td>The block in this uniform buffer to access </td></tr>
    <tr><td class="paramname">name</td><td>The name of the uniform variable </td></tr>
    <tr><td class="paramname">size</td><td>The number of values to write to the buffer </td></tr>
    <tr><td class="paramname">values</td><td>The values to write </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aa34011d0cfd0987b621119e472819c0d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa34011d0cfd0987b621119e472819c0d">&#9670;&nbsp;</a></span>setUniformuiv() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void cugl::UniformBuffer::setUniformuiv </td>
          <td>(</td>
          <td class="paramtype">GLint&#160;</td>
          <td class="paramname"><em>block</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">GLsizei&#160;</td>
          <td class="paramname"><em>offset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">GLsizei&#160;</td>
          <td class="paramname"><em>size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const GLuint *&#160;</td>
          <td class="paramname"><em>values</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Sets the given buffer offset to an array of unsigned integer values</p>
<p>Values set by this method will not be sent to the graphics card until the buffer is flushed. However, if the buffer is active and auto-flush is turned on, it will be written immediately.</p>
<p>If block is -1, it sets this value in every block in this uniform buffer. This is a potentially expensive operation if the block is active. For mass changes, it is better to deactivate the buffer, and have them apply once the buffer is reactivated.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">block</td><td>The block in this uniform buffer to access </td></tr>
    <tr><td class="paramname">offset</td><td>The offset within the block </td></tr>
    <tr><td class="paramname">size</td><td>The number of values to write to the buffer </td></tr>
    <tr><td class="paramname">values</td><td>The values to write </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a1b8283b3c0e5d9a991e05daf14967aeb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1b8283b3c0e5d9a991e05daf14967aeb">&#9670;&nbsp;</a></span>setUniformVec2() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void cugl::UniformBuffer::setUniformVec2 </td>
          <td>(</td>
          <td class="paramtype">GLint&#160;</td>
          <td class="paramname"><em>block</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classcugl_1_1_vec2.html">Vec2</a>&#160;</td>
          <td class="paramname"><em>vec</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Sets the given uniform variable to a vector value.</p>
<p>This method requires that the uniform name be previously bound to a byte offset with the call <a class="el" href="classcugl_1_1_uniform_buffer.html#aed42e022b292a290dc9447e02c9240a2">setOffset</a>. This method will write the vector as 2*sizeof(float) bytes to the appropriate buffer location (and the buffer must have the appropriate capacity).</p>
<p>Values set by this method will not be sent to the graphics card until the buffer is flushed. However, if the buffer is active and auto-flush is turned on, it will be written immediately.</p>
<p>If block is -1, it sets this value in every block in this uniform buffer. This is a potentially expensive operation if the block is active. For mass changes, it is better to deactivate the buffer, and have them apply once the buffer is reactivated.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">block</td><td>The block in this uniform buffer to access </td></tr>
    <tr><td class="paramname">name</td><td>The name of the uniform variable </td></tr>
    <tr><td class="paramname">vec</td><td>The value for the uniform </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aab597256d45930bb612ab00e5296badc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aab597256d45930bb612ab00e5296badc">&#9670;&nbsp;</a></span>setUniformVec2() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void cugl::UniformBuffer::setUniformVec2 </td>
          <td>(</td>
          <td class="paramtype">GLint&#160;</td>
          <td class="paramname"><em>block</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">GLsizei&#160;</td>
          <td class="paramname"><em>offset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classcugl_1_1_vec2.html">Vec2</a>&#160;</td>
          <td class="paramname"><em>vec</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Sets the given uniform variable to a vector value.</p>
<p>This method will write the vector as 2*sizeof(float) bytes to the appropriate buffer location (and the buffer must have the appropriate capacity).</p>
<p>Values set by this method will not be sent to the graphics card until the buffer is flushed. However, if the buffer is active and auto-flush is turned on, it will be written immediately.</p>
<p>If block is -1, it sets this value in every block in this uniform buffer. This is a potentially expensive operation if the block is active. For mass changes, it is better to deactivate the buffer, and have them apply once the buffer is reactivated.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">block</td><td>The block in this uniform buffer to access </td></tr>
    <tr><td class="paramname">offset</td><td>The offset within the block </td></tr>
    <tr><td class="paramname">vec</td><td>The value for the uniform </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a7fc283070b91fa356c6981524badc21f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7fc283070b91fa356c6981524badc21f">&#9670;&nbsp;</a></span>setUniformVec3() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void cugl::UniformBuffer::setUniformVec3 </td>
          <td>(</td>
          <td class="paramtype">GLint&#160;</td>
          <td class="paramname"><em>block</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classcugl_1_1_vec3.html">Vec3</a>&#160;</td>
          <td class="paramname"><em>vec</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Sets the given uniform variable to a vector value.</p>
<p>This method requires that the uniform name be previously bound to a byte offset with the call <a class="el" href="classcugl_1_1_uniform_buffer.html#aed42e022b292a290dc9447e02c9240a2">setOffset</a>. This method will write the vector as 3*sizeof(float) bytes to the appropriate buffer location (and the buffer must have the appropriate capacity).</p>
<p>The buffer does not need to be active to call this method. However, changes made while the buffer is inactive will be cached and not applied until the buffer is reactivated.</p>
<p>If block is -1, it sets this value in every block in this uniform buffer. This is a potentially expensive operation if the block is active. For mass changes, it is better to deactivate the buffer, and have them apply once the buffer is reactivated.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">block</td><td>The block in this uniform buffer to access </td></tr>
    <tr><td class="paramname">name</td><td>The name of the uniform variable </td></tr>
    <tr><td class="paramname">vec</td><td>The value for the uniform </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a94f549d8afd5afaf5ac9696b0f435d7b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a94f549d8afd5afaf5ac9696b0f435d7b">&#9670;&nbsp;</a></span>setUniformVec3() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void cugl::UniformBuffer::setUniformVec3 </td>
          <td>(</td>
          <td class="paramtype">GLint&#160;</td>
          <td class="paramname"><em>block</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">GLsizei&#160;</td>
          <td class="paramname"><em>offset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classcugl_1_1_vec3.html">Vec3</a>&#160;</td>
          <td class="paramname"><em>vec</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Sets the given uniform variable to a vector value.</p>
<p>This method will write the vector as 3*sizeof(float) bytes to the appropriate buffer location (and the buffer must have the appropriate capacity).</p>
<p>Values set by this method will not be sent to the graphics card until the buffer is flushed. However, if the buffer is active and auto-flush is turned on, it will be written immediately.</p>
<p>If block is -1, it sets this value in every block in this uniform buffer. This is a potentially expensive operation if the block is active. For mass changes, it is better to deactivate the buffer, and have them apply once the buffer is reactivated.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">block</td><td>The block in this uniform buffer to access </td></tr>
    <tr><td class="paramname">offset</td><td>The offset within the block </td></tr>
    <tr><td class="paramname">vec</td><td>The value for the uniform </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ab2b88e5bdb47bba55e4818fe4932c4aa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab2b88e5bdb47bba55e4818fe4932c4aa">&#9670;&nbsp;</a></span>setUniformVec4() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void cugl::UniformBuffer::setUniformVec4 </td>
          <td>(</td>
          <td class="paramtype">GLint&#160;</td>
          <td class="paramname"><em>block</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classcugl_1_1_vec4.html">Vec4</a>&#160;</td>
          <td class="paramname"><em>vec</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Sets the given uniform variable to a vector value.</p>
<p>This method requires that the uniform name be previously bound to a byte offset with the call <a class="el" href="classcugl_1_1_uniform_buffer.html#aed42e022b292a290dc9447e02c9240a2">setOffset</a>. This method will write the vector as 4*sizeof(float) bytes to the appropriate buffer location (and the buffer must have the appropriate capacity).</p>
<p>Values set by this method will not be sent to the graphics card until the buffer is flushed. However, if the buffer is active and auto-flush is turned on, it will be written immediately.</p>
<p>If block is -1, it sets this value in every block in this uniform buffer. This is a potentially expensive operation if the block is active. For mass changes, it is better to deactivate the buffer, and have them apply once the buffer is reactivated.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">block</td><td>The block in this uniform buffer to access </td></tr>
    <tr><td class="paramname">name</td><td>The name of the uniform variable </td></tr>
    <tr><td class="paramname">vec</td><td>The value for the uniform </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a7734c167c62d1379bc9703e8dce1bc43"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7734c167c62d1379bc9703e8dce1bc43">&#9670;&nbsp;</a></span>setUniformVec4() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void cugl::UniformBuffer::setUniformVec4 </td>
          <td>(</td>
          <td class="paramtype">GLint&#160;</td>
          <td class="paramname"><em>block</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">GLsizei&#160;</td>
          <td class="paramname"><em>offset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classcugl_1_1_vec4.html">Vec4</a>&#160;</td>
          <td class="paramname"><em>vec</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Sets the given uniform variable to a vector value.</p>
<p>This method will write the vector as 4*sizeof(float) bytes to the appropriate buffer location (and the buffer must have the appropriate capacity).</p>
<p>Values set by this method will not be sent to the graphics card until the buffer is flushed. However, if the buffer is active and auto-flush is turned on, it will be written immediately.</p>
<p>If block is -1, it sets this value in every block in this uniform buffer. This is a potentially expensive operation if the block is active. For mass changes, it is better to deactivate the buffer, and have them apply once the buffer is reactivated.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">block</td><td>The block in this uniform buffer to access </td></tr>
    <tr><td class="paramname">offset</td><td>The offset within the block </td></tr>
    <tr><td class="paramname">vec</td><td>The value for the uniform </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="af4dd4de6563477582eae6a04c666f96e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af4dd4de6563477582eae6a04c666f96e">&#9670;&nbsp;</a></span>unbind()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void cugl::UniformBuffer::unbind </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Unbinds this uniform buffer disassociating it from its bind point.</p>
<p>This call will have no affect on the active buffer (e.g. which buffer is receiving data from the program). This method simply removes this buffer from its bind point.</p>
<p>Once unbound, the bind point for this buffer will no longer send data to the appropriate uniform(s) in the shader. In that case the shader will use default values according to the variable types.</p>
<p>This call is reentrant. If can be safely called multiple times. </p>

</div>
</div>
<h2 class="groupheader">Member Data Documentation</h2>
<a id="a59861c4ebccea912dd9b32cc101787f8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a59861c4ebccea912dd9b32cc101787f8">&#9670;&nbsp;</a></span>INVALID_OFFSET</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">GLsizei cugl::UniformBuffer::INVALID_OFFSET</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>The byte position of an invalid offset </p>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>include/cugl/render/<a class="el" href="_c_u_uniform_buffer_8h_source.html">CUUniformBuffer.h</a></li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.1
</small></address>
</body>
</html>
