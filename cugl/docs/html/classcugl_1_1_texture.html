<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.9.1"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>CUGL 2.0: cugl::Texture Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">CUGL 2.0
   </div>
   <div id="projectbrief">Cornell University Game Library</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.1 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search','.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespacecugl.html">cugl</a></li><li class="navelem"><a class="el" href="classcugl_1_1_texture.html">Texture</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-static-methods">Static Public Member Functions</a> &#124;
<a href="classcugl_1_1_texture-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">cugl::Texture Class Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p><code>#include &lt;<a class="el" href="_c_u_texture_8h_source.html">CUTexture.h</a>&gt;</code></p>
<div class="dynheader">
Inheritance diagram for cugl::Texture:</div>
<div class="dyncontent">
 <div class="center">
  <img src="classcugl_1_1_texture.png" alt=""/>
 </div></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:ac9762e396811469c04413c1c604ea3cd"><td class="memItemLeft" align="right" valign="top">enum class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1_texture.html#ac9762e396811469c04413c1c604ea3cd">PixelFormat</a> : GLenum { <br />
&#160;&#160;<a class="el" href="classcugl_1_1_texture.html#ac9762e396811469c04413c1c604ea3cdaea3495a278957dc58165e48a8945469f">RGBA</a> = GL_RGBA
, <a class="el" href="classcugl_1_1_texture.html#ac9762e396811469c04413c1c604ea3cda889574aebacda6bfd3e534e2b49b8028">RGB</a> = GL_RGB
, <a class="el" href="classcugl_1_1_texture.html#ac9762e396811469c04413c1c604ea3cdaa2d9547b5d3dd9f05984475f7c926da0">RED</a> = GL_RED
, <a class="el" href="classcugl_1_1_texture.html#ac9762e396811469c04413c1c604ea3cdabc512462a2c883b0a43583f607c19b5a">RED_GREEN</a> = GL_RG
, <br />
&#160;&#160;<a class="el" href="classcugl_1_1_texture.html#ac9762e396811469c04413c1c604ea3cdaaa1780b4fcce2d5d9af13dc25386d111">DEPTH</a> = GL_DEPTH_COMPONENT
, <a class="el" href="classcugl_1_1_texture.html#ac9762e396811469c04413c1c604ea3cdaecaa8fe8cb0e85372f4cc76728c7cf3c">DEPTH_STENCIL</a> = GL_DEPTH_STENCIL
<br />
 }</td></tr>
<tr class="separator:ac9762e396811469c04413c1c604ea3cd"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:ae00706fa56b20962bd5d3661a80034e9"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1_texture.html#ae00706fa56b20962bd5d3661a80034e9">Texture</a> ()</td></tr>
<tr class="separator:ae00706fa56b20962bd5d3661a80034e9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4254550850246c44351ca5cf954cb22f"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1_texture.html#a4254550850246c44351ca5cf954cb22f">~Texture</a> ()</td></tr>
<tr class="separator:a4254550850246c44351ca5cf954cb22f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7f4311b1ca1483a5ab98fe4b10e5fa83"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1_texture.html#a7f4311b1ca1483a5ab98fe4b10e5fa83">dispose</a> ()</td></tr>
<tr class="separator:a7f4311b1ca1483a5ab98fe4b10e5fa83"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3fef5518341f65eae6a97dbfbabe6fb9"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1_texture.html#a3fef5518341f65eae6a97dbfbabe6fb9">init</a> (int width, int height, <a class="el" href="classcugl_1_1_texture.html#ac9762e396811469c04413c1c604ea3cd">PixelFormat</a> format=<a class="el" href="classcugl_1_1_texture.html#ac9762e396811469c04413c1c604ea3cdaea3495a278957dc58165e48a8945469f">PixelFormat::RGBA</a>)</td></tr>
<tr class="separator:a3fef5518341f65eae6a97dbfbabe6fb9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a13f8b761fed4ab717c0c86a35d8f16ca"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1_texture.html#a13f8b761fed4ab717c0c86a35d8f16ca">initWithData</a> (const void *data, int width, int height, <a class="el" href="classcugl_1_1_texture.html#ac9762e396811469c04413c1c604ea3cd">PixelFormat</a> format=<a class="el" href="classcugl_1_1_texture.html#ac9762e396811469c04413c1c604ea3cdaea3495a278957dc58165e48a8945469f">PixelFormat::RGBA</a>)</td></tr>
<tr class="separator:a13f8b761fed4ab717c0c86a35d8f16ca"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8dc1a183163ec4106c702e5c6200a459"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1_texture.html#a8dc1a183163ec4106c702e5c6200a459">initWithFile</a> (const std::string filename)</td></tr>
<tr class="separator:a8dc1a183163ec4106c702e5c6200a459"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4a527174ba98ef3265afac2d1d121838"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classcugl_1_1_texture.html">Texture</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1_texture.html#a4a527174ba98ef3265afac2d1d121838">operator=</a> (const void *data)</td></tr>
<tr class="separator:a4a527174ba98ef3265afac2d1d121838"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4c42edb3d985f33e1253c08128b41908"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classcugl_1_1_texture.html">Texture</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1_texture.html#a4c42edb3d985f33e1253c08128b41908">set</a> (const void *data)</td></tr>
<tr class="separator:a4c42edb3d985f33e1253c08128b41908"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0e83b26b63dfb4d7584eec7965d34735"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1_texture.html#a0e83b26b63dfb4d7584eec7965d34735">setName</a> (std::string name)</td></tr>
<tr class="separator:a0e83b26b63dfb4d7584eec7965d34735"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6aee3ae4a7ce090a944eee46dedddcf5"><td class="memItemLeft" align="right" valign="top">const std::string &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1_texture.html#a6aee3ae4a7ce090a944eee46dedddcf5">getName</a> () const</td></tr>
<tr class="separator:a6aee3ae4a7ce090a944eee46dedddcf5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a86042d6e4f0186ea7abc6df6fe4c834f"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1_texture.html#a86042d6e4f0186ea7abc6df6fe4c834f">isReady</a> () const</td></tr>
<tr class="separator:a86042d6e4f0186ea7abc6df6fe4c834f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9db9d16745be5913be5e6d3e1497bbfc"><td class="memItemLeft" align="right" valign="top">unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1_texture.html#a9db9d16745be5913be5e6d3e1497bbfc">getWidth</a> () const</td></tr>
<tr class="separator:a9db9d16745be5913be5e6d3e1497bbfc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a995d206ca090ede2edc4dca7c7a83baf"><td class="memItemLeft" align="right" valign="top">unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1_texture.html#a995d206ca090ede2edc4dca7c7a83baf">getHeight</a> () const</td></tr>
<tr class="separator:a995d206ca090ede2edc4dca7c7a83baf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a73d90eef04a89ad92d7c2549e5d7aa4e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classcugl_1_1_size.html">Size</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1_texture.html#a73d90eef04a89ad92d7c2549e5d7aa4e">getSize</a> ()</td></tr>
<tr class="separator:a73d90eef04a89ad92d7c2549e5d7aa4e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9f4ae9548d4752bcae86865a9e4805de"><td class="memItemLeft" align="right" valign="top">unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1_texture.html#a9f4ae9548d4752bcae86865a9e4805de">getByteSize</a> () const</td></tr>
<tr class="separator:a9f4ae9548d4752bcae86865a9e4805de"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acfea467e981d2a72a7635f004c617238"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classcugl_1_1_texture.html#ac9762e396811469c04413c1c604ea3cd">PixelFormat</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1_texture.html#acfea467e981d2a72a7635f004c617238">getFormat</a> () const</td></tr>
<tr class="separator:acfea467e981d2a72a7635f004c617238"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aade213575a787a6591219eacb90b387e"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1_texture.html#aade213575a787a6591219eacb90b387e">hasMipMaps</a> () const</td></tr>
<tr class="separator:aade213575a787a6591219eacb90b387e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab452af930df2f2c9bdd07f0bace0a590"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1_texture.html#ab452af930df2f2c9bdd07f0bace0a590">buildMipMaps</a> ()</td></tr>
<tr class="separator:ab452af930df2f2c9bdd07f0bace0a590"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a39f7530d73e1a3c7079843bad3fd0bbc"><td class="memItemLeft" align="right" valign="top">GLuint&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1_texture.html#a39f7530d73e1a3c7079843bad3fd0bbc">getMinFilter</a> () const</td></tr>
<tr class="separator:a39f7530d73e1a3c7079843bad3fd0bbc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a254dc7f811ae8fdf1deaa5160196300e"><td class="memItemLeft" align="right" valign="top">GLuint&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1_texture.html#a254dc7f811ae8fdf1deaa5160196300e">getMagFilter</a> () const</td></tr>
<tr class="separator:a254dc7f811ae8fdf1deaa5160196300e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6a69872976e6cc02f465d12038ba516d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1_texture.html#a6a69872976e6cc02f465d12038ba516d">setMinFilter</a> (GLuint minFilter)</td></tr>
<tr class="separator:a6a69872976e6cc02f465d12038ba516d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a68d900d213e9f980b0e738d80874c462"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1_texture.html#a68d900d213e9f980b0e738d80874c462">setMagFilter</a> (GLuint magFilter)</td></tr>
<tr class="separator:a68d900d213e9f980b0e738d80874c462"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ada0fdd6309ca9e2b753c32c61386bb4a"><td class="memItemLeft" align="right" valign="top">GLuint&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1_texture.html#ada0fdd6309ca9e2b753c32c61386bb4a">getWrapS</a> () const</td></tr>
<tr class="separator:ada0fdd6309ca9e2b753c32c61386bb4a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af5ab70776de06840dec811a4223758ed"><td class="memItemLeft" align="right" valign="top">GLuint&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1_texture.html#af5ab70776de06840dec811a4223758ed">getWrapT</a> () const</td></tr>
<tr class="separator:af5ab70776de06840dec811a4223758ed"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8ce5e7b5bfc9069eb1e2d67743f55a81"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1_texture.html#a8ce5e7b5bfc9069eb1e2d67743f55a81">setWrapS</a> (GLuint wrap)</td></tr>
<tr class="separator:a8ce5e7b5bfc9069eb1e2d67743f55a81"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a40fede2bb77332b511871768a8a7eab4"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1_texture.html#a40fede2bb77332b511871768a8a7eab4">setWrapT</a> (GLuint wrap)</td></tr>
<tr class="separator:a40fede2bb77332b511871768a8a7eab4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adff41cd23c8ce09af9b0432fab940e91"><td class="memItemLeft" align="right" valign="top">const std::shared_ptr&lt; <a class="el" href="classcugl_1_1_texture.html">Texture</a> &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1_texture.html#adff41cd23c8ce09af9b0432fab940e91">getParent</a> () const</td></tr>
<tr class="separator:adff41cd23c8ce09af9b0432fab940e91"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aac1737939574a12734f54afd5ff30861"><td class="memItemLeft" align="right" valign="top">std::shared_ptr&lt; <a class="el" href="classcugl_1_1_texture.html">Texture</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1_texture.html#aac1737939574a12734f54afd5ff30861">getParent</a> ()</td></tr>
<tr class="separator:aac1737939574a12734f54afd5ff30861"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad2db6602a062b85d1be82014ff6384a5"><td class="memItemLeft" align="right" valign="top">std::shared_ptr&lt; <a class="el" href="classcugl_1_1_texture.html">Texture</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1_texture.html#ad2db6602a062b85d1be82014ff6384a5">getSubTexture</a> (GLfloat minS, GLfloat maxS, GLfloat minT, GLfloat maxT)</td></tr>
<tr class="separator:ad2db6602a062b85d1be82014ff6384a5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afe579049793db1ce892b5e3a4be543c4"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1_texture.html#afe579049793db1ce892b5e3a4be543c4">isSubTexture</a> () const</td></tr>
<tr class="separator:afe579049793db1ce892b5e3a4be543c4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac73ffe264621545bda0ab1e38bb4a56f"><td class="memItemLeft" align="right" valign="top">GLfloat&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1_texture.html#ac73ffe264621545bda0ab1e38bb4a56f">getMinS</a> () const</td></tr>
<tr class="separator:ac73ffe264621545bda0ab1e38bb4a56f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2ce401709827b3252d121ae9b2f6fc45"><td class="memItemLeft" align="right" valign="top">GLfloat&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1_texture.html#a2ce401709827b3252d121ae9b2f6fc45">getMinT</a> () const</td></tr>
<tr class="separator:a2ce401709827b3252d121ae9b2f6fc45"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad58f152331116ed880d95e6ab22d5855"><td class="memItemLeft" align="right" valign="top">GLfloat&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1_texture.html#ad58f152331116ed880d95e6ab22d5855">getMaxS</a> () const</td></tr>
<tr class="separator:ad58f152331116ed880d95e6ab22d5855"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae370133c66480087c8998f0e92e8fe1e"><td class="memItemLeft" align="right" valign="top">GLfloat&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1_texture.html#ae370133c66480087c8998f0e92e8fe1e">getMaxT</a> () const</td></tr>
<tr class="separator:ae370133c66480087c8998f0e92e8fe1e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad1c0e862467860440d8230be964ac734"><td class="memItemLeft" align="right" valign="top">GLuint&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1_texture.html#ad1c0e862467860440d8230be964ac734">getBuffer</a> () const</td></tr>
<tr class="separator:ad1c0e862467860440d8230be964ac734"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7304af125365874840495f7b2eb48aed"><td class="memItemLeft" align="right" valign="top">GLuint&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1_texture.html#a7304af125365874840495f7b2eb48aed">getBindPoint</a> () const</td></tr>
<tr class="separator:a7304af125365874840495f7b2eb48aed"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad9ddfa3651e2e005a9f217d7ce2e10f3"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1_texture.html#ad9ddfa3651e2e005a9f217d7ce2e10f3">setBindPoint</a> (GLuint point)</td></tr>
<tr class="separator:ad9ddfa3651e2e005a9f217d7ce2e10f3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4907a63990427c274693dad4f18593fa"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1_texture.html#a4907a63990427c274693dad4f18593fa">bind</a> ()</td></tr>
<tr class="separator:a4907a63990427c274693dad4f18593fa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0884390434e62ffbdcceb7f93fd8579e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1_texture.html#a0884390434e62ffbdcceb7f93fd8579e">unbind</a> ()</td></tr>
<tr class="separator:a0884390434e62ffbdcceb7f93fd8579e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a02065a42a67342496250b28ebc170fbf"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1_texture.html#a02065a42a67342496250b28ebc170fbf">isBound</a> () const</td></tr>
<tr class="separator:a02065a42a67342496250b28ebc170fbf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8adf298f1d542dcdcaaf023f405e5a73"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1_texture.html#a8adf298f1d542dcdcaaf023f405e5a73">isActive</a> () const</td></tr>
<tr class="separator:a8adf298f1d542dcdcaaf023f405e5a73"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a30ce1a7a4c68cfe28292f133d12a02af"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1_texture.html#a30ce1a7a4c68cfe28292f133d12a02af">toString</a> (bool verbose=false) const</td></tr>
<tr class="separator:a30ce1a7a4c68cfe28292f133d12a02af"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8642c2088d2c90c87876d62043f2a6d7"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1_texture.html#a8642c2088d2c90c87876d62043f2a6d7">operator std::string</a> () const</td></tr>
<tr class="separator:a8642c2088d2c90c87876d62043f2a6d7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aabeca9598671cadd49249985a017c1bc"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1_texture.html#aabeca9598671cadd49249985a017c1bc">save</a> (const std::string file)</td></tr>
<tr class="separator:aabeca9598671cadd49249985a017c1bc"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-static-methods"></a>
Static Public Member Functions</h2></td></tr>
<tr class="memitem:ab6268aa9f44d75cb587c7fcc1d6f58ab"><td class="memItemLeft" align="right" valign="top">static std::shared_ptr&lt; <a class="el" href="classcugl_1_1_texture.html">Texture</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1_texture.html#ab6268aa9f44d75cb587c7fcc1d6f58ab">alloc</a> (int width, int height, <a class="el" href="classcugl_1_1_texture.html#ac9762e396811469c04413c1c604ea3cd">PixelFormat</a> format=<a class="el" href="classcugl_1_1_texture.html#ac9762e396811469c04413c1c604ea3cdaea3495a278957dc58165e48a8945469f">PixelFormat::RGBA</a>)</td></tr>
<tr class="separator:ab6268aa9f44d75cb587c7fcc1d6f58ab"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2b2c7824e0798cae8a74ccd61b6f7c73"><td class="memItemLeft" align="right" valign="top">static std::shared_ptr&lt; <a class="el" href="classcugl_1_1_texture.html">Texture</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1_texture.html#a2b2c7824e0798cae8a74ccd61b6f7c73">allocWithData</a> (const void *data, int width, int height, <a class="el" href="classcugl_1_1_texture.html#ac9762e396811469c04413c1c604ea3cd">PixelFormat</a> format=<a class="el" href="classcugl_1_1_texture.html#ac9762e396811469c04413c1c604ea3cdaea3495a278957dc58165e48a8945469f">PixelFormat::RGBA</a>)</td></tr>
<tr class="separator:a2b2c7824e0798cae8a74ccd61b6f7c73"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8076d6d3af13a453184fa612c15dfe8e"><td class="memItemLeft" align="right" valign="top">static std::shared_ptr&lt; <a class="el" href="classcugl_1_1_texture.html">Texture</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1_texture.html#a8076d6d3af13a453184fa612c15dfe8e">allocWithFile</a> (const std::string filename)</td></tr>
<tr class="separator:a8076d6d3af13a453184fa612c15dfe8e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4966ffe089bdc6f0984c58cbb779896d"><td class="memItemLeft" align="right" valign="top">static const std::shared_ptr&lt; <a class="el" href="classcugl_1_1_texture.html">Texture</a> &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1_texture.html#a4966ffe089bdc6f0984c58cbb779896d">getBlank</a> ()</td></tr>
<tr class="separator:a4966ffe089bdc6f0984c58cbb779896d"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>This is a class representing an OpenGL texture.</p>
<p>We enforce that all textures must be a power-of-two along each dimension (though they need not be square). This is still required by some mobile devices and so it is easiest to require it across the board.</p>
<p>This class also provides support for texture atlases. Any non-repeating texture can produce a subtexture. A subtexture wraps the same texture data (and so does not require a context switch in the rendering pipeline), but has different start and end boundaries, as defined by minS, maxS, minT and maxT. See getSubtexture() for more information.</p>
<p>Shaders and textures have a many-to-many relationship. At any given time, a texture may be providing data to multiple shaders, and a shader may be working with multiple textures. This many-to-many relationship is captured by bind points. A texture is bound to a specific bind point and a shader associates a bind point with a sampler variable. That sampler variable then pulls data from the appropriate texture.</p>
<p>When discussing the relationship between a shader and a texture, we talk about a texture being bound and a texture being active. A bound texture is one that is associated with a shader; the shader will pull from the texture in a sampler variable. An active texture is one that is capable of receiving data from the CPU. A texture must be active if the user wants to change the data or filter settings of a texture.</p>
<p>Ideally, bound and active should be two separate concepts, like they are in <a class="el" href="classcugl_1_1_uniform_buffer.html">UniformBuffer</a>. However, for legacy reasons, OpenGL does not allow a texture to be active without being bound. Hence the <a class="el" href="classcugl_1_1_texture.html#a4907a63990427c274693dad4f18593fa">bind</a> method below is used for both activating and binding a texture. </p>
</div><h2 class="groupheader">Member Enumeration Documentation</h2>
<a id="ac9762e396811469c04413c1c604ea3cd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac9762e396811469c04413c1c604ea3cd">&#9670;&nbsp;</a></span>PixelFormat</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="classcugl_1_1_texture.html#ac9762e396811469c04413c1c604ea3cd">cugl::Texture::PixelFormat</a> : GLenum</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">strong</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>This enum lists the possible texture pixel formats.</p>
<p>This enum defines the pixel formats supported by CUGL. Because of cross-platform issues (we must support both OpenGL and OpenGLES), our textures only support a small subset of formats.</p>
<p>This enum also associates default internal types and data types with each pixel format. This greatly simplifies texture creation at the loss of some flexibility. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="ac9762e396811469c04413c1c604ea3cdaea3495a278957dc58165e48a8945469f"></a>RGBA&#160;</td><td class="fielddoc"><p>The default format: RGB with alpha transparency.</p>
<p>This format uses GL_RGBA8 as the internal format. The data type (for each component) is unsigned byte. </p>
</td></tr>
<tr><td class="fieldname"><a id="ac9762e396811469c04413c1c604ea3cda889574aebacda6bfd3e534e2b49b8028"></a>RGB&#160;</td><td class="fielddoc"><p>RGB with no alpha</p>
<p>All blending with this texture assumes alpha is 1.0. This format uses GL_RGB8 as the internal format. The data type (for each component) is unsigned byte. </p>
</td></tr>
<tr><td class="fieldname"><a id="ac9762e396811469c04413c1c604ea3cdaa2d9547b5d3dd9f05984475f7c926da0"></a>RED&#160;</td><td class="fielddoc"><p>A single color channel. In OpenGL that is identified as red.</p>
<p>The green and blue values will be 0. All blending with this texture assumes alpha is 1.0. This format uses GL_RGB8 as the internal format. The data type (for each component) is unsigned byte. </p>
</td></tr>
<tr><td class="fieldname"><a id="ac9762e396811469c04413c1c604ea3cdabc512462a2c883b0a43583f607c19b5a"></a>RED_GREEN&#160;</td><td class="fielddoc"><p>A dual color channel. In OpenGL that is identified as red and green.</p>
<p>The blue values will be 0. All blending with this texture assumes alpha is 1.0. This format uses GL_RGB8 as the internal format. The data type (for each component) is unsigned byte. </p>
</td></tr>
<tr><td class="fieldname"><a id="ac9762e396811469c04413c1c604ea3cdaaa1780b4fcce2d5d9af13dc25386d111"></a>DEPTH&#160;</td><td class="fielddoc"><p>A texture used to store a depth component.</p>
<p>This format uses GL_DEPTH_COMPONENT32F as the internal format. The data type (for the only component) is float. </p>
</td></tr>
<tr><td class="fieldname"><a id="ac9762e396811469c04413c1c604ea3cdaecaa8fe8cb0e85372f4cc76728c7cf3c"></a>DEPTH_STENCIL&#160;</td><td class="fielddoc"><p>A texture used to store a combined depth and stencil component</p>
<p>This format uses GL_DEPTH24_STENCIL8 as the internal format. The data type is GL_UNSIGNED_INT_24_8, giving 24 bytes to depth and 8 bits to the stencil. </p>
</td></tr>
</table>

</div>
</div>
<h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="ae00706fa56b20962bd5d3661a80034e9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae00706fa56b20962bd5d3661a80034e9">&#9670;&nbsp;</a></span>Texture()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">cugl::Texture::Texture </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Creates a new empty texture with no size.</p>
<p>This method performs no allocations. You must call init to generate a proper OpenGL texture. </p>

</div>
</div>
<a id="a4254550850246c44351ca5cf954cb22f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4254550850246c44351ca5cf954cb22f">&#9670;&nbsp;</a></span>~Texture()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">cugl::Texture::~Texture </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Deletes this texture, disposing all resources </p>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="ab6268aa9f44d75cb587c7fcc1d6f58ab"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab6268aa9f44d75cb587c7fcc1d6f58ab">&#9670;&nbsp;</a></span>alloc()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static std::shared_ptr&lt;<a class="el" href="classcugl_1_1_texture.html">Texture</a>&gt; cugl::Texture::alloc </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>width</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>height</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classcugl_1_1_texture.html#ac9762e396811469c04413c1c604ea3cd">PixelFormat</a>&#160;</td>
          <td class="paramname"><em>format</em> = <code><a class="el" href="classcugl_1_1_texture.html#ac9762e396811469c04413c1c604ea3cdaea3495a278957dc58165e48a8945469f">PixelFormat::RGBA</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns a new empty texture with the given dimensions.</p>
<p>Allocating a texture requires the use of the binding point at 0. Any texture bound to that point will be unbound. In addition, once allocation is done, this texture will not longer be bound as well.</p>
<p>You must use the <a class="el" href="classcugl_1_1_texture.html#a4c42edb3d985f33e1253c08128b41908">set()</a> method to load data into the texture.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">width</td><td>The texture width in pixels </td></tr>
    <tr><td class="paramname">height</td><td>The texture height in pixels </td></tr>
    <tr><td class="paramname">format</td><td>The texture data format</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a new empty texture with the given dimensions. </dd></dl>

</div>
</div>
<a id="a2b2c7824e0798cae8a74ccd61b6f7c73"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2b2c7824e0798cae8a74ccd61b6f7c73">&#9670;&nbsp;</a></span>allocWithData()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static std::shared_ptr&lt;<a class="el" href="classcugl_1_1_texture.html">Texture</a>&gt; cugl::Texture::allocWithData </td>
          <td>(</td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>width</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>height</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classcugl_1_1_texture.html#ac9762e396811469c04413c1c604ea3cd">PixelFormat</a>&#160;</td>
          <td class="paramname"><em>format</em> = <code><a class="el" href="classcugl_1_1_texture.html#ac9762e396811469c04413c1c604ea3cdaea3495a278957dc58165e48a8945469f">PixelFormat::RGBA</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns a new texture with the given data.</p>
<p>Allocating a texture requires the use of the binding point at 0. Any texture bound to that point will be unbound. In addition, once allocation is done, this texture will not longer be bound as well.</p>
<p>The data format must match the one given.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">data</td><td>The texture data (size width*height*format) </td></tr>
    <tr><td class="paramname">width</td><td>The texture width in pixels </td></tr>
    <tr><td class="paramname">height</td><td>The texture height in pixels </td></tr>
    <tr><td class="paramname">format</td><td>The texture data format</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a new texture with the given data. </dd></dl>

</div>
</div>
<a id="a8076d6d3af13a453184fa612c15dfe8e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8076d6d3af13a453184fa612c15dfe8e">&#9670;&nbsp;</a></span>allocWithFile()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static std::shared_ptr&lt;<a class="el" href="classcugl_1_1_texture.html">Texture</a>&gt; cugl::Texture::allocWithFile </td>
          <td>(</td>
          <td class="paramtype">const std::string&#160;</td>
          <td class="paramname"><em>filename</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns a new texture with the data from the given file.</p>
<p>Allocating a texture requires the use of the binding point at 0. Any texture bound to that point will be unbound. In addition, once allocation is done, this texture will not longer be bound as well.</p>
<p>This method can load any file format supported by SDL_Image. This includes (but is not limited to) PNG, JPEG, GIF, TIFF, BMP and PCX.</p>
<p>The texture will be stored in RGBA format, even if it is a file format that does not support transparency (e.g. JPEG).</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">filename</td><td>The file supporting the texture file.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a new texture with the given data </dd></dl>

</div>
</div>
<a id="a4907a63990427c274693dad4f18593fa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4907a63990427c274693dad4f18593fa">&#9670;&nbsp;</a></span>bind()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void cugl::Texture::bind </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Binds this texture to its bind point, making</p>
<p>Because of legacy issues with OpenGL, this method actually does two things. It attaches the block to the correct bind point, as defined by <a class="el" href="classcugl_1_1_texture.html#ad9ddfa3651e2e005a9f217d7ce2e10f3">setBindPoint</a>. It also makes this the active texture, capable of receiving OpenGL commands.</p>
<p>Unlike <a class="el" href="classcugl_1_1_uniform_buffer.html">UniformBuffer</a> is not possible to bind a texture without making it the active texture. Therefore, any existing texture will be deactivated, no matter its bind point. So this texture can be unbound without a call to <a class="el" href="classcugl_1_1_texture.html#a0884390434e62ffbdcceb7f93fd8579e">unbind</a>.</p>
<p>This call is reentrant. If can be safely called multiple times. </p>

</div>
</div>
<a id="ab452af930df2f2c9bdd07f0bace0a590"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab452af930df2f2c9bdd07f0bace0a590">&#9670;&nbsp;</a></span>buildMipMaps()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void cugl::Texture::buildMipMaps </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Builds mipmaps for the current texture.</p>
<p>This method will fail if this texture is a subtexture. Only the parent texture can have mipmaps. In addition, mipmaps can only be built if the texture size is a power of two.</p>
<p>This method is only successful if the texture is currently active. </p>

</div>
</div>
<a id="a7f4311b1ca1483a5ab98fe4b10e5fa83"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7f4311b1ca1483a5ab98fe4b10e5fa83">&#9670;&nbsp;</a></span>dispose()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void cugl::Texture::dispose </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Deletes the OpenGL texture and resets all attributes.</p>
<p>You must reinitialize the texture to use it. </p>

</div>
</div>
<a id="a7304af125365874840495f7b2eb48aed"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7304af125365874840495f7b2eb48aed">&#9670;&nbsp;</a></span>getBindPoint()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">GLuint cugl::Texture::getBindPoint </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns the bind point for this texture.</p>
<p>Textures and shaders have a many-to-many relationship. This means that connecting them requires an intermediate table. The positions in this table are called bind points. A texture is associated with a bind point and a shader associates a bind point with a sampler variable. That sampler variable then pulls data from the appropriate texture. By default this value is 0.</p>
<dl class="section return"><dt>Returns</dt><dd>the bind point for for this texture. </dd></dl>

</div>
</div>
<a id="a4966ffe089bdc6f0984c58cbb779896d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4966ffe089bdc6f0984c58cbb779896d">&#9670;&nbsp;</a></span>getBlank()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static const std::shared_ptr&lt;<a class="el" href="classcugl_1_1_texture.html">Texture</a>&gt;&amp; cugl::Texture::getBlank </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns a blank texture that can be used to make solid shapes.</p>
<p>Allocating a texture requires the use of the binding point at 0. Any texture bound to that point will be unbound. In addition, once allocation is done, this texture will not longer be bound as well.</p>
<p>This is the texture used by <a class="el" href="classcugl_1_1_sprite_batch.html">SpriteBatch</a> when the active texture is nullptr. It is a 2x2 texture of all white pixels. Using this texture means that all shapes and outlines will be drawn with a solid color.</p>
<p>This texture is a singleton. There is only one of it. All calls to this method will return a reference to the same object.</p>
<dl class="section return"><dt>Returns</dt><dd>a blank texture that can be used to make solid shapes. </dd></dl>

</div>
</div>
<a id="ad1c0e862467860440d8230be964ac734"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad1c0e862467860440d8230be964ac734">&#9670;&nbsp;</a></span>getBuffer()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">GLuint cugl::Texture::getBuffer </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns the OpenGL buffer for this texture.</p>
<p>The buffer is a value assigned by OpenGL when the texture was allocated. This method will return 0 if the texture is not initialized.</p>
<dl class="section return"><dt>Returns</dt><dd>the OpenGL buffer for this texture. </dd></dl>

</div>
</div>
<a id="a9f4ae9548d4752bcae86865a9e4805de"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9f4ae9548d4752bcae86865a9e4805de">&#9670;&nbsp;</a></span>getByteSize()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">unsigned int cugl::Texture::getByteSize </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns the number of bytes in a single pixel of this texture.</p>
<dl class="section return"><dt>Returns</dt><dd>the number of bytes in a single pixel of this texture. </dd></dl>

</div>
</div>
<a id="acfea467e981d2a72a7635f004c617238"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acfea467e981d2a72a7635f004c617238">&#9670;&nbsp;</a></span>getFormat()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcugl_1_1_texture.html#ac9762e396811469c04413c1c604ea3cd">PixelFormat</a> cugl::Texture::getFormat </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns the data format of this texture.</p>
<p>The data format determines what type of data can be assigned to this texture.</p>
<dl class="section return"><dt>Returns</dt><dd>the data format of this texture. </dd></dl>

</div>
</div>
<a id="a995d206ca090ede2edc4dca7c7a83baf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a995d206ca090ede2edc4dca7c7a83baf">&#9670;&nbsp;</a></span>getHeight()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">unsigned int cugl::Texture::getHeight </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns the height of this texture in pixels.</p>
<dl class="section return"><dt>Returns</dt><dd>the height of this texture in pixels. </dd></dl>

</div>
</div>
<a id="a254dc7f811ae8fdf1deaa5160196300e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a254dc7f811ae8fdf1deaa5160196300e">&#9670;&nbsp;</a></span>getMagFilter()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">GLuint cugl::Texture::getMagFilter </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns the mag filter of this texture.</p>
<p>The mag filter is the algorithm hint that OpenGL uses to make an image larger. The default is GL_LINEAR.</p>
<dl class="section return"><dt>Returns</dt><dd>the mag filter of this texture. </dd></dl>

</div>
</div>
<a id="ad58f152331116ed880d95e6ab22d5855"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad58f152331116ed880d95e6ab22d5855">&#9670;&nbsp;</a></span>getMaxS()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">GLfloat cugl::Texture::getMaxS </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns the maximum S texture coordinate for this texture.</p>
<p>When rescaling texture coordinates for a subtexture, this value is used in place of 0.</p>
<dl class="section return"><dt>Returns</dt><dd>the maximum S texture coordinate for this texture. </dd></dl>

</div>
</div>
<a id="ae370133c66480087c8998f0e92e8fe1e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae370133c66480087c8998f0e92e8fe1e">&#9670;&nbsp;</a></span>getMaxT()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">GLfloat cugl::Texture::getMaxT </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns the maximum T texture coordinate for this texture.</p>
<p>When rescaling texture coordinates for a subtexture, this value is used in place of 0.</p>
<dl class="section return"><dt>Returns</dt><dd>the maximum T texture coordinate for this texture. </dd></dl>

</div>
</div>
<a id="a39f7530d73e1a3c7079843bad3fd0bbc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a39f7530d73e1a3c7079843bad3fd0bbc">&#9670;&nbsp;</a></span>getMinFilter()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">GLuint cugl::Texture::getMinFilter </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns the min filter of this texture.</p>
<p>The min filter is the algorithm hint that OpenGL uses to make an image smaller. The default is GL_NEAREST.</p>
<dl class="section return"><dt>Returns</dt><dd>the min filter of this texture. </dd></dl>

</div>
</div>
<a id="ac73ffe264621545bda0ab1e38bb4a56f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac73ffe264621545bda0ab1e38bb4a56f">&#9670;&nbsp;</a></span>getMinS()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">GLfloat cugl::Texture::getMinS </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns the minimum S texture coordinate for this texture.</p>
<p>When rescaling texture coordinates for a subtexture, this value is used in place of 0.</p>
<dl class="section return"><dt>Returns</dt><dd>the minimum S texture coordinate for this texture. </dd></dl>

</div>
</div>
<a id="a2ce401709827b3252d121ae9b2f6fc45"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2ce401709827b3252d121ae9b2f6fc45">&#9670;&nbsp;</a></span>getMinT()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">GLfloat cugl::Texture::getMinT </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns the minimum T texture coordinate for this texture.</p>
<p>When rescaling texture coordinates for a subtexture, this value is used in place of 0.</p>
<dl class="section return"><dt>Returns</dt><dd>the minimum T texture coordinate for this texture. </dd></dl>

</div>
</div>
<a id="a6aee3ae4a7ce090a944eee46dedddcf5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6aee3ae4a7ce090a944eee46dedddcf5">&#9670;&nbsp;</a></span>getName()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const std::string&amp; cugl::Texture::getName </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns the name of this texture.</p>
<p>A name is a user-defined way of identifying a texture. Subtextures are permitted to have different names than their parents.</p>
<dl class="section return"><dt>Returns</dt><dd>the name of this texture. </dd></dl>

</div>
</div>
<a id="aac1737939574a12734f54afd5ff30861"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aac1737939574a12734f54afd5ff30861">&#9670;&nbsp;</a></span>getParent() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::shared_ptr&lt;<a class="el" href="classcugl_1_1_texture.html">Texture</a>&gt; cugl::Texture::getParent </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns the parent texture of this subtexture.</p>
<p>This method will return nullptr is this is not a subtexture.</p>
<p>Returns the parent texture of this subtexture. </p>

</div>
</div>
<a id="adff41cd23c8ce09af9b0432fab940e91"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adff41cd23c8ce09af9b0432fab940e91">&#9670;&nbsp;</a></span>getParent() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const std::shared_ptr&lt;<a class="el" href="classcugl_1_1_texture.html">Texture</a>&gt;&amp; cugl::Texture::getParent </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns the parent texture of this subtexture.</p>
<p>This method will return nullptr is this is not a subtexture.</p>
<p>Returns the parent texture of this subtexture. </p>

</div>
</div>
<a id="a73d90eef04a89ad92d7c2549e5d7aa4e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a73d90eef04a89ad92d7c2549e5d7aa4e">&#9670;&nbsp;</a></span>getSize()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcugl_1_1_size.html">Size</a> cugl::Texture::getSize </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns the size of this texture in pixels.</p>
<dl class="section return"><dt>Returns</dt><dd>the size of this texture in pixels. </dd></dl>

</div>
</div>
<a id="ad2db6602a062b85d1be82014ff6384a5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad2db6602a062b85d1be82014ff6384a5">&#9670;&nbsp;</a></span>getSubTexture()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::shared_ptr&lt;<a class="el" href="classcugl_1_1_texture.html">Texture</a>&gt; cugl::Texture::getSubTexture </td>
          <td>(</td>
          <td class="paramtype">GLfloat&#160;</td>
          <td class="paramname"><em>minS</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">GLfloat&#160;</td>
          <td class="paramname"><em>maxS</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">GLfloat&#160;</td>
          <td class="paramname"><em>minT</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">GLfloat&#160;</td>
          <td class="paramname"><em>maxT</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns a subtexture with the given dimensions.</p>
<p>The values must be 0 &lt;= minS &lt;= maxS &lt;= 1 and 0 &lt;= minT &lt;= maxT &lt;= 1. They specify the region of the texture to extract the subtexture.</p>
<p>It is the responsibility of the user to rescale the texture coordinates when using subtexture. Otherwise, the OpenGL pipeline will just use the original texture instead. See the method internal method prepare of <a class="el" href="classcugl_1_1_sprite_batch.html">SpriteBatch</a> for an example of how to scale texture coordinates.</p>
<p>It is possible to make a subtexture of a subtexture. However, in that case, the minS, maxS, minT and maxT values are all with respect to the original root texture. Furthermore, the parent of the new subtexture will be the original root texture. So no tree of subtextures is more than one level deep.</p>
<p>Returns a subtexture with the given dimensions. </p>

</div>
</div>
<a id="a9db9d16745be5913be5e6d3e1497bbfc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9db9d16745be5913be5e6d3e1497bbfc">&#9670;&nbsp;</a></span>getWidth()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">unsigned int cugl::Texture::getWidth </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns the width of this texture in pixels.</p>
<dl class="section return"><dt>Returns</dt><dd>the width of this texture in pixels. </dd></dl>

</div>
</div>
<a id="ada0fdd6309ca9e2b753c32c61386bb4a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ada0fdd6309ca9e2b753c32c61386bb4a">&#9670;&nbsp;</a></span>getWrapS()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">GLuint cugl::Texture::getWrapS </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns the horizontal wrap of this texture.</p>
<p>The default is GL_CLAMP_TO_EDGE.</p>
<dl class="section return"><dt>Returns</dt><dd>the horizontal wrap of this texture. </dd></dl>

</div>
</div>
<a id="af5ab70776de06840dec811a4223758ed"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af5ab70776de06840dec811a4223758ed">&#9670;&nbsp;</a></span>getWrapT()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">GLuint cugl::Texture::getWrapT </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns the vertical wrap of this texture.</p>
<p>The default is GL_CLAMP_TO_EDGE.</p>
<dl class="section return"><dt>Returns</dt><dd>the vertical wrap of this texture. </dd></dl>

</div>
</div>
<a id="aade213575a787a6591219eacb90b387e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aade213575a787a6591219eacb90b387e">&#9670;&nbsp;</a></span>hasMipMaps()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool cugl::Texture::hasMipMaps </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns whether this texture has generated mipmaps.</p>
<p>If this texture is a subtexture of texture with mipmaps, this method will also return true (and vice versa).</p>
<dl class="section return"><dt>Returns</dt><dd>whether this texture has generated mipmaps. </dd></dl>

</div>
</div>
<a id="a3fef5518341f65eae6a97dbfbabe6fb9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3fef5518341f65eae6a97dbfbabe6fb9">&#9670;&nbsp;</a></span>init()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool cugl::Texture::init </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>width</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>height</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classcugl_1_1_texture.html#ac9762e396811469c04413c1c604ea3cd">PixelFormat</a>&#160;</td>
          <td class="paramname"><em>format</em> = <code><a class="el" href="classcugl_1_1_texture.html#ac9762e396811469c04413c1c604ea3cdaea3495a278957dc58165e48a8945469f">PixelFormat::RGBA</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Initializes an empty texture with the given dimensions.</p>
<p>Initializing a texture requires the use of the binding point at 0. Any texture bound to that point will be unbound. In addition, once initialization is done, this texture will not longer be bound as well.</p>
<p>You must use the <a class="el" href="classcugl_1_1_texture.html#a4c42edb3d985f33e1253c08128b41908">set()</a> method to load data into the texture.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">width</td><td>The texture width in pixels </td></tr>
    <tr><td class="paramname">height</td><td>The texture height in pixels </td></tr>
    <tr><td class="paramname">format</td><td>The texture data format</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if initialization was successful. </dd></dl>

</div>
</div>
<a id="a13f8b761fed4ab717c0c86a35d8f16ca"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a13f8b761fed4ab717c0c86a35d8f16ca">&#9670;&nbsp;</a></span>initWithData()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool cugl::Texture::initWithData </td>
          <td>(</td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>width</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>height</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classcugl_1_1_texture.html#ac9762e396811469c04413c1c604ea3cd">PixelFormat</a>&#160;</td>
          <td class="paramname"><em>format</em> = <code><a class="el" href="classcugl_1_1_texture.html#ac9762e396811469c04413c1c604ea3cdaea3495a278957dc58165e48a8945469f">PixelFormat::RGBA</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Initializes an texture with the given data.</p>
<p>Initializing a texture requires the use of the binding point at 0. Any texture bound to that point will be unbound. In addition, once initialization is done, this texture will not longer be bound as well.</p>
<p>The data format must match the one given.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">data</td><td>The texture data (size width*height*format) </td></tr>
    <tr><td class="paramname">width</td><td>The texture width in pixels </td></tr>
    <tr><td class="paramname">height</td><td>The texture height in pixels </td></tr>
    <tr><td class="paramname">format</td><td>The texture data format</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if initialization was successful. </dd></dl>

</div>
</div>
<a id="a8dc1a183163ec4106c702e5c6200a459"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8dc1a183163ec4106c702e5c6200a459">&#9670;&nbsp;</a></span>initWithFile()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool cugl::Texture::initWithFile </td>
          <td>(</td>
          <td class="paramtype">const std::string&#160;</td>
          <td class="paramname"><em>filename</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Initializes an texture with the data from the given file.</p>
<p>Initializing a texture requires the use of the binding point at 0. Any texture bound to that point will be unbound. In addition, once initialization is done, this texture will not longer be bound as well.</p>
<p>This method can load any file format supported by SDL_Image. This includes (but is not limited to) PNG, JPEG, GIF, TIFF, BMP and PCX.</p>
<p>The texture will be stored in RGBA format, even if it is a file format that does not support transparency (e.g. JPEG).</p>
<p>IMPORTANT: In CUGL, relative path names always refer to the asset directory. If you wish to load a texture from somewhere else, you must use an absolute pathname.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">filename</td><td>The file supporting the texture file.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if initialization was successful. </dd></dl>

</div>
</div>
<a id="a8adf298f1d542dcdcaaf023f405e5a73"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8adf298f1d542dcdcaaf023f405e5a73">&#9670;&nbsp;</a></span>isActive()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool cugl::Texture::isActive </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns true if this texture is currently active.</p>
<p>An active uniform block is the one that receives data from OpenGL calls (such as glTexImage2D). Many of the setter-like methods in this class require the texture to be active to work properly (because of how OpenGL calls are wrapped).</p>
<p>Unlike <a class="el" href="classcugl_1_1_uniform_buffer.html">UniformBuffer</a>, it is not possible for a texture to be active without being bound. To activate a texture simply call the <a class="el" href="classcugl_1_1_texture.html#a4907a63990427c274693dad4f18593fa">bind</a> method.</p>
<dl class="section return"><dt>Returns</dt><dd>true if this texture is currently active. </dd></dl>

</div>
</div>
<a id="a02065a42a67342496250b28ebc170fbf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a02065a42a67342496250b28ebc170fbf">&#9670;&nbsp;</a></span>isBound()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool cugl::Texture::isBound </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns true if this texture is currently bound.</p>
<p>A texture is bound if it is attached to a bind point. That means that the shader will pull sampler data for that bind point from this texture.</p>
<p>A texture can be bound without being active. This happens when another texture has subsequently been bound, but to a different bind point.</p>
<dl class="section return"><dt>Returns</dt><dd>true if this texture is currently bound. </dd></dl>

</div>
</div>
<a id="a86042d6e4f0186ea7abc6df6fe4c834f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a86042d6e4f0186ea7abc6df6fe4c834f">&#9670;&nbsp;</a></span>isReady()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool cugl::Texture::isReady </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns true if this texture has been loaded into memory.</p>
<dl class="section return"><dt>Returns</dt><dd>true if this texture has been loaded into memory. </dd></dl>

</div>
</div>
<a id="afe579049793db1ce892b5e3a4be543c4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afe579049793db1ce892b5e3a4be543c4">&#9670;&nbsp;</a></span>isSubTexture()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool cugl::Texture::isSubTexture </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns true if this texture is a subtexture.</p>
<p>This is the same as checking if the parent is not nullptr.</p>
<dl class="section return"><dt>Returns</dt><dd>true if this texture is a subtexture. </dd></dl>

</div>
</div>
<a id="a8642c2088d2c90c87876d62043f2a6d7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8642c2088d2c90c87876d62043f2a6d7">&#9670;&nbsp;</a></span>operator std::string()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">cugl::Texture::operator std::string </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Casts from <a class="el" href="classcugl_1_1_texture.html">Texture</a> to a string. </p>

</div>
</div>
<a id="a4a527174ba98ef3265afac2d1d121838"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4a527174ba98ef3265afac2d1d121838">&#9670;&nbsp;</a></span>operator=()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classcugl_1_1_texture.html">Texture</a>&amp; cugl::Texture::operator= </td>
          <td>(</td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>data</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Sets this texture to have the contents of the given buffer.</p>
<p>The buffer must have the correct data format. In addition, the buffer must be size width*height*bytesize. See <a class="el" href="classcugl_1_1_texture.html#a9f4ae9548d4752bcae86865a9e4805de">getByteSize</a> for a description of the latter.</p>
<p>This method is only successful if the texture is currently active.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">data</td><td>The buffer to read into the texture</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a reference to this (modified) texture for chaining. </dd></dl>

</div>
</div>
<a id="aabeca9598671cadd49249985a017c1bc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aabeca9598671cadd49249985a017c1bc">&#9670;&nbsp;</a></span>save()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool cugl::Texture::save </td>
          <td>(</td>
          <td class="paramtype">const std::string&#160;</td>
          <td class="paramname"><em>file</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns true if able to save the texture to the given file.</p>
<p>The image will be saved as a PNG file. If the suffix of file is not .png, then this suffix will be added.</p>
<p>This method is only successful if the texture is currently active.</p>
<p>IMPORTANT: In CUGL, relative path names always refer to the asset directory, which is a read-only directory. Therefore, the file must must be specified with an absolute path. Using a relative path for this method will cause this method to fail.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">file</td><td>The name of the file to write to</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if able to save the texture to the given file. </dd></dl>

</div>
</div>
<a id="a4c42edb3d985f33e1253c08128b41908"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4c42edb3d985f33e1253c08128b41908">&#9670;&nbsp;</a></span>set()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classcugl_1_1_texture.html">Texture</a>&amp; cugl::Texture::set </td>
          <td>(</td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>data</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Sets this texture to have the contents of the given buffer.</p>
<p>The buffer must have the correct data format. In addition, the buffer must be size width*height*bytesize. See <a class="el" href="classcugl_1_1_texture.html#a9f4ae9548d4752bcae86865a9e4805de">getByteSize</a> for a description of the latter.</p>
<p>This method is only successful if the texture is currently active.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">data</td><td>The buffer to read into the texture</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a reference to this (modified) texture for chaining. </dd></dl>

</div>
</div>
<a id="ad9ddfa3651e2e005a9f217d7ce2e10f3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad9ddfa3651e2e005a9f217d7ce2e10f3">&#9670;&nbsp;</a></span>setBindPoint()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void cugl::Texture::setBindPoint </td>
          <td>(</td>
          <td class="paramtype">GLuint&#160;</td>
          <td class="paramname"><em>point</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Sets the bind point for this texture.</p>
<p>Textures and shaders have a many-to-many relationship. This means that connecting them requires an intermediate table. The positions in this table are called bind points. A texture is associated with a bind point and a shader associates a bind point with a sampler variable. That sampler variable then pulls data from the appropriate texture. By default this value is 0.</p>
<p>The texture does not need to be active to call this method. This method only sets the bind point preference and does not actually <a class="el" href="classcugl_1_1_texture.html#a4907a63990427c274693dad4f18593fa">bind</a> the texture. However, if the texture is bound to another bind point, then it will be unbound from that point.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">point</td><td>The bind point for this texture. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a68d900d213e9f980b0e738d80874c462"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a68d900d213e9f980b0e738d80874c462">&#9670;&nbsp;</a></span>setMagFilter()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void cugl::Texture::setMagFilter </td>
          <td>(</td>
          <td class="paramtype">GLuint&#160;</td>
          <td class="paramname"><em>magFilter</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Sets the mag filter of this texture.</p>
<p>The mag filter is the algorithm hint that OpenGL uses to make an image larger. The default is GL_LINEAR.</p>
<p>This method may be safely called even if this texture is not active. The preference will be applied once the texture is activated.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">magFilter</td><td>The mag filter of this texture. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a6a69872976e6cc02f465d12038ba516d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6a69872976e6cc02f465d12038ba516d">&#9670;&nbsp;</a></span>setMinFilter()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void cugl::Texture::setMinFilter </td>
          <td>(</td>
          <td class="paramtype">GLuint&#160;</td>
          <td class="paramname"><em>minFilter</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Sets the min filter of this texture.</p>
<p>The min filter is the algorithm hint that OpenGL uses to make an image smaller. The default is GL_NEAREST.</p>
<p>This method may be safely called even if this texture is not active. The preference will be applied once the texture is activated.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">minFilter</td><td>The min filter of this texture. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a0e83b26b63dfb4d7584eec7965d34735"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0e83b26b63dfb4d7584eec7965d34735">&#9670;&nbsp;</a></span>setName()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void cugl::Texture::setName </td>
          <td>(</td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>name</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Sets the name of this texture.</p>
<p>A name is a user-defined way of identifying a texture. Subtextures are permitted to have different names than their parents.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">name</td><td>The name of this texture. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a8ce5e7b5bfc9069eb1e2d67743f55a81"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8ce5e7b5bfc9069eb1e2d67743f55a81">&#9670;&nbsp;</a></span>setWrapS()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void cugl::Texture::setWrapS </td>
          <td>(</td>
          <td class="paramtype">GLuint&#160;</td>
          <td class="paramname"><em>wrap</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Sets the horizontal wrap of this texture.</p>
<p>The default is GL_CLAMP_TO_EDGE.</p>
<p>This method may be safely called even if this texture is not active. The preference will be applied once the texture is activated.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">wrap</td><td>The horizontal wrap setting of this texture </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a40fede2bb77332b511871768a8a7eab4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a40fede2bb77332b511871768a8a7eab4">&#9670;&nbsp;</a></span>setWrapT()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void cugl::Texture::setWrapT </td>
          <td>(</td>
          <td class="paramtype">GLuint&#160;</td>
          <td class="paramname"><em>wrap</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Sets the vertical wrap of this texture.</p>
<p>The default is GL_CLAMP_TO_EDGE.</p>
<p>This method may be safely called even if this texture is not active. The preference will be applied once the texture is activated.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">wrap</td><td>The vertical wrap setting of this texture </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a30ce1a7a4c68cfe28292f133d12a02af"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a30ce1a7a4c68cfe28292f133d12a02af">&#9670;&nbsp;</a></span>toString()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string cugl::Texture::toString </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>verbose</em> = <code>false</code></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns a string representation of this texture for debugging purposes.</p>
<p>If verbose is true, the string will include class information. This allows us to unambiguously identify the class.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">verbose</td><td>Whether to include class information</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a string representation of this texture for debugging purposes. </dd></dl>

</div>
</div>
<a id="a0884390434e62ffbdcceb7f93fd8579e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0884390434e62ffbdcceb7f93fd8579e">&#9670;&nbsp;</a></span>unbind()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void cugl::Texture::unbind </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Unbinds this texture, making it neither bound nor active.</p>
<p>If another texture is active, calling this method will not effect that texture. But once unbound, the shader will no longer receive data from the bind point for this texture. A new texture must be bound for the shader to receive data.</p>
<p>Unlike <a class="el" href="classcugl_1_1_uniform_buffer.html">UniformBuffer</a>, it is not possible to unbind a texture without deactivating it.</p>
<p>This call is reentrant. If can be safely called multiple times. </p>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>include/cugl/render/<a class="el" href="_c_u_texture_8h_source.html">CUTexture.h</a></li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.1
</small></address>
</body>
</html>
