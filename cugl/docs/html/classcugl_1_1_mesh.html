<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.9.1"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>CUGL 2.0: cugl::Mesh&lt; T &gt; Class Template Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">CUGL 2.0
   </div>
   <div id="projectbrief">Cornell University Game Library</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.1 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search','.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespacecugl.html">cugl</a></li><li class="navelem"><a class="el" href="classcugl_1_1_mesh.html">Mesh</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-attribs">Public Attributes</a> &#124;
<a href="classcugl_1_1_mesh-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">cugl::Mesh&lt; T &gt; Class Template Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p><code>#include &lt;<a class="el" href="_c_u_mesh_8h_source.html">CUMesh.h</a>&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:ab06371869fa0166dcf01d35a0bb6e05b"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1_mesh.html#ab06371869fa0166dcf01d35a0bb6e05b">Mesh</a> ()</td></tr>
<tr class="separator:ab06371869fa0166dcf01d35a0bb6e05b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af51203495bbec0cf2a42cec661081a3f"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1_mesh.html#af51203495bbec0cf2a42cec661081a3f">~Mesh</a> ()</td></tr>
<tr class="separator:af51203495bbec0cf2a42cec661081a3f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6f65e9a3cc300a8169ddbee1f6475620"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1_mesh.html#a6f65e9a3cc300a8169ddbee1f6475620">Mesh</a> (const <a class="el" href="classcugl_1_1_mesh.html">Mesh</a> &amp;mesh)</td></tr>
<tr class="separator:a6f65e9a3cc300a8169ddbee1f6475620"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a72455fa56465e0473757df2b1f69953d"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1_mesh.html#a72455fa56465e0473757df2b1f69953d">Mesh</a> (<a class="el" href="classcugl_1_1_mesh.html">Mesh</a> &amp;&amp;mesh)</td></tr>
<tr class="separator:a72455fa56465e0473757df2b1f69953d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adb6e0939db1bc47966a3e9997cf605c2"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1_mesh.html#adb6e0939db1bc47966a3e9997cf605c2">Mesh</a> (const <a class="el" href="classcugl_1_1_poly2.html">Poly2</a> &amp;poly)</td></tr>
<tr class="separator:adb6e0939db1bc47966a3e9997cf605c2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac5d39fcbe603c5421a2c52b5313479f4"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classcugl_1_1_mesh.html">Mesh</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1_mesh.html#ac5d39fcbe603c5421a2c52b5313479f4">operator=</a> (const <a class="el" href="classcugl_1_1_mesh.html">Mesh</a> &amp;other)</td></tr>
<tr class="separator:ac5d39fcbe603c5421a2c52b5313479f4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae105a7d7215b532658da3e2c1868e150"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classcugl_1_1_mesh.html">Mesh</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1_mesh.html#ae105a7d7215b532658da3e2c1868e150">operator=</a> (<a class="el" href="classcugl_1_1_mesh.html">Mesh</a> &amp;&amp;other)</td></tr>
<tr class="separator:ae105a7d7215b532658da3e2c1868e150"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ade718340e5e8d6c9b4bf1b138a417361"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classcugl_1_1_mesh.html">Mesh</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1_mesh.html#ade718340e5e8d6c9b4bf1b138a417361">operator=</a> (const <a class="el" href="classcugl_1_1_poly2.html">Poly2</a> &amp;poly)</td></tr>
<tr class="separator:ade718340e5e8d6c9b4bf1b138a417361"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa4c9008fb5a44d64628dafc09ffbd38d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classcugl_1_1_mesh.html">Mesh</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1_mesh.html#aa4c9008fb5a44d64628dafc09ffbd38d">set</a> (const <a class="el" href="classcugl_1_1_mesh.html">Mesh</a> &amp;other)</td></tr>
<tr class="separator:aa4c9008fb5a44d64628dafc09ffbd38d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aea2b05331e1bc7b22eb0dd761454dc7f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classcugl_1_1_mesh.html">Mesh</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1_mesh.html#aea2b05331e1bc7b22eb0dd761454dc7f">set</a> (const <a class="el" href="classcugl_1_1_poly2.html">Poly2</a> &amp;poly)</td></tr>
<tr class="separator:aea2b05331e1bc7b22eb0dd761454dc7f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7572bdccccf8febaa036900cc7c2dc4e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classcugl_1_1_mesh.html">Mesh</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1_mesh.html#a7572bdccccf8febaa036900cc7c2dc4e">set</a> (const std::vector&lt; T &gt; &amp;verts)</td></tr>
<tr class="separator:a7572bdccccf8febaa036900cc7c2dc4e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a845d5af44ca45a60ede864869255505b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classcugl_1_1_mesh.html">Mesh</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1_mesh.html#a845d5af44ca45a60ede864869255505b">set</a> (const std::vector&lt; T &gt; &amp;verts, const std::vector&lt; GLuint &gt; &amp;indx)</td></tr>
<tr class="separator:a845d5af44ca45a60ede864869255505b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae182a7c1b9f59547f6b30dec81b4ac66"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classcugl_1_1_mesh.html">Mesh</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1_mesh.html#ae182a7c1b9f59547f6b30dec81b4ac66">clear</a> ()</td></tr>
<tr class="separator:ae182a7c1b9f59547f6b30dec81b4ac66"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a01e523a831ba481926a32e482840dbce"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classcugl_1_1_mesh.html">Mesh</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1_mesh.html#a01e523a831ba481926a32e482840dbce">operator*=</a> (const <a class="el" href="classcugl_1_1_mat4.html">Mat4</a> &amp;transform)</td></tr>
<tr class="separator:a01e523a831ba481926a32e482840dbce"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9df2d9d822d1027ea3313d4b6f5cabf5"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classcugl_1_1_mesh.html">Mesh</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1_mesh.html#a9df2d9d822d1027ea3313d4b6f5cabf5">operator*</a> (const <a class="el" href="classcugl_1_1_mat4.html">Mat4</a> &amp;transform) const</td></tr>
<tr class="separator:a9df2d9d822d1027ea3313d4b6f5cabf5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae26460ee531d639a3da733dea208810b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classcugl_1_1_mesh.html">Mesh</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1_mesh.html#ae26460ee531d639a3da733dea208810b">operator+=</a> (const <a class="el" href="classcugl_1_1_mesh.html">Mesh</a> &amp;other)</td></tr>
<tr class="separator:ae26460ee531d639a3da733dea208810b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ace232681be4b36fb157010ea080edc9b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classcugl_1_1_mesh.html">Mesh</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1_mesh.html#ace232681be4b36fb157010ea080edc9b">operator+</a> (const <a class="el" href="classcugl_1_1_mesh.html">Mesh</a> &amp;other) const</td></tr>
<tr class="separator:ace232681be4b36fb157010ea080edc9b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a59ed1008728cdd30fe0f1cece51a2b1b"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1_mesh.html#a59ed1008728cdd30fe0f1cece51a2b1b">isSliceable</a> () const</td></tr>
<tr class="separator:a59ed1008728cdd30fe0f1cece51a2b1b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae85ac83de197b228288cddd28dd06bd7"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classcugl_1_1_mesh.html">Mesh</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1_mesh.html#ae85ac83de197b228288cddd28dd06bd7">slice</a> (size_t start, size_t end) const</td></tr>
<tr class="separator:ae85ac83de197b228288cddd28dd06bd7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a58d69611b323ac7c70d91b137d410926"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classcugl_1_1_mesh.html">Mesh</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1_mesh.html#a58d69611b323ac7c70d91b137d410926">sliceFrom</a> (size_t start) const</td></tr>
<tr class="separator:a58d69611b323ac7c70d91b137d410926"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a28d8f41100f57c3f943d311e139cf526"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classcugl_1_1_mesh.html">Mesh</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1_mesh.html#a28d8f41100f57c3f943d311e139cf526">sliceTo</a> (size_t end) const</td></tr>
<tr class="separator:a28d8f41100f57c3f943d311e139cf526"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-attribs"></a>
Public Attributes</h2></td></tr>
<tr class="memitem:a460693ae62f12032d1f37f71fab31581"><td class="memItemLeft" align="right" valign="top">std::vector&lt; T &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1_mesh.html#a460693ae62f12032d1f37f71fab31581">vertices</a></td></tr>
<tr class="separator:a460693ae62f12032d1f37f71fab31581"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a36f1b7bcf5e56d49be7af1cccec86b8b"><td class="memItemLeft" align="right" valign="top">std::vector&lt; GLuint &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1_mesh.html#a36f1b7bcf5e56d49be7af1cccec86b8b">indices</a></td></tr>
<tr class="separator:a36f1b7bcf5e56d49be7af1cccec86b8b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a439820bedf2c38ce52cfa1817f36c80f"><td class="memItemLeft" align="right" valign="top">GLenum&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1_mesh.html#a439820bedf2c38ce52cfa1817f36c80f">command</a></td></tr>
<tr class="separator:a439820bedf2c38ce52cfa1817f36c80f"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><h3>template&lt;class T&gt;<br />
class cugl::Mesh&lt; T &gt;</h3>

<p>This class represents an arbitrary drawing mesh.</p>
<p>A mesh is a collection of vertices, together with indices and a drawing command. The type of the indices and drawing command are fixed, but the vertex type is templated. This allows a mesh to be adapter to an arbitrary <a class="el" href="classcugl_1_1_shader.html">Shader</a>.</p>
<p>The only requirement of a mesh vertex is that it have at least one field called position, and this type be one of <a class="el" href="classcugl_1_1_vec2.html">Vec2</a>, <a class="el" href="classcugl_1_1_vec3.html">Vec3</a> or <a class="el" href="classcugl_1_1_vec4.html">Vec4</a>. </p>
</div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="ab06371869fa0166dcf01d35a0bb6e05b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab06371869fa0166dcf01d35a0bb6e05b">&#9670;&nbsp;</a></span>Mesh() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcugl_1_1_mesh.html">cugl::Mesh</a>&lt; T &gt;::<a class="el" href="classcugl_1_1_mesh.html">Mesh</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Creates an empty mesh with no data.</p>
<p>Access the attributes to add data to the mesh. </p>

</div>
</div>
<a id="af51203495bbec0cf2a42cec661081a3f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af51203495bbec0cf2a42cec661081a3f">&#9670;&nbsp;</a></span>~Mesh()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcugl_1_1_mesh.html">cugl::Mesh</a>&lt; T &gt;::~<a class="el" href="classcugl_1_1_mesh.html">Mesh</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Deletes the given mesh, freeing all resources. </p>

</div>
</div>
<a id="a6f65e9a3cc300a8169ddbee1f6475620"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6f65e9a3cc300a8169ddbee1f6475620">&#9670;&nbsp;</a></span>Mesh() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcugl_1_1_mesh.html">cugl::Mesh</a>&lt; T &gt;::<a class="el" href="classcugl_1_1_mesh.html">Mesh</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classcugl_1_1_mesh.html">Mesh</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>mesh</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Creates a copy of the given mesh.</p>
<p>Both the vertices and the indices are copied. No references to the original mesh are kept.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">mesh</td><td>The mesh to copy </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a72455fa56465e0473757df2b1f69953d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a72455fa56465e0473757df2b1f69953d">&#9670;&nbsp;</a></span>Mesh() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcugl_1_1_mesh.html">cugl::Mesh</a>&lt; T &gt;::<a class="el" href="classcugl_1_1_mesh.html">Mesh</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classcugl_1_1_mesh.html">Mesh</a>&lt; T &gt; &amp;&amp;&#160;</td>
          <td class="paramname"><em>mesh</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Creates a copy with the resource of the given polygon.</p>
<p>It is unsafe to use the original mesh after this method is called.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">mesh</td><td>The mesh to take from </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="adb6e0939db1bc47966a3e9997cf605c2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adb6e0939db1bc47966a3e9997cf605c2">&#9670;&nbsp;</a></span>Mesh() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcugl_1_1_mesh.html">cugl::Mesh</a>&lt; T &gt;::<a class="el" href="classcugl_1_1_mesh.html">Mesh</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classcugl_1_1_poly2.html">Poly2</a> &amp;&#160;</td>
          <td class="paramname"><em>poly</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Creates a mesh from the given <a class="el" href="classcugl_1_1_poly2.html">Poly2</a> object.</p>
<p>No vertex attribute other than position is set. Additional information (such as color or texture coordinate) must be added later. The command will be GL_TRIANGLES if the polygon is solid, GL_LINES if it is a path, and GL_UNDEFINED otherwise.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">poly</td><td>The polygon defining this mesh </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="ae182a7c1b9f59547f6b30dec81b4ac66"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae182a7c1b9f59547f6b30dec81b4ac66">&#9670;&nbsp;</a></span>clear()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcugl_1_1_mesh.html">Mesh</a>&amp; <a class="el" href="classcugl_1_1_mesh.html">cugl::Mesh</a>&lt; T &gt;::clear </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Clears the contents of this mesh and sets the command to GL_LINES</p>
<dl class="section return"><dt>Returns</dt><dd>This mesh for chaining </dd></dl>

</div>
</div>
<a id="a59ed1008728cdd30fe0f1cece51a2b1b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a59ed1008728cdd30fe0f1cece51a2b1b">&#9670;&nbsp;</a></span>isSliceable()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classcugl_1_1_mesh.html">cugl::Mesh</a>&lt; T &gt;::isSliceable </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns true is this mesh is sliceable.</p>
<p>The only sliceable mesh types are GL_LINES and GL_TRIANGLES. That is because the mesh is represented in regular, decomposable chunks. This method not only checks that the command is correct, but that the index size is correct as well.</p>
<dl class="section return"><dt>Returns</dt><dd>true is this mesh is sliceable. </dd></dl>

</div>
</div>
<a id="a9df2d9d822d1027ea3313d4b6f5cabf5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9df2d9d822d1027ea3313d4b6f5cabf5">&#9670;&nbsp;</a></span>operator*()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcugl_1_1_mesh.html">Mesh</a> <a class="el" href="classcugl_1_1_mesh.html">cugl::Mesh</a>&lt; T &gt;::operator* </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classcugl_1_1_mat4.html">Mat4</a> &amp;&#160;</td>
          <td class="paramname"><em>transform</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns a new mesh by transforming the vertices of this one.</p>
<p>Because we allow meshes to be of arbitrary dimension, the only guaranteed safe transforms are <a class="el" href="classcugl_1_1_mat4.html">Mat4</a> objects.</p>
<p>Note: This method does not modify the mesh.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">transform</td><td>The transform matrix</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The transformed mesh </dd></dl>

</div>
</div>
<a id="a01e523a831ba481926a32e482840dbce"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a01e523a831ba481926a32e482840dbce">&#9670;&nbsp;</a></span>operator*=()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcugl_1_1_mesh.html">Mesh</a>&amp; <a class="el" href="classcugl_1_1_mesh.html">cugl::Mesh</a>&lt; T &gt;::operator*= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classcugl_1_1_mat4.html">Mat4</a> &amp;&#160;</td>
          <td class="paramname"><em>transform</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Transforms all of the vertices of this mesh.</p>
<p>Because we allow meshes to be of arbitrary dimension, the only guaranteed safe transforms are <a class="el" href="classcugl_1_1_mat4.html">Mat4</a> objects.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">transform</td><td>The transform matrix</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>This mesh with the vertices transformed </dd></dl>

</div>
</div>
<a id="ace232681be4b36fb157010ea080edc9b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ace232681be4b36fb157010ea080edc9b">&#9670;&nbsp;</a></span>operator+()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcugl_1_1_mesh.html">Mesh</a> <a class="el" href="classcugl_1_1_mesh.html">cugl::Mesh</a>&lt; T &gt;::operator+ </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classcugl_1_1_mesh.html">Mesh</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Return the concatenation of this mesh and other.</p>
<p>The vertices of other are appended to the end of this mesh. The indices are reindex to account for this shift.</p>
<p>This method will fail to append to the mesh if other does not share the same command as this mesh.</p>
<p>Note: This method does not modify the mesh.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">other</td><td>The mesh to concatenate</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the concatenation of this mesh and other. </dd></dl>

</div>
</div>
<a id="ae26460ee531d639a3da733dea208810b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae26460ee531d639a3da733dea208810b">&#9670;&nbsp;</a></span>operator+=()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcugl_1_1_mesh.html">Mesh</a>&amp; <a class="el" href="classcugl_1_1_mesh.html">cugl::Mesh</a>&lt; T &gt;::operator+= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classcugl_1_1_mesh.html">Mesh</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Appends the given mesh to this one.</p>
<p>The vertices of other are appended to the end of this mesh. The indices are reindex to account for this shift.</p>
<p>This method will fail to append to the mesh if other does not share the same command as this mesh.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">other</td><td>The mesh to append</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>This mesh with the new vertices </dd></dl>

</div>
</div>
<a id="ac5d39fcbe603c5421a2c52b5313479f4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac5d39fcbe603c5421a2c52b5313479f4">&#9670;&nbsp;</a></span>operator=() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcugl_1_1_mesh.html">Mesh</a>&amp; <a class="el" href="classcugl_1_1_mesh.html">cugl::Mesh</a>&lt; T &gt;::operator= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classcugl_1_1_mesh.html">Mesh</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Sets this mesh to be a copy of the given one.</p>
<p>All of the contents are copied, so that this mesh does not hold any references to elements of the other mesh. This method returns a reference to this mesh for chaining.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">other</td><td>The mesh to copy</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>This mesh for chaining </dd></dl>

</div>
</div>
<a id="ade718340e5e8d6c9b4bf1b138a417361"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ade718340e5e8d6c9b4bf1b138a417361">&#9670;&nbsp;</a></span>operator=() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcugl_1_1_mesh.html">Mesh</a>&amp; <a class="el" href="classcugl_1_1_mesh.html">cugl::Mesh</a>&lt; T &gt;::operator= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classcugl_1_1_poly2.html">Poly2</a> &amp;&#160;</td>
          <td class="paramname"><em>poly</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Sets the mesh to match the <a class="el" href="classcugl_1_1_poly2.html">Poly2</a> object.</p>
<p>No vertex attribute other than position is set. Additional information (such as color or texture coordinate) must be added later. The command will be GL_TRIANGLES if the polygon is solid, GL_LINES if it is a path, and GL_UNDEFINED otherwise.</p>
<p>This method returns a reference to this polygon for chaining.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">poly</td><td>The polygon defining this mesh</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>This polygon, returned for chaining </dd></dl>

</div>
</div>
<a id="ae105a7d7215b532658da3e2c1868e150"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae105a7d7215b532658da3e2c1868e150">&#9670;&nbsp;</a></span>operator=() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcugl_1_1_mesh.html">Mesh</a>&amp; <a class="el" href="classcugl_1_1_mesh.html">cugl::Mesh</a>&lt; T &gt;::operator= </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classcugl_1_1_mesh.html">Mesh</a>&lt; T &gt; &amp;&amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Sets this mesh to be have the resources of the given one.</p>
<p>It is unsafe to use the original mesh after this method is called.</p>
<p>This method returns a reference to this mesh for chaining.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">other</td><td>The mesh to take from</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>This mesh for chaining </dd></dl>

</div>
</div>
<a id="aa4c9008fb5a44d64628dafc09ffbd38d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa4c9008fb5a44d64628dafc09ffbd38d">&#9670;&nbsp;</a></span>set() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcugl_1_1_mesh.html">Mesh</a>&amp; <a class="el" href="classcugl_1_1_mesh.html">cugl::Mesh</a>&lt; T &gt;::set </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classcugl_1_1_mesh.html">Mesh</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Sets this mesh to be a copy of the given one.</p>
<p>All of the contents are copied, so that this mesh does not hold any references to elements of the other mesh. This method returns a reference to this mesh for chaining.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">other</td><td>The mesh to copy</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>This mesh for chaining </dd></dl>

</div>
</div>
<a id="aea2b05331e1bc7b22eb0dd761454dc7f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aea2b05331e1bc7b22eb0dd761454dc7f">&#9670;&nbsp;</a></span>set() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcugl_1_1_mesh.html">Mesh</a>&amp; <a class="el" href="classcugl_1_1_mesh.html">cugl::Mesh</a>&lt; T &gt;::set </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classcugl_1_1_poly2.html">Poly2</a> &amp;&#160;</td>
          <td class="paramname"><em>poly</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Sets the mesh to match the <a class="el" href="classcugl_1_1_poly2.html">Poly2</a> object.</p>
<p>No vertex attribute other than position is set. Additional information (such as color or texture coordinate) must be added later. The command will be GL_TRIANGLES if the polygon is solid, GL_LINES if it is a path, and GL_UNDEFINED otherwise.</p>
<p>This method returns a reference to this polygon for chaining.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">poly</td><td>The polygon defining this mesh</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>This polygon, returned for chaining </dd></dl>

</div>
</div>
<a id="a7572bdccccf8febaa036900cc7c2dc4e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7572bdccccf8febaa036900cc7c2dc4e">&#9670;&nbsp;</a></span>set() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcugl_1_1_mesh.html">Mesh</a>&amp; <a class="el" href="classcugl_1_1_mesh.html">cugl::Mesh</a>&lt; T &gt;::set </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>verts</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Sets the mesh to have the given vertices</p>
<p>The resulting mesh has no indices. The command will be reset to GL_UNDEFINED.</p>
<p>This method returns a reference to this mesh for chaining.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">verts</td><td>The vector of vertices (as <a class="el" href="classcugl_1_1_vec2.html">Vec2</a>) in this mesh</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>This mesh for chaining </dd></dl>

</div>
</div>
<a id="a845d5af44ca45a60ede864869255505b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a845d5af44ca45a60ede864869255505b">&#9670;&nbsp;</a></span>set() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcugl_1_1_mesh.html">Mesh</a>&amp; <a class="el" href="classcugl_1_1_mesh.html">cugl::Mesh</a>&lt; T &gt;::set </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>verts</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; GLuint &gt; &amp;&#160;</td>
          <td class="paramname"><em>indx</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Sets a mesh to have the given vertices and indices.</p>
<p>This method will assign a command according to the multiplicity of the indices. If the number of indices n is divisible by 3, it will be GL_TRIANGLES. Otherwise, if it is even, it will be GL_LINES. All other values will be undefined and the user must manually set the type.</p>
<p>This method returns a reference to this mesh for chaining.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">verts</td><td>The vector of vertices (as floats) in this mesh </td></tr>
    <tr><td class="paramname">indx</td><td>The vector of indices for the rendering</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>This mesh for chaining </dd></dl>

</div>
</div>
<a id="ae85ac83de197b228288cddd28dd06bd7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae85ac83de197b228288cddd28dd06bd7">&#9670;&nbsp;</a></span>slice()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcugl_1_1_mesh.html">Mesh</a> <a class="el" href="classcugl_1_1_mesh.html">cugl::Mesh</a>&lt; T &gt;::slice </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>start</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>end</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns the slice of this mesh between start and end.</p>
<p>The sliced mesh will use the indices from start to end (not including end). It will include the vertices referenced by those indices, and only those vertices. The command will remain the same.</p>
<p>The only sliceable mesh types are GL_LINES and GL_TRIANGLES. That is because the mesh is represented in regular, decomposable chunks. Any attempt to slice another mesh type will fail.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">start</td><td>The start index </td></tr>
    <tr><td class="paramname">end</td><td>The end index</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the slice of this mesh between start and end. </dd></dl>

</div>
</div>
<a id="a58d69611b323ac7c70d91b137d410926"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a58d69611b323ac7c70d91b137d410926">&#9670;&nbsp;</a></span>sliceFrom()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcugl_1_1_mesh.html">Mesh</a> <a class="el" href="classcugl_1_1_mesh.html">cugl::Mesh</a>&lt; T &gt;::sliceFrom </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>start</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns the slice of this mesh from the start index to the end.</p>
<p>The sliced mesh will use the indices from start to the end. It will include the vertices referenced by those indices, and only those vertices. The command will remain the same.</p>
<p>The only sliceable mesh types are GL_LINES and GL_TRIANGLES. That is because the mesh is represented in regular, decomposable chunks. Any attempt to slice another mesh type will fail.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">start</td><td>The start index</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the slice of this mesh between start and end. </dd></dl>

</div>
</div>
<a id="a28d8f41100f57c3f943d311e139cf526"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a28d8f41100f57c3f943d311e139cf526">&#9670;&nbsp;</a></span>sliceTo()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcugl_1_1_mesh.html">Mesh</a> <a class="el" href="classcugl_1_1_mesh.html">cugl::Mesh</a>&lt; T &gt;::sliceTo </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>end</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns the slice of this mesh from the begining to end.</p>
<p>The sliced mesh will use the indices up to (but not including) end. It will include the vertices referenced by those indices, and only those vertices. The command will remain the same.</p>
<p>The only sliceable mesh types are GL_LINES and GL_TRIANGLES. That is because the mesh is represented in regular, decomposable chunks. Any attempt to slice another mesh type will fail.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">end</td><td>The end index</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the slice of this mesh between start and end. </dd></dl>

</div>
</div>
<h2 class="groupheader">Member Data Documentation</h2>
<a id="a439820bedf2c38ce52cfa1817f36c80f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a439820bedf2c38ce52cfa1817f36c80f">&#9670;&nbsp;</a></span>command</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">GLenum <a class="el" href="classcugl_1_1_mesh.html">cugl::Mesh</a>&lt; T &gt;::command</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>The OpenGL drawing command </p>

</div>
</div>
<a id="a36f1b7bcf5e56d49be7af1cccec86b8b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a36f1b7bcf5e56d49be7af1cccec86b8b">&#9670;&nbsp;</a></span>indices</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;GLuint&gt; <a class="el" href="classcugl_1_1_mesh.html">cugl::Mesh</a>&lt; T &gt;::indices</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>The mesh indices, providing a shape to the vertices </p>

</div>
</div>
<a id="a460693ae62f12032d1f37f71fab31581"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a460693ae62f12032d1f37f71fab31581">&#9670;&nbsp;</a></span>vertices</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;T&gt; <a class="el" href="classcugl_1_1_mesh.html">cugl::Mesh</a>&lt; T &gt;::vertices</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>The mesh vertices, to be passed to the shader </p>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>include/cugl/render/<a class="el" href="_c_u_mesh_8h_source.html">CUMesh.h</a></li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.1
</small></address>
</body>
</html>
