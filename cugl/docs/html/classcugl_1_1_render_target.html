<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.9.1"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>CUGL 2.0: cugl::RenderTarget Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">CUGL 2.0
   </div>
   <div id="projectbrief">Cornell University Game Library</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.1 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search','.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespacecugl.html">cugl</a></li><li class="navelem"><a class="el" href="classcugl_1_1_render_target.html">RenderTarget</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-static-methods">Static Public Member Functions</a> &#124;
<a href="classcugl_1_1_render_target-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">cugl::RenderTarget Class Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p><code>#include &lt;<a class="el" href="_c_u_render_target_8h_source.html">CURenderTarget.h</a>&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a80429a5219fe3e403196b7b2f153ab15"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1_render_target.html#a80429a5219fe3e403196b7b2f153ab15">RenderTarget</a> ()</td></tr>
<tr class="separator:a80429a5219fe3e403196b7b2f153ab15"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a880f06efb36ddf64b24c2e9aa40a0c91"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1_render_target.html#a880f06efb36ddf64b24c2e9aa40a0c91">~RenderTarget</a> ()</td></tr>
<tr class="separator:a880f06efb36ddf64b24c2e9aa40a0c91"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a36126a399a6ccbb7565103633c4206f5"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1_render_target.html#a36126a399a6ccbb7565103633c4206f5">dispose</a> ()</td></tr>
<tr class="separator:a36126a399a6ccbb7565103633c4206f5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6e7b534f4ca90bbfae6fb7128cd9a9b6"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1_render_target.html#a6e7b534f4ca90bbfae6fb7128cd9a9b6">init</a> (int width, int height)</td></tr>
<tr class="separator:a6e7b534f4ca90bbfae6fb7128cd9a9b6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9dd38d1b28428b3c996ac7197fbc11c0"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1_render_target.html#a9dd38d1b28428b3c996ac7197fbc11c0">init</a> (int width, int height, size_t outputs)</td></tr>
<tr class="separator:a9dd38d1b28428b3c996ac7197fbc11c0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a808504902d31b7e312fa651c549326a5"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1_render_target.html#a808504902d31b7e312fa651c549326a5">init</a> (int width, int height, std::initializer_list&lt; <a class="el" href="classcugl_1_1_texture.html#ac9762e396811469c04413c1c604ea3cd">Texture::PixelFormat</a> &gt; outputs)</td></tr>
<tr class="separator:a808504902d31b7e312fa651c549326a5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abcbbbca9caf66ec96cc2e7dd645cf823"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1_render_target.html#abcbbbca9caf66ec96cc2e7dd645cf823">init</a> (int width, int height, std::vector&lt; <a class="el" href="classcugl_1_1_texture.html#ac9762e396811469c04413c1c604ea3cd">Texture::PixelFormat</a> &gt; outputs)</td></tr>
<tr class="separator:abcbbbca9caf66ec96cc2e7dd645cf823"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a30a87b7ddc0bcdf10ed94971ceefb431"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1_render_target.html#a30a87b7ddc0bcdf10ed94971ceefb431">init</a> (int width, int height, std::unordered_map&lt; GLuint, <a class="el" href="classcugl_1_1_texture.html#ac9762e396811469c04413c1c604ea3cd">Texture::PixelFormat</a> &gt; outputs)</td></tr>
<tr class="separator:a30a87b7ddc0bcdf10ed94971ceefb431"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abc83a50c3290e4f3c533477aeaffe64d"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1_render_target.html#abc83a50c3290e4f3c533477aeaffe64d">init</a> (int width, int height, <a class="el" href="classcugl_1_1_texture.html#ac9762e396811469c04413c1c604ea3cd">Texture::PixelFormat</a> *outputs, size_t outsize)</td></tr>
<tr class="separator:abc83a50c3290e4f3c533477aeaffe64d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4ff1b4188697b624f25baec97a4e4b4e"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1_render_target.html#a4ff1b4188697b624f25baec97a4e4b4e">getWidth</a> () const</td></tr>
<tr class="separator:a4ff1b4188697b624f25baec97a4e4b4e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a04ccb3cf7dd80ac42560bcbbdfeb9994"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1_render_target.html#a04ccb3cf7dd80ac42560bcbbdfeb9994">getHeight</a> () const</td></tr>
<tr class="separator:a04ccb3cf7dd80ac42560bcbbdfeb9994"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a318f1522f4ab7ade853f4bddeeaf5997"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classcugl_1_1_color4.html">Color4</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1_render_target.html#a318f1522f4ab7ade853f4bddeeaf5997">getClearColor</a> () const</td></tr>
<tr class="separator:a318f1522f4ab7ade853f4bddeeaf5997"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9b574b372e3bbaa4209824a8007988f9"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1_render_target.html#a9b574b372e3bbaa4209824a8007988f9">setClearColor</a> (const <a class="el" href="classcugl_1_1_color4.html">Color4</a> color)</td></tr>
<tr class="separator:a9b574b372e3bbaa4209824a8007988f9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab904c9703db11c4ba7810cf2b231709b"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1_render_target.html#ab904c9703db11c4ba7810cf2b231709b">getOutputSize</a> () const</td></tr>
<tr class="separator:ab904c9703db11c4ba7810cf2b231709b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a25885b21e25636a2894ee0cf9d2351f1"><td class="memItemLeft" align="right" valign="top">const std::shared_ptr&lt; <a class="el" href="classcugl_1_1_texture.html">Texture</a> &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1_render_target.html#a25885b21e25636a2894ee0cf9d2351f1">getTexture</a> (size_t index=0) const</td></tr>
<tr class="separator:a25885b21e25636a2894ee0cf9d2351f1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9c047b6e94ea5cde91ade30cce46e7d8"><td class="memItemLeft" align="right" valign="top">const std::shared_ptr&lt; <a class="el" href="classcugl_1_1_texture.html">Texture</a> &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1_render_target.html#a9c047b6e94ea5cde91ade30cce46e7d8">getDepthStencil</a> () const</td></tr>
<tr class="separator:a9c047b6e94ea5cde91ade30cce46e7d8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a95ff5e3fda9ce34ddcca0362b503385e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1_render_target.html#a95ff5e3fda9ce34ddcca0362b503385e">begin</a> ()</td></tr>
<tr class="separator:a95ff5e3fda9ce34ddcca0362b503385e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afe2bb9b6eff50d026ab7cd5c21da5dfd"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1_render_target.html#afe2bb9b6eff50d026ab7cd5c21da5dfd">end</a> ()</td></tr>
<tr class="separator:afe2bb9b6eff50d026ab7cd5c21da5dfd"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-static-methods"></a>
Static Public Member Functions</h2></td></tr>
<tr class="memitem:ab08d5ab385dec4e01199df09785c2cf2"><td class="memItemLeft" align="right" valign="top">static std::shared_ptr&lt; <a class="el" href="classcugl_1_1_render_target.html">RenderTarget</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1_render_target.html#ab08d5ab385dec4e01199df09785c2cf2">alloc</a> (int width, int height)</td></tr>
<tr class="separator:ab08d5ab385dec4e01199df09785c2cf2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aab50557199cb2ea183f9cc55483f1b55"><td class="memItemLeft" align="right" valign="top">static std::shared_ptr&lt; <a class="el" href="classcugl_1_1_render_target.html">RenderTarget</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1_render_target.html#aab50557199cb2ea183f9cc55483f1b55">alloc</a> (int width, int height, size_t outputs)</td></tr>
<tr class="separator:aab50557199cb2ea183f9cc55483f1b55"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a28ba10b6f3983d7744331cbed7596179"><td class="memItemLeft" align="right" valign="top">static std::shared_ptr&lt; <a class="el" href="classcugl_1_1_render_target.html">RenderTarget</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1_render_target.html#a28ba10b6f3983d7744331cbed7596179">alloc</a> (int width, int height, std::initializer_list&lt; <a class="el" href="classcugl_1_1_texture.html#ac9762e396811469c04413c1c604ea3cd">Texture::PixelFormat</a> &gt; outputs)</td></tr>
<tr class="separator:a28ba10b6f3983d7744331cbed7596179"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ace55b9afb9dac68858fc084257348af6"><td class="memItemLeft" align="right" valign="top">static std::shared_ptr&lt; <a class="el" href="classcugl_1_1_render_target.html">RenderTarget</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1_render_target.html#ace55b9afb9dac68858fc084257348af6">alloc</a> (int width, int height, std::vector&lt; <a class="el" href="classcugl_1_1_texture.html#ac9762e396811469c04413c1c604ea3cd">Texture::PixelFormat</a> &gt; outputs)</td></tr>
<tr class="separator:ace55b9afb9dac68858fc084257348af6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2ad8d0bb8084efdb2496781165aed29c"><td class="memItemLeft" align="right" valign="top">static std::shared_ptr&lt; <a class="el" href="classcugl_1_1_render_target.html">RenderTarget</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1_render_target.html#a2ad8d0bb8084efdb2496781165aed29c">alloc</a> (int width, int height, std::unordered_map&lt; GLuint, <a class="el" href="classcugl_1_1_texture.html#ac9762e396811469c04413c1c604ea3cd">Texture::PixelFormat</a> &gt; outputs)</td></tr>
<tr class="separator:a2ad8d0bb8084efdb2496781165aed29c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a87f22e9131ab5647377f0a9523d28254"><td class="memItemLeft" align="right" valign="top">static std::shared_ptr&lt; <a class="el" href="classcugl_1_1_render_target.html">RenderTarget</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1_render_target.html#a87f22e9131ab5647377f0a9523d28254">alloc</a> (int width, int height, <a class="el" href="classcugl_1_1_texture.html#ac9762e396811469c04413c1c604ea3cd">Texture::PixelFormat</a> *outputs, size_t outsize)</td></tr>
<tr class="separator:a87f22e9131ab5647377f0a9523d28254"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>This is a class representing an offscreen render target (framebuffer).</p>
<p>A render target allows the user to draw to a texture before drawing to a screen. This allows for the potential for post-processing effects. To draw to a render target simply call the <a class="el" href="classcugl_1_1_render_target.html#a95ff5e3fda9ce34ddcca0362b503385e">begin</a> method before drawing. From that point on all drawing commands will be sent to the associated texture instead of the screen. Call <a class="el" href="classcugl_1_1_render_target.html#afe2bb9b6eff50d026ab7cd5c21da5dfd">end</a> to resume drawing to the screen.</p>
<p>Render targets should not be stacked. It is not safe to call a begin/end pair of one render target inside of another begin/end pair. Control to the screen should be resumed before using another render target.</p>
<p>While render targets must have at least one output texture, they can support multiple textures as long as the active fragment shader has multiple output variables. The locations of these outputs should be set explicitly and sequentially with the layout keyword.</p>
<p>This class greatly simplifies OpenGL framebuffers at the cost of some flexibility. The only support for depth and stencil is a combined 24/8 depth and stencil buffer. In addition, output textures must have one of the simplified formats defined by <a class="el" href="classcugl_1_1_texture.html#ac9762e396811469c04413c1c604ea3cd">Texture::PixelFormat</a>. Finally, all output textures are bound sequentially to output locations 0..#outputs-1. However, we find that still allows us to handle the vast majority of applications with a framebuffer. </p>
</div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="a80429a5219fe3e403196b7b2f153ab15"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a80429a5219fe3e403196b7b2f153ab15">&#9670;&nbsp;</a></span>RenderTarget()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">cugl::RenderTarget::RenderTarget </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Creates an uninitialized render target with no output textures.</p>
<p>You must initialize the render target to create an output texture. </p>

</div>
</div>
<a id="a880f06efb36ddf64b24c2e9aa40a0c91"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a880f06efb36ddf64b24c2e9aa40a0c91">&#9670;&nbsp;</a></span>~RenderTarget()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">cugl::RenderTarget::~RenderTarget </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Deletes this render target, disposing all resources. </p>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="ab08d5ab385dec4e01199df09785c2cf2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab08d5ab385dec4e01199df09785c2cf2">&#9670;&nbsp;</a></span>alloc() <span class="overload">[1/6]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static std::shared_ptr&lt;<a class="el" href="classcugl_1_1_render_target.html">RenderTarget</a>&gt; cugl::RenderTarget::alloc </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>width</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>height</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns a new render target with a single RGBA output texture.</p>
<p>The output texture will have the given width and size.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">width</td><td>The drawing width of this render target <br  />
 </td></tr>
    <tr><td class="paramname">height</td><td>The drawing width of this render target <br  />
</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a new render target with a single RGBA output texture. </dd></dl>

</div>
</div>
<a id="aab50557199cb2ea183f9cc55483f1b55"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aab50557199cb2ea183f9cc55483f1b55">&#9670;&nbsp;</a></span>alloc() <span class="overload">[2/6]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static std::shared_ptr&lt;<a class="el" href="classcugl_1_1_render_target.html">RenderTarget</a>&gt; cugl::RenderTarget::alloc </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>width</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>height</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>outputs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns a new render target with multiple RGBA output textures.</p>
<p>The output textures will have the given width and size. They will be assigned locations 0..outputs-1. These locations should be bound with the layout keyword in any shader used with this render target. Otherwise the results are not well-defined.</p>
<p>If outputs is larger than the number of possible shader outputs for this platform, this method will fail. OpenGL only guarantees up to 8 output textures.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">width</td><td>The drawing width of this render target <br  />
 </td></tr>
    <tr><td class="paramname">height</td><td>The drawing width of this render target <br  />
 </td></tr>
    <tr><td class="paramname">outputs</td><td>The number of output textures</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a new render target with multiple RGBA output textures. </dd></dl>

</div>
</div>
<a id="a28ba10b6f3983d7744331cbed7596179"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a28ba10b6f3983d7744331cbed7596179">&#9670;&nbsp;</a></span>alloc() <span class="overload">[3/6]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static std::shared_ptr&lt;<a class="el" href="classcugl_1_1_render_target.html">RenderTarget</a>&gt; cugl::RenderTarget::alloc </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>width</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>height</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::initializer_list&lt; <a class="el" href="classcugl_1_1_texture.html#ac9762e396811469c04413c1c604ea3cd">Texture::PixelFormat</a> &gt;&#160;</td>
          <td class="paramname"><em>outputs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns a new render target with multiple textures of the given format.</p>
<p>The output textures will have the given width and size. They will be assigned the appropriate format as specified in <a class="el" href="classcugl_1_1_texture.html#a3fef5518341f65eae6a97dbfbabe6fb9">Texture#init</a>. <br  />
 They will be assigned locations 0..#outputs-1. These locations should be bound with the layout keyword in any shader used with this render target. Otherwise the results are not well-defined.</p>
<p>If the size of the outputs parameter is larger than the number of possible shader outputs for this platform, this method will fail. <br  />
 OpenGL only guarantees up to 8 output textures.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">width</td><td>The drawing width of this render target <br  />
 </td></tr>
    <tr><td class="paramname">height</td><td>The drawing width of this render target <br  />
 </td></tr>
    <tr><td class="paramname">outputs</td><td>The list of desired texture formats</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a new render target with multiple textures of the given format. </dd></dl>

</div>
</div>
<a id="a2ad8d0bb8084efdb2496781165aed29c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2ad8d0bb8084efdb2496781165aed29c">&#9670;&nbsp;</a></span>alloc() <span class="overload">[4/6]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static std::shared_ptr&lt;<a class="el" href="classcugl_1_1_render_target.html">RenderTarget</a>&gt; cugl::RenderTarget::alloc </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>width</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>height</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::unordered_map&lt; GLuint, <a class="el" href="classcugl_1_1_texture.html#ac9762e396811469c04413c1c604ea3cd">Texture::PixelFormat</a> &gt;&#160;</td>
          <td class="paramname"><em>outputs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns a new render target with multiple textures of the given format.</p>
<p>The output textures will have the given width and size. They will be assigned the appropriate format as specified in <a class="el" href="classcugl_1_1_texture.html#a3fef5518341f65eae6a97dbfbabe6fb9">Texture#init</a>. They will be assigned locations matching the keys of the map outputs. These locations should be bound with the layout keyword in any shader used with this render target. Otherwise the results are not well-defined.</p>
<p>If the size of the outputs parameter is larger than the number of possible shader outputs for this platform, this method will fail. OpenGL only guarantees up to 8 output textures.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">width</td><td>The drawing width of this render target </td></tr>
    <tr><td class="paramname">height</td><td>The drawing width of this render target </td></tr>
    <tr><td class="paramname">outputs</td><td>The map of desired texture formats for each location</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a new render target with multiple textures of the given format. </dd></dl>

</div>
</div>
<a id="ace55b9afb9dac68858fc084257348af6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ace55b9afb9dac68858fc084257348af6">&#9670;&nbsp;</a></span>alloc() <span class="overload">[5/6]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static std::shared_ptr&lt;<a class="el" href="classcugl_1_1_render_target.html">RenderTarget</a>&gt; cugl::RenderTarget::alloc </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>width</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>height</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; <a class="el" href="classcugl_1_1_texture.html#ac9762e396811469c04413c1c604ea3cd">Texture::PixelFormat</a> &gt;&#160;</td>
          <td class="paramname"><em>outputs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns a new render target with multiple textures of the given format.</p>
<p>The output textures will have the given width and size. They will be assigned the appropriate format as specified in <a class="el" href="classcugl_1_1_texture.html#a3fef5518341f65eae6a97dbfbabe6fb9">Texture#init</a>. <br  />
 They will be assigned locations 0..#outputs-1. These locations should be bound with the layout keyword in any shader used with this render target. Otherwise the results are not well-defined.</p>
<p>If the size of the outputs parameter is larger than the number of possible shader outputs for this platform, this method will fail. <br  />
 OpenGL only guarantees up to 8 output textures.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">width</td><td>The drawing width of this render target <br  />
 </td></tr>
    <tr><td class="paramname">height</td><td>The drawing width of this render target <br  />
 </td></tr>
    <tr><td class="paramname">outputs</td><td>The list of desired texture formats</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a new render target with multiple textures of the given format. </dd></dl>

</div>
</div>
<a id="a87f22e9131ab5647377f0a9523d28254"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a87f22e9131ab5647377f0a9523d28254">&#9670;&nbsp;</a></span>alloc() <span class="overload">[6/6]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static std::shared_ptr&lt;<a class="el" href="classcugl_1_1_render_target.html">RenderTarget</a>&gt; cugl::RenderTarget::alloc </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>width</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>height</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classcugl_1_1_texture.html#ac9762e396811469c04413c1c604ea3cd">Texture::PixelFormat</a> *&#160;</td>
          <td class="paramname"><em>outputs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>outsize</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns a new render target with multiple textures of the given format.</p>
<p>The output textures will have the given width and size. They will be assigned the appropriate format as specified in <a class="el" href="classcugl_1_1_texture.html#a3fef5518341f65eae6a97dbfbabe6fb9">Texture#init</a>. <br  />
 They will be assigned locations 0..#outsize-1. These locations should be bound with the layout keyword in any shader used with this render target. Otherwise the results are not well-defined.</p>
<p>If the size of the outputs parameter is larger than the number of possible shader outputs for this platform, this method will fail. <br  />
 OpenGL only guarantees up to 8 output textures.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">width</td><td>The drawing width of this render target <br  />
 </td></tr>
    <tr><td class="paramname">height</td><td>The drawing width of this render target <br  />
 </td></tr>
    <tr><td class="paramname">outputs</td><td>The list of desired texture formats </td></tr>
    <tr><td class="paramname">outsize</td><td>The number of elements in outputs</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a new render target with multiple textures of the given format. </dd></dl>

</div>
</div>
<a id="a95ff5e3fda9ce34ddcca0362b503385e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a95ff5e3fda9ce34ddcca0362b503385e">&#9670;&nbsp;</a></span>begin()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void cugl::RenderTarget::begin </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Begins sending draw commands to this render target.</p>
<p>This method clears all of the output textures with the clear color of this render target. It also sets the viewpoint to match the size of this render target (which may not be the same as the screen). The old viewport is saved and will be restored when <a class="el" href="classcugl_1_1_render_target.html#afe2bb9b6eff50d026ab7cd5c21da5dfd">end</a> is called.</p>
<p>It is NOT safe to call a begin/end pair of a render target inside of another render target. Render targets do not keep a stack. They alway return control to the default render target (the screen) when done. </p>

</div>
</div>
<a id="a36126a399a6ccbb7565103633c4206f5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a36126a399a6ccbb7565103633c4206f5">&#9670;&nbsp;</a></span>dispose()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void cugl::RenderTarget::dispose </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Deletes the render target and resets all attributes.</p>
<p>You must reinitialize the render target to use it. </p>

</div>
</div>
<a id="afe2bb9b6eff50d026ab7cd5c21da5dfd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afe2bb9b6eff50d026ab7cd5c21da5dfd">&#9670;&nbsp;</a></span>end()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void cugl::RenderTarget::end </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Stops sendinging draw commands to this render target.</p>
<p>When this method is called, the original viewport will be restored. Future draw commands will be sent directly to the screen.</p>
<p>It is NOT safe to call a begin/end pair of a render target inside of another render target. Render targets do not keep a stack. They alway return control to the default render target (the screen) when done. </p>

</div>
</div>
<a id="a318f1522f4ab7ade853f4bddeeaf5997"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a318f1522f4ab7ade853f4bddeeaf5997">&#9670;&nbsp;</a></span>getClearColor()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcugl_1_1_color4.html">Color4</a> cugl::RenderTarget::getClearColor </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns the clear color for this render target.</p>
<p>The clear color is used to clear the texture when the method <a class="el" href="classcugl_1_1_render_target.html#a95ff5e3fda9ce34ddcca0362b503385e">begin</a> is called.</p>
<dl class="section return"><dt>Returns</dt><dd>the clear color for this render target. </dd></dl>

</div>
</div>
<a id="a9c047b6e94ea5cde91ade30cce46e7d8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9c047b6e94ea5cde91ade30cce46e7d8">&#9670;&nbsp;</a></span>getDepthStencil()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const std::shared_ptr&lt;<a class="el" href="classcugl_1_1_texture.html">Texture</a>&gt;&amp; cugl::RenderTarget::getDepthStencil </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns the depth/stencil buffer for this render target</p>
<p>The framebuffer for a render target always uses a combined depth and stencil buffer. It uses 24 bits for the depth and 8 bits for the stencil. This should be sufficient in most applications.</p>
<dl class="section return"><dt>Returns</dt><dd>the depth/stencil buffer for this render target </dd></dl>

</div>
</div>
<a id="a04ccb3cf7dd80ac42560bcbbdfeb9994"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a04ccb3cf7dd80ac42560bcbbdfeb9994">&#9670;&nbsp;</a></span>getHeight()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int cugl::RenderTarget::getHeight </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns the height of this render target</p>
<dl class="section return"><dt>Returns</dt><dd>the height of this render target </dd></dl>

</div>
</div>
<a id="ab904c9703db11c4ba7810cf2b231709b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab904c9703db11c4ba7810cf2b231709b">&#9670;&nbsp;</a></span>getOutputSize()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_t cugl::RenderTarget::getOutputSize </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns the number of output textures for this render target.</p>
<p>If the render target has been successfully initialized, this value is guaranteed to be at least 1.</p>
<dl class="section return"><dt>Returns</dt><dd>the number of output textures for this render target. </dd></dl>

</div>
</div>
<a id="a25885b21e25636a2894ee0cf9d2351f1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a25885b21e25636a2894ee0cf9d2351f1">&#9670;&nbsp;</a></span>getTexture()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const std::shared_ptr&lt;<a class="el" href="classcugl_1_1_texture.html">Texture</a>&gt;&amp; cugl::RenderTarget::getTexture </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>index</em> = <code>0</code></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns the output texture for the given index.</p>
<p>The index should be a value between 0..OutputSize-1. By default it is 0, the primary output texture.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">index</td><td>The output index</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the output texture for the given index. </dd></dl>

</div>
</div>
<a id="a4ff1b4188697b624f25baec97a4e4b4e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4ff1b4188697b624f25baec97a4e4b4e">&#9670;&nbsp;</a></span>getWidth()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int cugl::RenderTarget::getWidth </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns the width of this render target</p>
<dl class="section return"><dt>Returns</dt><dd>the width of this render target </dd></dl>

</div>
</div>
<a id="a6e7b534f4ca90bbfae6fb7128cd9a9b6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6e7b534f4ca90bbfae6fb7128cd9a9b6">&#9670;&nbsp;</a></span>init() <span class="overload">[1/6]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool cugl::RenderTarget::init </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>width</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>height</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Initializes this target with a single RGBA output texture.</p>
<p>The output texture will have the given width and size.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">width</td><td>The drawing width of this render target <br  />
 </td></tr>
    <tr><td class="paramname">height</td><td>The drawing width of this render target <br  />
</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if initialization was successful. </dd></dl>

</div>
</div>
<a id="a9dd38d1b28428b3c996ac7197fbc11c0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9dd38d1b28428b3c996ac7197fbc11c0">&#9670;&nbsp;</a></span>init() <span class="overload">[2/6]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool cugl::RenderTarget::init </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>width</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>height</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>outputs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Initializes this target with multiple RGBA output textures.</p>
<p>The output textures will have the given width and size. They will be assigned locations 0..outputs-1. These locations should be bound with the layout keyword in any shader used with this render target. Otherwise the results are not well-defined.</p>
<p>If outputs is larger than the number of possible shader outputs for this platform, this method will fail. OpenGL only guarantees up to 8 output textures.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">width</td><td>The drawing width of this render target <br  />
 </td></tr>
    <tr><td class="paramname">height</td><td>The drawing width of this render target <br  />
 </td></tr>
    <tr><td class="paramname">outputs</td><td>The number of output textures</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if initialization was successful. </dd></dl>

</div>
</div>
<a id="a808504902d31b7e312fa651c549326a5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a808504902d31b7e312fa651c549326a5">&#9670;&nbsp;</a></span>init() <span class="overload">[3/6]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool cugl::RenderTarget::init </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>width</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>height</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::initializer_list&lt; <a class="el" href="classcugl_1_1_texture.html#ac9762e396811469c04413c1c604ea3cd">Texture::PixelFormat</a> &gt;&#160;</td>
          <td class="paramname"><em>outputs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Initializes this target with multiple textures of the given format.</p>
<p>The output textures will have the given width and size. They will be assigned the appropriate format as specified in <a class="el" href="classcugl_1_1_texture.html#a3fef5518341f65eae6a97dbfbabe6fb9">Texture#init</a>. <br  />
 They will be assigned locations 0..#outputs-1. These locations should be bound with the layout keyword in any shader used with this render target. Otherwise the results are not well-defined.</p>
<p>If the size of the outputs parameter is larger than the number of possible shader outputs for this platform, this method will fail. <br  />
 OpenGL only guarantees up to 8 output textures.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">width</td><td>The drawing width of this render target <br  />
 </td></tr>
    <tr><td class="paramname">height</td><td>The drawing width of this render target <br  />
 </td></tr>
    <tr><td class="paramname">outputs</td><td>The list of desired texture formats</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if initialization was successful. </dd></dl>

</div>
</div>
<a id="a30a87b7ddc0bcdf10ed94971ceefb431"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a30a87b7ddc0bcdf10ed94971ceefb431">&#9670;&nbsp;</a></span>init() <span class="overload">[4/6]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool cugl::RenderTarget::init </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>width</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>height</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::unordered_map&lt; GLuint, <a class="el" href="classcugl_1_1_texture.html#ac9762e396811469c04413c1c604ea3cd">Texture::PixelFormat</a> &gt;&#160;</td>
          <td class="paramname"><em>outputs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Initializes this target with multiple textures of the given format.</p>
<p>The output textures will have the given width and size. They will be assigned the appropriate format as specified in <a class="el" href="classcugl_1_1_texture.html#a3fef5518341f65eae6a97dbfbabe6fb9">Texture#init</a>. They will be assigned locations matching the keys of the map outputs. These locations should be bound with the layout keyword in any shader used with this render target. Otherwise the results are not well-defined.</p>
<p>If the size of the outputs parameter is larger than the number of possible shader outputs for this platform, this method will fail. OpenGL only guarantees up to 8 output textures.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">width</td><td>The drawing width of this render target </td></tr>
    <tr><td class="paramname">height</td><td>The drawing width of this render target </td></tr>
    <tr><td class="paramname">outputs</td><td>The map of desired texture formats for each location</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if initialization was successful. </dd></dl>

</div>
</div>
<a id="abcbbbca9caf66ec96cc2e7dd645cf823"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abcbbbca9caf66ec96cc2e7dd645cf823">&#9670;&nbsp;</a></span>init() <span class="overload">[5/6]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool cugl::RenderTarget::init </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>width</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>height</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; <a class="el" href="classcugl_1_1_texture.html#ac9762e396811469c04413c1c604ea3cd">Texture::PixelFormat</a> &gt;&#160;</td>
          <td class="paramname"><em>outputs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Initializes this shader with multiple textures of the given format.</p>
<p>The output textures will have the given width and size. They will be assigned the appropriate format as specified in <a class="el" href="classcugl_1_1_texture.html#a3fef5518341f65eae6a97dbfbabe6fb9">Texture#init</a>. <br  />
 They will be assigned locations 0..#outputs-1. These locations should be bound with the layout keyword in any shader used with this render target. Otherwise the results are not well-defined.</p>
<p>If the size of the outputs parameter is larger than the number of possible shader outputs for this platform, this method will fail. <br  />
 OpenGL only guarantees up to 8 output textures.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">width</td><td>The drawing width of this render target <br  />
 </td></tr>
    <tr><td class="paramname">height</td><td>The drawing width of this render target <br  />
 </td></tr>
    <tr><td class="paramname">outputs</td><td>The list of desired texture formats</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if initialization was successful. </dd></dl>

</div>
</div>
<a id="abc83a50c3290e4f3c533477aeaffe64d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abc83a50c3290e4f3c533477aeaffe64d">&#9670;&nbsp;</a></span>init() <span class="overload">[6/6]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool cugl::RenderTarget::init </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>width</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>height</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classcugl_1_1_texture.html#ac9762e396811469c04413c1c604ea3cd">Texture::PixelFormat</a> *&#160;</td>
          <td class="paramname"><em>outputs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>outsize</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Initializes this target with multiple textures of the given format.</p>
<p>The output textures will have the given width and size. They will be assigned the appropriate format as specified in <a class="el" href="classcugl_1_1_texture.html#a3fef5518341f65eae6a97dbfbabe6fb9">Texture#init</a>. <br  />
 They will be assigned locations 0..#outsize-1. These locations should be bound with the layout keyword in any shader used with this render target. Otherwise the results are not well-defined.</p>
<p>If the size of the outputs parameter is larger than the number of possible shader outputs for this platform, this method will fail. <br  />
 OpenGL only guarantees up to 8 output textures.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">width</td><td>The drawing width of this render target <br  />
 </td></tr>
    <tr><td class="paramname">height</td><td>The drawing width of this render target <br  />
 </td></tr>
    <tr><td class="paramname">outputs</td><td>The list of desired texture formats </td></tr>
    <tr><td class="paramname">outsize</td><td>The number of elements in outputs</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if initialization was successful. </dd></dl>

</div>
</div>
<a id="a9b574b372e3bbaa4209824a8007988f9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9b574b372e3bbaa4209824a8007988f9">&#9670;&nbsp;</a></span>setClearColor()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void cugl::RenderTarget::setClearColor </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classcugl_1_1_color4.html">Color4</a>&#160;</td>
          <td class="paramname"><em>color</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Sets the clear color for this render target.</p>
<p>The clear color is used to clear the texture when the method <a class="el" href="classcugl_1_1_render_target.html#a95ff5e3fda9ce34ddcca0362b503385e">begin</a> is called.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">color</td><td>The clear color for this render target. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>include/cugl/render/<a class="el" href="_c_u_render_target_8h_source.html">CURenderTarget.h</a></li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.1
</small></address>
</body>
</html>
