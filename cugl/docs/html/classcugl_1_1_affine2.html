<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.9.1"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>CUGL 2.0: cugl::Affine2 Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">CUGL 2.0
   </div>
   <div id="projectbrief">Cornell University Game Library</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.1 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search','.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespacecugl.html">cugl</a></li><li class="navelem"><a class="el" href="classcugl_1_1_affine2.html">Affine2</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-static-methods">Static Public Member Functions</a> &#124;
<a href="#pub-attribs">Public Attributes</a> &#124;
<a href="#pub-static-attribs">Static Public Attributes</a> &#124;
<a href="classcugl_1_1_affine2-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">cugl::Affine2 Class Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p><code>#include &lt;<a class="el" href="_c_u_affine2_8h_source.html">CUAffine2.h</a>&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a4b8cdc57a2fefbe3b701bd13b1b9c8c3"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1_affine2.html#a4b8cdc57a2fefbe3b701bd13b1b9c8c3">Affine2</a> ()</td></tr>
<tr class="separator:a4b8cdc57a2fefbe3b701bd13b1b9c8c3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aab97798b85f16c036eea8f5902f64853"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1_affine2.html#aab97798b85f16c036eea8f5902f64853">Affine2</a> (float m11, float m12, float m21, float m22, float tx, float ty)</td></tr>
<tr class="separator:aab97798b85f16c036eea8f5902f64853"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adec4e6f35e898ccd5846066e25eb0d38"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1_affine2.html#adec4e6f35e898ccd5846066e25eb0d38">Affine2</a> (const float *mat)</td></tr>
<tr class="separator:adec4e6f35e898ccd5846066e25eb0d38"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0f2a28b046f97e022fd688d0850179e7"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1_affine2.html#a0f2a28b046f97e022fd688d0850179e7">Affine2</a> (const <a class="el" href="classcugl_1_1_affine2.html">Affine2</a> &amp;copy)</td></tr>
<tr class="separator:a0f2a28b046f97e022fd688d0850179e7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a641ade00a492018865a14b382afc870d"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1_affine2.html#a641ade00a492018865a14b382afc870d">Affine2</a> (<a class="el" href="classcugl_1_1_affine2.html">Affine2</a> &amp;&amp;copy)</td></tr>
<tr class="separator:a641ade00a492018865a14b382afc870d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a25af9673fe7343a4989130f2227fabf7"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1_affine2.html#a25af9673fe7343a4989130f2227fabf7">~Affine2</a> ()</td></tr>
<tr class="separator:a25af9673fe7343a4989130f2227fabf7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:accc78fab6e7925504813d05d8133b35b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classcugl_1_1_affine2.html">Affine2</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1_affine2.html#accc78fab6e7925504813d05d8133b35b">operator=</a> (const <a class="el" href="classcugl_1_1_affine2.html">Affine2</a> &amp;mat)</td></tr>
<tr class="separator:accc78fab6e7925504813d05d8133b35b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6488ba992de5a72c48523724cb1f30d9"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classcugl_1_1_affine2.html">Affine2</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1_affine2.html#a6488ba992de5a72c48523724cb1f30d9">operator=</a> (<a class="el" href="classcugl_1_1_affine2.html">Affine2</a> &amp;&amp;mat)</td></tr>
<tr class="separator:a6488ba992de5a72c48523724cb1f30d9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab8d463f5418645f7b54ae1ea46951e95"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classcugl_1_1_affine2.html">Affine2</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1_affine2.html#ab8d463f5418645f7b54ae1ea46951e95">operator=</a> (const float *array)</td></tr>
<tr class="separator:ab8d463f5418645f7b54ae1ea46951e95"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afccaf334303ae3e95b208b9af65d328e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classcugl_1_1_affine2.html">Affine2</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1_affine2.html#afccaf334303ae3e95b208b9af65d328e">set</a> (float m11, float m12, float m21, float m22, float tx, float ty)</td></tr>
<tr class="separator:afccaf334303ae3e95b208b9af65d328e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af278299eff6733d7c28199aca350fc3e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classcugl_1_1_affine2.html">Affine2</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1_affine2.html#af278299eff6733d7c28199aca350fc3e">set</a> (const float *mat)</td></tr>
<tr class="separator:af278299eff6733d7c28199aca350fc3e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aae626e2a19203d00e66c8df7c3336c57"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classcugl_1_1_affine2.html">Affine2</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1_affine2.html#aae626e2a19203d00e66c8df7c3336c57">set</a> (const float *mat, size_t stride)</td></tr>
<tr class="separator:aae626e2a19203d00e66c8df7c3336c57"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:add02033567fa0f676563557c689e5039"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classcugl_1_1_affine2.html">Affine2</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1_affine2.html#add02033567fa0f676563557c689e5039">set</a> (const <a class="el" href="classcugl_1_1_affine2.html">Affine2</a> &amp;mat)</td></tr>
<tr class="separator:add02033567fa0f676563557c689e5039"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acd01e54686c9af28b75ccd200cfd3dd3"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classcugl_1_1_affine2.html">Affine2</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1_affine2.html#acd01e54686c9af28b75ccd200cfd3dd3">setIdentity</a> ()</td></tr>
<tr class="separator:acd01e54686c9af28b75ccd200cfd3dd3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adc6f551ca7edcaecaad777b2811d7c82"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classcugl_1_1_affine2.html">Affine2</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1_affine2.html#adc6f551ca7edcaecaad777b2811d7c82">setZero</a> ()</td></tr>
<tr class="separator:adc6f551ca7edcaecaad777b2811d7c82"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab7eae08e33c85e4e430a68cdea59de99"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classcugl_1_1_affine2.html">Affine2</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1_affine2.html#ab7eae08e33c85e4e430a68cdea59de99">multiply</a> (const <a class="el" href="classcugl_1_1_mat4.html">Mat4</a> &amp;m1, const <a class="el" href="classcugl_1_1_affine2.html">Affine2</a> &amp;m2, <a class="el" href="classcugl_1_1_affine2.html">Affine2</a> *dst)</td></tr>
<tr class="separator:ab7eae08e33c85e4e430a68cdea59de99"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9215cec637f03573a4e0f830a1861d55"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classcugl_1_1_affine2.html">Affine2</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1_affine2.html#a9215cec637f03573a4e0f830a1861d55">add</a> (const <a class="el" href="classcugl_1_1_vec2.html">Vec2</a> v)</td></tr>
<tr class="separator:a9215cec637f03573a4e0f830a1861d55"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2613d3591e583e73e1c0c611b44f11b7"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classcugl_1_1_affine2.html">Affine2</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1_affine2.html#a2613d3591e583e73e1c0c611b44f11b7">subtract</a> (const <a class="el" href="classcugl_1_1_vec2.html">Vec2</a> v)</td></tr>
<tr class="separator:a2613d3591e583e73e1c0c611b44f11b7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a52d6387f69944fb7fcd76f2f11ec8ccb"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classcugl_1_1_affine2.html">Affine2</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1_affine2.html#a52d6387f69944fb7fcd76f2f11ec8ccb">multiply</a> (float scalar)</td></tr>
<tr class="separator:a52d6387f69944fb7fcd76f2f11ec8ccb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab6dfc881e0e6937b67588cdf5f16f7c3"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classcugl_1_1_affine2.html">Affine2</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1_affine2.html#ab6dfc881e0e6937b67588cdf5f16f7c3">multiply</a> (const <a class="el" href="classcugl_1_1_affine2.html">Affine2</a> &amp;aff)</td></tr>
<tr class="separator:ab6dfc881e0e6937b67588cdf5f16f7c3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5ea3d783a93cc9880a3e4c8862b49de3"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classcugl_1_1_affine2.html">Affine2</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1_affine2.html#a5ea3d783a93cc9880a3e4c8862b49de3">multiply</a> (const <a class="el" href="classcugl_1_1_mat4.html">Mat4</a> &amp;mat)</td></tr>
<tr class="separator:a5ea3d783a93cc9880a3e4c8862b49de3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8fc06d785c74d017b9816e35dbacd615"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classcugl_1_1_affine2.html">Affine2</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1_affine2.html#a8fc06d785c74d017b9816e35dbacd615">invert</a> ()</td></tr>
<tr class="separator:a8fc06d785c74d017b9816e35dbacd615"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a001b233ab6d35f2181054ac123538af7"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classcugl_1_1_affine2.html">Affine2</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1_affine2.html#a001b233ab6d35f2181054ac123538af7">getInverse</a> () const</td></tr>
<tr class="separator:a001b233ab6d35f2181054ac123538af7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aad621777355d0c7a3e3b910a4bda89f9"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classcugl_1_1_affine2.html">Affine2</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1_affine2.html#aad621777355d0c7a3e3b910a4bda89f9">operator+=</a> (const <a class="el" href="classcugl_1_1_vec2.html">Vec2</a> v)</td></tr>
<tr class="separator:aad621777355d0c7a3e3b910a4bda89f9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaf0d8d25e81f4cbd9c01d9e5273846ca"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classcugl_1_1_affine2.html">Affine2</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1_affine2.html#aaf0d8d25e81f4cbd9c01d9e5273846ca">operator-=</a> (const <a class="el" href="classcugl_1_1_vec2.html">Vec2</a> v)</td></tr>
<tr class="separator:aaf0d8d25e81f4cbd9c01d9e5273846ca"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1dbc0227e613c4aeab18712a5bafda68"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classcugl_1_1_affine2.html">Affine2</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1_affine2.html#a1dbc0227e613c4aeab18712a5bafda68">operator*=</a> (float scalar)</td></tr>
<tr class="separator:a1dbc0227e613c4aeab18712a5bafda68"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a64bb5aa402b8338aa6d9966b664ab400"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classcugl_1_1_affine2.html">Affine2</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1_affine2.html#a64bb5aa402b8338aa6d9966b664ab400">operator*=</a> (const <a class="el" href="classcugl_1_1_mat4.html">Mat4</a> &amp;mat)</td></tr>
<tr class="separator:a64bb5aa402b8338aa6d9966b664ab400"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a44980076db2f8ce759ed8faa8e3cd765"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classcugl_1_1_affine2.html">Affine2</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1_affine2.html#a44980076db2f8ce759ed8faa8e3cd765">operator*=</a> (const <a class="el" href="classcugl_1_1_affine2.html">Affine2</a> &amp;aff)</td></tr>
<tr class="separator:a44980076db2f8ce759ed8faa8e3cd765"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4020ac8bf42d53bc503a45c9fbc6a717"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classcugl_1_1_affine2.html">Affine2</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1_affine2.html#a4020ac8bf42d53bc503a45c9fbc6a717">operator+</a> (const <a class="el" href="classcugl_1_1_vec2.html">Vec2</a> v) const</td></tr>
<tr class="separator:a4020ac8bf42d53bc503a45c9fbc6a717"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a753a56b81197c3794dd5553a3c0bf7ec"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classcugl_1_1_affine2.html">Affine2</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1_affine2.html#a753a56b81197c3794dd5553a3c0bf7ec">operator-</a> (const <a class="el" href="classcugl_1_1_vec2.html">Vec2</a> v) const</td></tr>
<tr class="separator:a753a56b81197c3794dd5553a3c0bf7ec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ada987a7773358e1321469499656e0d1e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classcugl_1_1_affine2.html">Affine2</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1_affine2.html#ada987a7773358e1321469499656e0d1e">operator*</a> (float scalar) const</td></tr>
<tr class="separator:ada987a7773358e1321469499656e0d1e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7869daac19f7de0963016bae9ffa3a59"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classcugl_1_1_affine2.html">Affine2</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1_affine2.html#a7869daac19f7de0963016bae9ffa3a59">operator*</a> (const <a class="el" href="classcugl_1_1_affine2.html">Affine2</a> &amp;aff) const</td></tr>
<tr class="separator:a7869daac19f7de0963016bae9ffa3a59"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a24bc1c1b2f17b7b82b8c79d01f20ef29"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classcugl_1_1_affine2.html">Affine2</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1_affine2.html#a24bc1c1b2f17b7b82b8c79d01f20ef29">operator*</a> (const <a class="el" href="classcugl_1_1_mat4.html">Mat4</a> &amp;mat) const</td></tr>
<tr class="separator:a24bc1c1b2f17b7b82b8c79d01f20ef29"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9710c87a601a6be0149bfb1a4e85b94c"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1_affine2.html#a9710c87a601a6be0149bfb1a4e85b94c">isExactly</a> (const <a class="el" href="classcugl_1_1_affine2.html">Affine2</a> &amp;aff) const</td></tr>
<tr class="separator:a9710c87a601a6be0149bfb1a4e85b94c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaf76247f97dc414a384c0f808c83871d"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1_affine2.html#aaf76247f97dc414a384c0f808c83871d">equals</a> (const <a class="el" href="classcugl_1_1_affine2.html">Affine2</a> &amp;mat, float variance=5.0e-4f) const</td></tr>
<tr class="separator:aaf76247f97dc414a384c0f808c83871d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0ebf099ed716e529492d20c371f8557a"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1_affine2.html#a0ebf099ed716e529492d20c371f8557a">operator==</a> (const <a class="el" href="classcugl_1_1_affine2.html">Affine2</a> &amp;aff) const</td></tr>
<tr class="separator:a0ebf099ed716e529492d20c371f8557a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aba3614aa9022ed81852094c03f5fec09"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1_affine2.html#aba3614aa9022ed81852094c03f5fec09">operator!=</a> (const <a class="el" href="classcugl_1_1_affine2.html">Affine2</a> &amp;aff) const</td></tr>
<tr class="separator:aba3614aa9022ed81852094c03f5fec09"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aedfc45c899f4dd8b57a20ea93b831b7f"><td class="memItemLeft" align="right" valign="top">float *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1_affine2.html#aedfc45c899f4dd8b57a20ea93b831b7f">get3x3</a> (float *array) const</td></tr>
<tr class="separator:aedfc45c899f4dd8b57a20ea93b831b7f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5a6bc0904428703fb031f1247fdfcc75"><td class="memItemLeft" align="right" valign="top">float *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1_affine2.html#a5a6bc0904428703fb031f1247fdfcc75">get3x4</a> (float *array) const</td></tr>
<tr class="separator:a5a6bc0904428703fb031f1247fdfcc75"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a612dabb8d4ae8b740e9998865c649fa2"><td class="memItemLeft" align="right" valign="top">float *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1_affine2.html#a612dabb8d4ae8b740e9998865c649fa2">get4x4</a> (float *array) const</td></tr>
<tr class="separator:a612dabb8d4ae8b740e9998865c649fa2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab8c8be050ee86cff21c2b31111c869b7"><td class="memItemLeft" align="right" valign="top">float *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1_affine2.html#ab8c8be050ee86cff21c2b31111c869b7">get</a> (float *array, size_t stride=2) const</td></tr>
<tr class="separator:ab8c8be050ee86cff21c2b31111c869b7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5cfc7ef754d3013679c6cf1ead3cb0b3"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1_affine2.html#a5cfc7ef754d3013679c6cf1ead3cb0b3">isIdentity</a> (float variance=0.0f) const</td></tr>
<tr class="separator:a5cfc7ef754d3013679c6cf1ead3cb0b3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab2321a2922cb78013afd101024b98722"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1_affine2.html#ab2321a2922cb78013afd101024b98722">isInvertible</a> (float variance=5.0e-4f) const</td></tr>
<tr class="separator:ab2321a2922cb78013afd101024b98722"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad5d9b6afcc292a35452772276080efb9"><td class="memItemLeft" align="right" valign="top">float&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1_affine2.html#ad5d9b6afcc292a35452772276080efb9">getDeterminant</a> () const</td></tr>
<tr class="separator:ad5d9b6afcc292a35452772276080efb9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4f38c74b7a7573b39bca73f7a942853f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classcugl_1_1_vec2.html">Vec2</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1_affine2.html#a4f38c74b7a7573b39bca73f7a942853f">getScale</a> () const</td></tr>
<tr class="separator:a4f38c74b7a7573b39bca73f7a942853f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9eaa2069732861bf2aa33f9b0c76d4f5"><td class="memItemLeft" align="right" valign="top">float&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1_affine2.html#a9eaa2069732861bf2aa33f9b0c76d4f5">getRotation</a> () const</td></tr>
<tr class="separator:a9eaa2069732861bf2aa33f9b0c76d4f5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aefc41b27c94bb910db443f7384e90a28"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classcugl_1_1_vec2.html">Vec2</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1_affine2.html#aefc41b27c94bb910db443f7384e90a28">getTranslation</a> () const</td></tr>
<tr class="separator:aefc41b27c94bb910db443f7384e90a28"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8d25a863f515dca681cd2ebaf417b4da"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classcugl_1_1_vec2.html">Vec2</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1_affine2.html#a8d25a863f515dca681cd2ebaf417b4da">transform</a> (const <a class="el" href="classcugl_1_1_vec2.html">Vec2</a> point) const</td></tr>
<tr class="separator:a8d25a863f515dca681cd2ebaf417b4da"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2539597763eb5761ff8b1d00e484bef3"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classcugl_1_1_rect.html">Rect</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1_affine2.html#a2539597763eb5761ff8b1d00e484bef3">transform</a> (const <a class="el" href="classcugl_1_1_rect.html">Rect</a> rect) const</td></tr>
<tr class="separator:a2539597763eb5761ff8b1d00e484bef3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9023ae447cea2fd1c1d3db512f6ea437"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classcugl_1_1_affine2.html">Affine2</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1_affine2.html#a9023ae447cea2fd1c1d3db512f6ea437">rotate</a> (float angle)</td></tr>
<tr class="separator:a9023ae447cea2fd1c1d3db512f6ea437"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6174a8cc971ac1ddddb4f83be35f7328"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classcugl_1_1_affine2.html">Affine2</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1_affine2.html#a6174a8cc971ac1ddddb4f83be35f7328">scale</a> (float value)</td></tr>
<tr class="separator:a6174a8cc971ac1ddddb4f83be35f7328"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5581e28d0d48e522f10b902f803c6960"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classcugl_1_1_affine2.html">Affine2</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1_affine2.html#a5581e28d0d48e522f10b902f803c6960">scale</a> (const <a class="el" href="classcugl_1_1_vec2.html">Vec2</a> s)</td></tr>
<tr class="separator:a5581e28d0d48e522f10b902f803c6960"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9bc0c20b4ee6f8ca381dcd51a82d0f5c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classcugl_1_1_affine2.html">Affine2</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1_affine2.html#a9bc0c20b4ee6f8ca381dcd51a82d0f5c">scale</a> (float sx, float sy)</td></tr>
<tr class="separator:a9bc0c20b4ee6f8ca381dcd51a82d0f5c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acf48b7d1a8042f09d627b8ed03c253ae"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classcugl_1_1_affine2.html">Affine2</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1_affine2.html#acf48b7d1a8042f09d627b8ed03c253ae">translate</a> (const <a class="el" href="classcugl_1_1_vec2.html">Vec2</a> t)</td></tr>
<tr class="separator:acf48b7d1a8042f09d627b8ed03c253ae"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7e30c145c1d2ec95c052f3154d6f1b8f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classcugl_1_1_affine2.html">Affine2</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1_affine2.html#a7e30c145c1d2ec95c052f3154d6f1b8f">translate</a> (float tx, float ty)</td></tr>
<tr class="separator:a7e30c145c1d2ec95c052f3154d6f1b8f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2e320f84f61281bfb460dabd44889bb7"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1_affine2.html#a2e320f84f61281bfb460dabd44889bb7">toString</a> (bool verbose=false) const</td></tr>
<tr class="separator:a2e320f84f61281bfb460dabd44889bb7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac0aa5d7cb00a10d260c259d30972199d"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1_affine2.html#ac0aa5d7cb00a10d260c259d30972199d">operator std::string</a> () const</td></tr>
<tr class="separator:ac0aa5d7cb00a10d260c259d30972199d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa5dd65252ef303fabc6374a99650112d"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1_affine2.html#aa5dd65252ef303fabc6374a99650112d">operator Mat4</a> () const</td></tr>
<tr class="separator:aa5dd65252ef303fabc6374a99650112d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3937a566d4aaf041696762ea42fd1d8b"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1_affine2.html#a3937a566d4aaf041696762ea42fd1d8b">Affine2</a> (const <a class="el" href="classcugl_1_1_mat4.html">Mat4</a> &amp;mat)</td></tr>
<tr class="separator:a3937a566d4aaf041696762ea42fd1d8b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a51ae7869d91de19cba43df15791eb41a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classcugl_1_1_affine2.html">Affine2</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1_affine2.html#a51ae7869d91de19cba43df15791eb41a">operator=</a> (const <a class="el" href="classcugl_1_1_mat4.html">Mat4</a> &amp;mat)</td></tr>
<tr class="separator:a51ae7869d91de19cba43df15791eb41a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0e77b5955070cae1f4d600f1dd4ced53"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classcugl_1_1_affine2.html">Affine2</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1_affine2.html#a0e77b5955070cae1f4d600f1dd4ced53">set</a> (const <a class="el" href="classcugl_1_1_mat4.html">Mat4</a> &amp;mat)</td></tr>
<tr class="separator:a0e77b5955070cae1f4d600f1dd4ced53"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-static-methods"></a>
Static Public Member Functions</h2></td></tr>
<tr class="memitem:a23842cc46b2e7a76da1ac8315619971c"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classcugl_1_1_affine2.html">Affine2</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1_affine2.html#a23842cc46b2e7a76da1ac8315619971c">createScale</a> (float <a class="el" href="classcugl_1_1_affine2.html#a7227ee03e3435e83e02420c9ae316bf2">scale</a>)</td></tr>
<tr class="separator:a23842cc46b2e7a76da1ac8315619971c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a59af20c78d7c7ec908416318a81df573"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classcugl_1_1_affine2.html">Affine2</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1_affine2.html#a59af20c78d7c7ec908416318a81df573">createScale</a> (float <a class="el" href="classcugl_1_1_affine2.html#a7227ee03e3435e83e02420c9ae316bf2">scale</a>, <a class="el" href="classcugl_1_1_affine2.html">Affine2</a> *dst)</td></tr>
<tr class="separator:a59af20c78d7c7ec908416318a81df573"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a59f4b086e6609b38ce884a4da147ee90"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classcugl_1_1_affine2.html">Affine2</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1_affine2.html#a59f4b086e6609b38ce884a4da147ee90">createScale</a> (float sx, float sy)</td></tr>
<tr class="separator:a59f4b086e6609b38ce884a4da147ee90"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ada60bbed63d4ffaca69e1d0932ab451a"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classcugl_1_1_affine2.html">Affine2</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1_affine2.html#ada60bbed63d4ffaca69e1d0932ab451a">createScale</a> (float sx, float sy, <a class="el" href="classcugl_1_1_affine2.html">Affine2</a> *dst)</td></tr>
<tr class="separator:ada60bbed63d4ffaca69e1d0932ab451a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaa712997718004635b08bd2d7f3ce4ed"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classcugl_1_1_affine2.html">Affine2</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1_affine2.html#aaa712997718004635b08bd2d7f3ce4ed">createScale</a> (const <a class="el" href="classcugl_1_1_vec2.html">Vec2</a> <a class="el" href="classcugl_1_1_affine2.html#a7227ee03e3435e83e02420c9ae316bf2">scale</a>)</td></tr>
<tr class="separator:aaa712997718004635b08bd2d7f3ce4ed"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a63ccbf5ee257d0ad649369d78d754285"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classcugl_1_1_affine2.html">Affine2</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1_affine2.html#a63ccbf5ee257d0ad649369d78d754285">createScale</a> (const <a class="el" href="classcugl_1_1_vec2.html">Vec2</a> <a class="el" href="classcugl_1_1_affine2.html#a7227ee03e3435e83e02420c9ae316bf2">scale</a>, <a class="el" href="classcugl_1_1_affine2.html">Affine2</a> *dst)</td></tr>
<tr class="separator:a63ccbf5ee257d0ad649369d78d754285"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a49295f3f20239c8a2f5ac12a34aeffa5"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classcugl_1_1_affine2.html">Affine2</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1_affine2.html#a49295f3f20239c8a2f5ac12a34aeffa5">createRotation</a> (float angle)</td></tr>
<tr class="separator:a49295f3f20239c8a2f5ac12a34aeffa5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab409739c8248a4e06b3e567821e295a7"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classcugl_1_1_affine2.html">Affine2</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1_affine2.html#ab409739c8248a4e06b3e567821e295a7">createRotation</a> (float angle, <a class="el" href="classcugl_1_1_affine2.html">Affine2</a> *dst)</td></tr>
<tr class="separator:ab409739c8248a4e06b3e567821e295a7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a357603d8498534b6558061c126810dce"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classcugl_1_1_affine2.html">Affine2</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1_affine2.html#a357603d8498534b6558061c126810dce">createTranslation</a> (const <a class="el" href="classcugl_1_1_vec2.html">Vec2</a> trans)</td></tr>
<tr class="separator:a357603d8498534b6558061c126810dce"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a46adb671c25bd6de39302b3deb03e1a5"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classcugl_1_1_affine2.html">Affine2</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1_affine2.html#a46adb671c25bd6de39302b3deb03e1a5">createTranslation</a> (const <a class="el" href="classcugl_1_1_vec2.html">Vec2</a> trans, <a class="el" href="classcugl_1_1_affine2.html">Affine2</a> *dst)</td></tr>
<tr class="separator:a46adb671c25bd6de39302b3deb03e1a5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9751801bb4f8f79f70aae42f2307d9b0"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classcugl_1_1_affine2.html">Affine2</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1_affine2.html#a9751801bb4f8f79f70aae42f2307d9b0">createTranslation</a> (float tx, float ty)</td></tr>
<tr class="separator:a9751801bb4f8f79f70aae42f2307d9b0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a72e249b90f0cf2bc2ec89084cfee46c6"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classcugl_1_1_affine2.html">Affine2</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1_affine2.html#a72e249b90f0cf2bc2ec89084cfee46c6">createTranslation</a> (float tx, float ty, <a class="el" href="classcugl_1_1_affine2.html">Affine2</a> *dst)</td></tr>
<tr class="separator:a72e249b90f0cf2bc2ec89084cfee46c6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a72ed68fcb49664789bd9d44e81bc66f2"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classcugl_1_1_affine2.html">Affine2</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1_affine2.html#a72ed68fcb49664789bd9d44e81bc66f2">add</a> (const <a class="el" href="classcugl_1_1_affine2.html">Affine2</a> &amp;<a class="el" href="classcugl_1_1_affine2.html#aa79b0aa7e82dfb4a4e55f21e46cf92e6">m</a>, const <a class="el" href="classcugl_1_1_vec2.html">Vec2</a> v, <a class="el" href="classcugl_1_1_affine2.html">Affine2</a> *dst)</td></tr>
<tr class="separator:a72ed68fcb49664789bd9d44e81bc66f2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac11113408bed5ef327e84a688ac00095"><td class="memItemLeft" align="right" valign="top">static float *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1_affine2.html#ac11113408bed5ef327e84a688ac00095">add</a> (const float *<a class="el" href="classcugl_1_1_affine2.html#aa79b0aa7e82dfb4a4e55f21e46cf92e6">m</a>, const <a class="el" href="classcugl_1_1_vec2.html">Vec2</a> v, float *dst, size_t stride=2)</td></tr>
<tr class="separator:ac11113408bed5ef327e84a688ac00095"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7764131775d3cbc4c6fb544963f0a46d"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classcugl_1_1_affine2.html">Affine2</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1_affine2.html#a7764131775d3cbc4c6fb544963f0a46d">subtract</a> (const <a class="el" href="classcugl_1_1_affine2.html">Affine2</a> &amp;m1, const <a class="el" href="classcugl_1_1_vec2.html">Vec2</a> v, <a class="el" href="classcugl_1_1_affine2.html">Affine2</a> *dst)</td></tr>
<tr class="separator:a7764131775d3cbc4c6fb544963f0a46d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a93c9ffcc42b0e0937604abed0bd75aa9"><td class="memItemLeft" align="right" valign="top">static float *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1_affine2.html#a93c9ffcc42b0e0937604abed0bd75aa9">subtract</a> (const float *m1, const <a class="el" href="classcugl_1_1_vec2.html">Vec2</a> v, float *dst, size_t stride=2)</td></tr>
<tr class="separator:a93c9ffcc42b0e0937604abed0bd75aa9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0a0b39bc452cc3747a59171ab342741f"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classcugl_1_1_affine2.html">Affine2</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1_affine2.html#a0a0b39bc452cc3747a59171ab342741f">multiply</a> (const <a class="el" href="classcugl_1_1_affine2.html">Affine2</a> &amp;mat, float scalar, <a class="el" href="classcugl_1_1_affine2.html">Affine2</a> *dst)</td></tr>
<tr class="separator:a0a0b39bc452cc3747a59171ab342741f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa6648f4c674c6540c977a721b8f5d6f1"><td class="memItemLeft" align="right" valign="top">static float *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1_affine2.html#aa6648f4c674c6540c977a721b8f5d6f1">multiply</a> (const float *mat, float scalar, float *dst, size_t stride=2)</td></tr>
<tr class="separator:aa6648f4c674c6540c977a721b8f5d6f1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad400dddda62cc2a1eef110ae980a52d3"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classcugl_1_1_affine2.html">Affine2</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1_affine2.html#ad400dddda62cc2a1eef110ae980a52d3">multiply</a> (const <a class="el" href="classcugl_1_1_affine2.html">Affine2</a> &amp;m1, const <a class="el" href="classcugl_1_1_affine2.html">Affine2</a> &amp;m2, <a class="el" href="classcugl_1_1_affine2.html">Affine2</a> *dst)</td></tr>
<tr class="separator:ad400dddda62cc2a1eef110ae980a52d3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4e9464864c05a7ad213296eb12d6b06c"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classcugl_1_1_affine2.html">Affine2</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1_affine2.html#a4e9464864c05a7ad213296eb12d6b06c">multiply</a> (const <a class="el" href="classcugl_1_1_affine2.html">Affine2</a> &amp;m1, const <a class="el" href="classcugl_1_1_mat4.html">Mat4</a> &amp;m2, <a class="el" href="classcugl_1_1_affine2.html">Affine2</a> *dst)</td></tr>
<tr class="separator:a4e9464864c05a7ad213296eb12d6b06c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5ecdb5a5ca58db850ada534d01a01cf3"><td class="memItemLeft" align="right" valign="top">static float *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1_affine2.html#a5ecdb5a5ca58db850ada534d01a01cf3">multiply</a> (const float *m1, const float *m2, float *dst, size_t stride=2)</td></tr>
<tr class="separator:a5ecdb5a5ca58db850ada534d01a01cf3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5a21fb146cc2fd4a9904cfe011cb667c"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classcugl_1_1_affine2.html">Affine2</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1_affine2.html#a5a21fb146cc2fd4a9904cfe011cb667c">invert</a> (const <a class="el" href="classcugl_1_1_affine2.html">Affine2</a> &amp;m1, <a class="el" href="classcugl_1_1_affine2.html">Affine2</a> *dst)</td></tr>
<tr class="separator:a5a21fb146cc2fd4a9904cfe011cb667c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1879732f89f3065de65600974b57c26b"><td class="memItemLeft" align="right" valign="top">static float *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1_affine2.html#a1879732f89f3065de65600974b57c26b">invert</a> (const float *m1, float *dst, size_t stride=2)</td></tr>
<tr class="separator:a1879732f89f3065de65600974b57c26b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a66d1df3ac53032a47d7900d6ba84a173"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classcugl_1_1_vec2.html">Vec2</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1_affine2.html#a66d1df3ac53032a47d7900d6ba84a173">transform</a> (const <a class="el" href="classcugl_1_1_affine2.html">Affine2</a> &amp;aff, const <a class="el" href="classcugl_1_1_vec2.html">Vec2</a> point, <a class="el" href="classcugl_1_1_vec2.html">Vec2</a> *dst)</td></tr>
<tr class="separator:a66d1df3ac53032a47d7900d6ba84a173"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1112dd1713f6ecf3c6aa131fd9828791"><td class="memItemLeft" align="right" valign="top">static float *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1_affine2.html#a1112dd1713f6ecf3c6aa131fd9828791">transform</a> (const <a class="el" href="classcugl_1_1_affine2.html">Affine2</a> &amp;aff, float const *input, float *output, size_t size)</td></tr>
<tr class="separator:a1112dd1713f6ecf3c6aa131fd9828791"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a713917416f9502b2ed1ebe7036fb4daa"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classcugl_1_1_rect.html">Rect</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1_affine2.html#a713917416f9502b2ed1ebe7036fb4daa">transform</a> (const <a class="el" href="classcugl_1_1_affine2.html">Affine2</a> &amp;aff, const <a class="el" href="classcugl_1_1_rect.html">Rect</a> rect, <a class="el" href="classcugl_1_1_rect.html">Rect</a> *dst)</td></tr>
<tr class="separator:a713917416f9502b2ed1ebe7036fb4daa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a689536c2e77699b10507b8133a6bc38f"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classcugl_1_1_affine2.html">Affine2</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1_affine2.html#a689536c2e77699b10507b8133a6bc38f">identify</a> (float *dst, size_t stride=2)</td></tr>
<tr class="separator:a689536c2e77699b10507b8133a6bc38f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab93a31399d061455211ac38aa0df509b"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classcugl_1_1_affine2.html">Affine2</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1_affine2.html#ab93a31399d061455211ac38aa0df509b">rotate</a> (const <a class="el" href="classcugl_1_1_affine2.html">Affine2</a> &amp;aff, float angle, <a class="el" href="classcugl_1_1_affine2.html">Affine2</a> *dst)</td></tr>
<tr class="separator:ab93a31399d061455211ac38aa0df509b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5bded7ceec9dd162df4612e30b4a7934"><td class="memItemLeft" align="right" valign="top">static float *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1_affine2.html#a5bded7ceec9dd162df4612e30b4a7934">rotate</a> (const float *aff, float angle, float *dst, size_t stride=2)</td></tr>
<tr class="separator:a5bded7ceec9dd162df4612e30b4a7934"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7227ee03e3435e83e02420c9ae316bf2"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classcugl_1_1_affine2.html">Affine2</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1_affine2.html#a7227ee03e3435e83e02420c9ae316bf2">scale</a> (const <a class="el" href="classcugl_1_1_affine2.html">Affine2</a> &amp;aff, float value, <a class="el" href="classcugl_1_1_affine2.html">Affine2</a> *dst)</td></tr>
<tr class="separator:a7227ee03e3435e83e02420c9ae316bf2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a579f2e48effd1624ff6cb11524225b3a"><td class="memItemLeft" align="right" valign="top">static float *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1_affine2.html#a579f2e48effd1624ff6cb11524225b3a">scale</a> (const float *aff, float value, float *dst, size_t stride=2)</td></tr>
<tr class="separator:a579f2e48effd1624ff6cb11524225b3a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4d359bab497c661e6040f7c97de9ab6b"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classcugl_1_1_affine2.html">Affine2</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1_affine2.html#a4d359bab497c661e6040f7c97de9ab6b">scale</a> (const <a class="el" href="classcugl_1_1_affine2.html">Affine2</a> &amp;aff, const <a class="el" href="classcugl_1_1_vec2.html">Vec2</a> s, <a class="el" href="classcugl_1_1_affine2.html">Affine2</a> *dst)</td></tr>
<tr class="separator:a4d359bab497c661e6040f7c97de9ab6b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad47245c0c51135cb26286f02e4a92400"><td class="memItemLeft" align="right" valign="top">static float *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1_affine2.html#ad47245c0c51135cb26286f02e4a92400">scale</a> (const float *aff, const <a class="el" href="classcugl_1_1_vec2.html">Vec2</a> s, float *dst, size_t stride=2)</td></tr>
<tr class="separator:ad47245c0c51135cb26286f02e4a92400"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a117a0e82c455b939cb393032e1a1cfb7"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classcugl_1_1_affine2.html">Affine2</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1_affine2.html#a117a0e82c455b939cb393032e1a1cfb7">scale</a> (const <a class="el" href="classcugl_1_1_affine2.html">Affine2</a> &amp;aff, float sx, float sy, <a class="el" href="classcugl_1_1_affine2.html">Affine2</a> *dst)</td></tr>
<tr class="separator:a117a0e82c455b939cb393032e1a1cfb7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a67fcaa8fa03869283d236e92e40fa0fc"><td class="memItemLeft" align="right" valign="top">static float *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1_affine2.html#a67fcaa8fa03869283d236e92e40fa0fc">scale</a> (const float *aff, float sx, float sy, float *dst, size_t stride=2)</td></tr>
<tr class="separator:a67fcaa8fa03869283d236e92e40fa0fc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a361b171ef04d9cf85d858a5bca15df6a"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classcugl_1_1_affine2.html">Affine2</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1_affine2.html#a361b171ef04d9cf85d858a5bca15df6a">translate</a> (const <a class="el" href="classcugl_1_1_affine2.html">Affine2</a> &amp;aff, const <a class="el" href="classcugl_1_1_vec2.html">Vec2</a> t, <a class="el" href="classcugl_1_1_affine2.html">Affine2</a> *dst)</td></tr>
<tr class="separator:a361b171ef04d9cf85d858a5bca15df6a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afb1d13a4faf20426c7c288c9fb0429ea"><td class="memItemLeft" align="right" valign="top">static float *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1_affine2.html#afb1d13a4faf20426c7c288c9fb0429ea">translate</a> (const float *aff, const <a class="el" href="classcugl_1_1_vec2.html">Vec2</a> t, float *dst, size_t stride=2)</td></tr>
<tr class="separator:afb1d13a4faf20426c7c288c9fb0429ea"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af8a88b03c8c38cb2f6fd611edfa7346d"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classcugl_1_1_affine2.html">Affine2</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1_affine2.html#af8a88b03c8c38cb2f6fd611edfa7346d">translate</a> (const <a class="el" href="classcugl_1_1_affine2.html">Affine2</a> &amp;aff, float tx, float ty, <a class="el" href="classcugl_1_1_affine2.html">Affine2</a> *dst)</td></tr>
<tr class="separator:af8a88b03c8c38cb2f6fd611edfa7346d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa4d61a865a27fa3609a93f3b12732a0d"><td class="memItemLeft" align="right" valign="top">static float *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1_affine2.html#aa4d61a865a27fa3609a93f3b12732a0d">translate</a> (const float *aff, float tx, float ty, float *dst, size_t stride=2)</td></tr>
<tr class="separator:aa4d61a865a27fa3609a93f3b12732a0d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1c1dbcda358f9544e9d4d7c9be16b20e"><td class="memItemLeft" align="right" valign="top">static bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1_affine2.html#a1c1dbcda358f9544e9d4d7c9be16b20e">decompose</a> (const <a class="el" href="classcugl_1_1_affine2.html">Affine2</a> &amp;mat, <a class="el" href="classcugl_1_1_vec2.html">Vec2</a> *<a class="el" href="classcugl_1_1_affine2.html#a7227ee03e3435e83e02420c9ae316bf2">scale</a>, float *rot, <a class="el" href="classcugl_1_1_vec2.html">Vec2</a> *trans)</td></tr>
<tr class="separator:a1c1dbcda358f9544e9d4d7c9be16b20e"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-attribs"></a>
Public Attributes</h2></td></tr>
<tr class="memitem:aa79b0aa7e82dfb4a4e55f21e46cf92e6"><td class="memItemLeft" align="right" valign="top">float&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1_affine2.html#aa79b0aa7e82dfb4a4e55f21e46cf92e6">m</a> [6]</td></tr>
<tr class="separator:aa79b0aa7e82dfb4a4e55f21e46cf92e6"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-static-attribs"></a>
Static Public Attributes</h2></td></tr>
<tr class="memitem:ae026a9986f11addd15e11f4c2529cef7"><td class="memItemLeft" align="right" valign="top">static const <a class="el" href="classcugl_1_1_affine2.html">Affine2</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1_affine2.html#ae026a9986f11addd15e11f4c2529cef7">ZERO</a></td></tr>
<tr class="separator:ae026a9986f11addd15e11f4c2529cef7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a89d528a1f040fa2769cf93d1b8ef58dc"><td class="memItemLeft" align="right" valign="top">static const <a class="el" href="classcugl_1_1_affine2.html">Affine2</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1_affine2.html#a89d528a1f040fa2769cf93d1b8ef58dc">ONE</a></td></tr>
<tr class="separator:a89d528a1f040fa2769cf93d1b8ef58dc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aefdf7abfee94c17467aac4ee96610917"><td class="memItemLeft" align="right" valign="top">static const <a class="el" href="classcugl_1_1_affine2.html">Affine2</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1_affine2.html#aefdf7abfee94c17467aac4ee96610917">IDENTITY</a></td></tr>
<tr class="separator:aefdf7abfee94c17467aac4ee96610917"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>This class defines an affine transform on 2D space.</p>
<p>In the case where you are only manipulating 2D points, this class may be faster than <a class="el" href="classcugl_1_1_mat4.html">Mat4</a>, even with the vectorization support. For an affine transform in 3d space, use <a class="el" href="classcugl_1_1_mat4.html">Mat4</a>.</p>
<p>An affine transform is represeted by 3x2 matrix in column major order, keeping with the convention of <a class="el" href="classcugl_1_1_mat4.html">Mat4</a>. The last column is the translation offset. In addition, we assume that all operations are multiplied on the right.</p>
<p>Because of OpenGL alignment issues, an affine transform typically needs to be converted to a 3x3 matrix (for <a class="el" href="classcugl_1_1_shader.html">Shader</a> or a 3x4 matrix (for a <a class="el" href="classcugl_1_1_uniform_buffer.html">UniformBuffer</a>). For that reason this class contains several static methods for processing float arrays of different strides. These methods interpret stride pairwise. For example, a stride of 4 corresponds to a 3x4 matrix with the first two elements at position 0 and 1, the next two at 4 and 5, and the last two at 8 and 9.</p>
<p>While an affine transform corresponds to a 3x3 matrix in homongeneous coordinates, this class is not an arbitrary Mat3 class. It enforces that its contents are always an affine transform. </p>
</div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="a4b8cdc57a2fefbe3b701bd13b1b9c8c3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4b8cdc57a2fefbe3b701bd13b1b9c8c3">&#9670;&nbsp;</a></span>Affine2() <span class="overload">[1/6]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">cugl::Affine2::Affine2 </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Creates the identity transform. </p><pre class="fragment">1  0  0
0  1  0
</pre> 
</div>
</div>
<a id="aab97798b85f16c036eea8f5902f64853"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aab97798b85f16c036eea8f5902f64853">&#9670;&nbsp;</a></span>Affine2() <span class="overload">[2/6]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">cugl::Affine2::Affine2 </td>
          <td>(</td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>m11</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>m12</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>m21</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>m22</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>tx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>ty</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Constructs a matrix initialized to the specified values.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">m11</td><td>The first element of the first row. </td></tr>
    <tr><td class="paramname">m12</td><td>The second element of the first row. </td></tr>
    <tr><td class="paramname">m21</td><td>The first element of the second row. </td></tr>
    <tr><td class="paramname">m22</td><td>The second element of the second row. </td></tr>
    <tr><td class="paramname">tx</td><td>The translation offset for the x-coordinate. </td></tr>
    <tr><td class="paramname">ty</td><td>The translation offset for the y-coordinate. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="adec4e6f35e898ccd5846066e25eb0d38"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adec4e6f35e898ccd5846066e25eb0d38">&#9670;&nbsp;</a></span>Affine2() <span class="overload">[3/6]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">cugl::Affine2::Affine2 </td>
          <td>(</td>
          <td class="paramtype">const float *&#160;</td>
          <td class="paramname"><em>mat</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Creates a matrix initialized to the specified column-major array.</p>
<p>The passed-in array is six elements in column-major order, with the last two elements being the translation offset. Hence the memory layout of the array is as follows: </p><pre class="fragment">0   2   4
1   3   5
</pre> <dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">mat</td><td>An array containing 6 elements in column-major order. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a0f2a28b046f97e022fd688d0850179e7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0f2a28b046f97e022fd688d0850179e7">&#9670;&nbsp;</a></span>Affine2() <span class="overload">[4/6]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">cugl::Affine2::Affine2 </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classcugl_1_1_affine2.html">Affine2</a> &amp;&#160;</td>
          <td class="paramname"><em>copy</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Constructs a new transform that is the copy of the specified one.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">copy</td><td>The transform to copy. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a641ade00a492018865a14b382afc870d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a641ade00a492018865a14b382afc870d">&#9670;&nbsp;</a></span>Affine2() <span class="overload">[5/6]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">cugl::Affine2::Affine2 </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classcugl_1_1_affine2.html">Affine2</a> &amp;&amp;&#160;</td>
          <td class="paramname"><em>copy</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Constructs a new transform that contains the resources of the specified one.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">copy</td><td>The transform contributing resources. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a25af9673fe7343a4989130f2227fabf7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a25af9673fe7343a4989130f2227fabf7">&#9670;&nbsp;</a></span>~Affine2()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">cugl::Affine2::~Affine2 </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Destroys this transform, releasing all resources. </p>

</div>
</div>
<a id="a3937a566d4aaf041696762ea42fd1d8b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3937a566d4aaf041696762ea42fd1d8b">&#9670;&nbsp;</a></span>Affine2() <span class="overload">[6/6]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">cugl::Affine2::Affine2 </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classcugl_1_1_mat4.html">Mat4</a> &amp;&#160;</td>
          <td class="paramname"><em>mat</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">explicit</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Creates an affine transform from the given matrix.</p>
<p>The z values are all uniformly ignored. However, it the final element of the matrix is not 1 (e.g. the translation has a w value of 1), then it divides the entire matrix before creating the affine transform</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">mat</td><td>The matrix to convert </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="a72ed68fcb49664789bd9d44e81bc66f2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a72ed68fcb49664789bd9d44e81bc66f2">&#9670;&nbsp;</a></span>add() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="classcugl_1_1_affine2.html">Affine2</a>* cugl::Affine2::add </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classcugl_1_1_affine2.html">Affine2</a> &amp;&#160;</td>
          <td class="paramname"><em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classcugl_1_1_vec2.html">Vec2</a>&#160;</td>
          <td class="paramname"><em>v</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classcugl_1_1_affine2.html">Affine2</a> *&#160;</td>
          <td class="paramname"><em>dst</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Adds the specified offset to the given and stores the result in dst.</p>
<p>Addition is applied to the offset only; the core matrix is unchanged.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">m</td><td>The initial transform. </td></tr>
    <tr><td class="paramname">v</td><td>The offset to add. </td></tr>
    <tr><td class="paramname">dst</td><td>A transform to store the result in.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A reference to dst for chaining </dd></dl>

</div>
</div>
<a id="ac11113408bed5ef327e84a688ac00095"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac11113408bed5ef327e84a688ac00095">&#9670;&nbsp;</a></span>add() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static float* cugl::Affine2::add </td>
          <td>(</td>
          <td class="paramtype">const float *&#160;</td>
          <td class="paramname"><em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classcugl_1_1_vec2.html">Vec2</a>&#160;</td>
          <td class="paramname"><em>v</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float *&#160;</td>
          <td class="paramname"><em>dst</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>stride</em> = <code>2</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Adds the specified offset to the given and stores the result in dst.</p>
<p>Addition is applied to the offset only; the core matrix is unchanged. Both of the float arrays should have at least 6-elements where each of the three pairs have the given stride.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">m</td><td>The initial transform in column major order </td></tr>
    <tr><td class="paramname">v</td><td>The offset to add. </td></tr>
    <tr><td class="paramname">dst</td><td>A transform to store the result in column major order </td></tr>
    <tr><td class="paramname">stride</td><td>The pairwise data stride</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A reference to dst for chaining </dd></dl>

</div>
</div>
<a id="a9215cec637f03573a4e0f830a1861d55"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9215cec637f03573a4e0f830a1861d55">&#9670;&nbsp;</a></span>add() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcugl_1_1_affine2.html">Affine2</a>&amp; cugl::Affine2::add </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classcugl_1_1_vec2.html">Vec2</a>&#160;</td>
          <td class="paramname"><em>v</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Adds the specified offset to this transform.</p>
<p>Addition is applied to the offset only; the core matrix is unchanged.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">v</td><td>The offset to add.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A reference to the <a class="el" href="classcugl_1_1_affine2.html">Affine2</a> after addition. </dd></dl>

</div>
</div>
<a id="a49295f3f20239c8a2f5ac12a34aeffa5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a49295f3f20239c8a2f5ac12a34aeffa5">&#9670;&nbsp;</a></span>createRotation() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="classcugl_1_1_affine2.html">Affine2</a> cugl::Affine2::createRotation </td>
          <td>(</td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>angle</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns a rotation transform for the given angle.</p>
<p>The angle measurement is in radians. The rotation is counter clockwise about the z-axis.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">angle</td><td>The angle (in radians).</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a rotation transform for the given angle. </dd></dl>

</div>
</div>
<a id="ab409739c8248a4e06b3e567821e295a7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab409739c8248a4e06b3e567821e295a7">&#9670;&nbsp;</a></span>createRotation() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="classcugl_1_1_affine2.html">Affine2</a>* cugl::Affine2::createRotation </td>
          <td>(</td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>angle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classcugl_1_1_affine2.html">Affine2</a> *&#160;</td>
          <td class="paramname"><em>dst</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Creates a rotation transform for the given angle, putting it in dst.</p>
<p>The angle measurement is in radians. The rotation is counter clockwise about the z-axis.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">angle</td><td>The angle (in radians). </td></tr>
    <tr><td class="paramname">dst</td><td>A transform to store the result in.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A reference to dst for chaining </dd></dl>

</div>
</div>
<a id="aaa712997718004635b08bd2d7f3ce4ed"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaa712997718004635b08bd2d7f3ce4ed">&#9670;&nbsp;</a></span>createScale() <span class="overload">[1/6]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="classcugl_1_1_affine2.html">Affine2</a> cugl::Affine2::createScale </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classcugl_1_1_vec2.html">Vec2</a>&#160;</td>
          <td class="paramname"><em>scale</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns a nonuniform scale transform from the given vector.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">scale</td><td>The nonuniform scale value.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a nonuniform scale transform from the given vector. </dd></dl>

</div>
</div>
<a id="a63ccbf5ee257d0ad649369d78d754285"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a63ccbf5ee257d0ad649369d78d754285">&#9670;&nbsp;</a></span>createScale() <span class="overload">[2/6]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="classcugl_1_1_affine2.html">Affine2</a>* cugl::Affine2::createScale </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classcugl_1_1_vec2.html">Vec2</a>&#160;</td>
          <td class="paramname"><em>scale</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classcugl_1_1_affine2.html">Affine2</a> *&#160;</td>
          <td class="paramname"><em>dst</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Creates a nonuniform scale transform from the given vector, putting it in dst.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">scale</td><td>The nonuniform scale value. </td></tr>
    <tr><td class="paramname">dst</td><td>A transform to store the result in.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A reference to dst for chaining </dd></dl>

</div>
</div>
<a id="a23842cc46b2e7a76da1ac8315619971c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a23842cc46b2e7a76da1ac8315619971c">&#9670;&nbsp;</a></span>createScale() <span class="overload">[3/6]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="classcugl_1_1_affine2.html">Affine2</a> cugl::Affine2::createScale </td>
          <td>(</td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>scale</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns a uniform scale transform.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">scale</td><td>The amount to scale.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a uniform scale transform. </dd></dl>

</div>
</div>
<a id="a59af20c78d7c7ec908416318a81df573"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a59af20c78d7c7ec908416318a81df573">&#9670;&nbsp;</a></span>createScale() <span class="overload">[4/6]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="classcugl_1_1_affine2.html">Affine2</a>* cugl::Affine2::createScale </td>
          <td>(</td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>scale</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classcugl_1_1_affine2.html">Affine2</a> *&#160;</td>
          <td class="paramname"><em>dst</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Creates a uniform scale transform, putting it in dst.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">scale</td><td>The amount to scale. </td></tr>
    <tr><td class="paramname">dst</td><td>A transform to store the result in.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A reference to dst for chaining </dd></dl>

</div>
</div>
<a id="a59f4b086e6609b38ce884a4da147ee90"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a59f4b086e6609b38ce884a4da147ee90">&#9670;&nbsp;</a></span>createScale() <span class="overload">[5/6]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="classcugl_1_1_affine2.html">Affine2</a> cugl::Affine2::createScale </td>
          <td>(</td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>sx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>sy</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns a nonuniform scale transform.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">sx</td><td>The amount to scale along the x-axis. </td></tr>
    <tr><td class="paramname">sy</td><td>The amount to scale along the y-axis.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a nonuniform scale transform. </dd></dl>

</div>
</div>
<a id="ada60bbed63d4ffaca69e1d0932ab451a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ada60bbed63d4ffaca69e1d0932ab451a">&#9670;&nbsp;</a></span>createScale() <span class="overload">[6/6]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="classcugl_1_1_affine2.html">Affine2</a>* cugl::Affine2::createScale </td>
          <td>(</td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>sx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>sy</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classcugl_1_1_affine2.html">Affine2</a> *&#160;</td>
          <td class="paramname"><em>dst</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Creates a nonuniform scale transform, putting it in dst.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">sx</td><td>The amount to scale along the x-axis. </td></tr>
    <tr><td class="paramname">sy</td><td>The amount to scale along the y-axis. </td></tr>
    <tr><td class="paramname">dst</td><td>A transform to store the result in.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A reference to dst for chaining </dd></dl>

</div>
</div>
<a id="a357603d8498534b6558061c126810dce"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a357603d8498534b6558061c126810dce">&#9670;&nbsp;</a></span>createTranslation() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="classcugl_1_1_affine2.html">Affine2</a> cugl::Affine2::createTranslation </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classcugl_1_1_vec2.html">Vec2</a>&#160;</td>
          <td class="paramname"><em>trans</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns a translation transform from the given offset</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">trans</td><td>The translation offset.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a translation transform from the given offset </dd></dl>

</div>
</div>
<a id="a46adb671c25bd6de39302b3deb03e1a5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a46adb671c25bd6de39302b3deb03e1a5">&#9670;&nbsp;</a></span>createTranslation() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="classcugl_1_1_affine2.html">Affine2</a>* cugl::Affine2::createTranslation </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classcugl_1_1_vec2.html">Vec2</a>&#160;</td>
          <td class="paramname"><em>trans</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classcugl_1_1_affine2.html">Affine2</a> *&#160;</td>
          <td class="paramname"><em>dst</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Creates a translation transform from the given offset, putting it in dst.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">trans</td><td>The translation offset. </td></tr>
    <tr><td class="paramname">dst</td><td>A transform to store the result in.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A reference to dst for chaining </dd></dl>

</div>
</div>
<a id="a9751801bb4f8f79f70aae42f2307d9b0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9751801bb4f8f79f70aae42f2307d9b0">&#9670;&nbsp;</a></span>createTranslation() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="classcugl_1_1_affine2.html">Affine2</a> cugl::Affine2::createTranslation </td>
          <td>(</td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>tx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>ty</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns a translation transform from the given parameters.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">tx</td><td>The translation on the x-axis. </td></tr>
    <tr><td class="paramname">ty</td><td>The translation on the y-axis.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a translation transform from the given parameters. </dd></dl>

</div>
</div>
<a id="a72e249b90f0cf2bc2ec89084cfee46c6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a72e249b90f0cf2bc2ec89084cfee46c6">&#9670;&nbsp;</a></span>createTranslation() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="classcugl_1_1_affine2.html">Affine2</a>* cugl::Affine2::createTranslation </td>
          <td>(</td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>tx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>ty</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classcugl_1_1_affine2.html">Affine2</a> *&#160;</td>
          <td class="paramname"><em>dst</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Creates a translation transform from the given parameters, putting it in dst.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">tx</td><td>The translation on the x-axis. </td></tr>
    <tr><td class="paramname">ty</td><td>The translation on the y-axis. </td></tr>
    <tr><td class="paramname">dst</td><td>A transform to store the result in.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A reference to dst for chaining </dd></dl>

</div>
</div>
<a id="a1c1dbcda358f9544e9d4d7c9be16b20e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1c1dbcda358f9544e9d4d7c9be16b20e">&#9670;&nbsp;</a></span>decompose()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static bool cugl::Affine2::decompose </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classcugl_1_1_affine2.html">Affine2</a> &amp;&#160;</td>
          <td class="paramname"><em>mat</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classcugl_1_1_vec2.html">Vec2</a> *&#160;</td>
          <td class="paramname"><em>scale</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float *&#160;</td>
          <td class="paramname"><em>rot</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classcugl_1_1_vec2.html">Vec2</a> *&#160;</td>
          <td class="paramname"><em>trans</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Decomposes the scale, rotation and translation components of the given matrix.</p>
<p>To work properly, the matrix must have been constructed in the following order: scale, then rotate, then translation. While the rotation matrix will always be correct, the scale and translation are not guaranteed to be correct if this is violated.</p>
<p>If any pointer is null, the method simply does not assign that result. However, it will still continue to compute the component with non-null vectors to store the result.</p>
<p>If the scale component is too small, then it may be impossible to extract the rotation. In that case, if the rotation pointer is not null, this method will return false.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">mat</td><td>The transform to decompose. </td></tr>
    <tr><td class="paramname">scale</td><td>The scale component. </td></tr>
    <tr><td class="paramname">rot</td><td>The rotation component. </td></tr>
    <tr><td class="paramname">trans</td><td>The translation component.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if all requested components were properly extracted </dd></dl>

</div>
</div>
<a id="aaf76247f97dc414a384c0f808c83871d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaf76247f97dc414a384c0f808c83871d">&#9670;&nbsp;</a></span>equals()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool cugl::Affine2::equals </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classcugl_1_1_affine2.html">Affine2</a> &amp;&#160;</td>
          <td class="paramname"><em>mat</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>variance</em> = <code>5.0e-4f</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns true if the transforms are within tolerance of each other.</p>
<p>The tolerance is applied to each element of the transform individually.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">mat</td><td>The transform to compare against. </td></tr>
    <tr><td class="paramname">variance</td><td>The comparison tolerance.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if the transforms are within tolerance of each other. </dd></dl>

</div>
</div>
<a id="ab8c8be050ee86cff21c2b31111c869b7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab8c8be050ee86cff21c2b31111c869b7">&#9670;&nbsp;</a></span>get()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">float* cugl::Affine2::get </td>
          <td>(</td>
          <td class="paramtype">float *&#160;</td>
          <td class="paramname"><em>array</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>stride</em> = <code>2</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Reads the affine transform as an array with the given stride</p>
<p>The float array should have at least 6-elements where each of the three pairs have the given stride. Postions outside of the 6 element core are left untouched.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">array</td><td>The array to store the values </td></tr>
    <tr><td class="paramname">stride</td><td>The pairwise data stride</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a reference to the array for chaining </dd></dl>

</div>
</div>
<a id="aedfc45c899f4dd8b57a20ea93b831b7f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aedfc45c899f4dd8b57a20ea93b831b7f">&#9670;&nbsp;</a></span>get3x3()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">float* cugl::Affine2::get3x3 </td>
          <td>(</td>
          <td class="paramtype">float *&#160;</td>
          <td class="paramname"><em>array</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Reads the affine transform as a 3x3 matrix into the given array.</p>
<p>The array should contain at least 9 elements. The transform is read in column major order as a 3x3 matrix in homogenous coordinates. That is, the z values are all 0, except for the translation component which is 1.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">array</td><td>The array to store the values</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a reference to the array for chaining </dd></dl>

</div>
</div>
<a id="a5a6bc0904428703fb031f1247fdfcc75"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5a6bc0904428703fb031f1247fdfcc75">&#9670;&nbsp;</a></span>get3x4()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">float* cugl::Affine2::get3x4 </td>
          <td>(</td>
          <td class="paramtype">float *&#160;</td>
          <td class="paramname"><em>array</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Reads the affine transform as a 3x4 matrix into the given array.</p>
<p>The array should contain at least 12 elements. The transform is read in column major order as a 3x4 matrix in homogenous coordinates. That is, the z and w values are all 0, except for the translation z component which is 1.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">array</td><td>The array to store the values</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a reference to the array for chaining </dd></dl>

</div>
</div>
<a id="a612dabb8d4ae8b740e9998865c649fa2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a612dabb8d4ae8b740e9998865c649fa2">&#9670;&nbsp;</a></span>get4x4()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">float* cugl::Affine2::get4x4 </td>
          <td>(</td>
          <td class="paramtype">float *&#160;</td>
          <td class="paramname"><em>array</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Reads the affine transform as a 4x4 matrix into the given array.</p>
<p>The array should contain at least 16 elements. The transform is read in column major order as a 4x4 matrix in homogenous coordinates. The z and w values are all 0, except for the translation w component which is 1.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">array</td><td>The array to store the values</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a reference to the array for chaining </dd></dl>

</div>
</div>
<a id="ad5d9b6afcc292a35452772276080efb9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad5d9b6afcc292a35452772276080efb9">&#9670;&nbsp;</a></span>getDeterminant()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">float cugl::Affine2::getDeterminant </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns the determinant of this transform.</p>
<p>The determinant is a feature of the core matrix. The offset is ignored.</p>
<dl class="section return"><dt>Returns</dt><dd>the determinant of this transform. </dd></dl>

</div>
</div>
<a id="a001b233ab6d35f2181054ac123538af7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a001b233ab6d35f2181054ac123538af7">&#9670;&nbsp;</a></span>getInverse()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcugl_1_1_affine2.html">Affine2</a> cugl::Affine2::getInverse </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns a copy of the inverse of this transform.</p>
<p>If the transform cannot be inverted, this method returns the zero transform.</p>
<p>Note: This does not modify the transform.</p>
<dl class="section return"><dt>Returns</dt><dd>a copy of the inverse of this transform. </dd></dl>

</div>
</div>
<a id="a9eaa2069732861bf2aa33f9b0c76d4f5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9eaa2069732861bf2aa33f9b0c76d4f5">&#9670;&nbsp;</a></span>getRotation()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">float cugl::Affine2::getRotation </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns the rotational angle of this transform.</p>
<p>If the scale component is too close to zero, we cannot extract the rotation. In that case, we return the zero angle. ( </p><dl class="section return"><dt>Returns</dt><dd>the rotational angle of this transform. </dd></dl>

</div>
</div>
<a id="a4f38c74b7a7573b39bca73f7a942853f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4f38c74b7a7573b39bca73f7a942853f">&#9670;&nbsp;</a></span>getScale()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcugl_1_1_vec2.html">Vec2</a> cugl::Affine2::getScale </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns the scale component of this transform.</p>
<p>If the scale component of this matrix has negative parts, it is not possible to always extract the exact scalar component. In that case, a scale vector that is mathematically equivalent to the original scale vector is extracted and returned.</p>
<dl class="section return"><dt>Returns</dt><dd>the scale component of this transform. </dd></dl>

</div>
</div>
<a id="aefc41b27c94bb910db443f7384e90a28"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aefc41b27c94bb910db443f7384e90a28">&#9670;&nbsp;</a></span>getTranslation()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcugl_1_1_vec2.html">Vec2</a> cugl::Affine2::getTranslation </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns the translational component of this transform.</p>
<dl class="section return"><dt>Returns</dt><dd>the translational component of this transform. </dd></dl>

</div>
</div>
<a id="a689536c2e77699b10507b8133a6bc38f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a689536c2e77699b10507b8133a6bc38f">&#9670;&nbsp;</a></span>identify()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="classcugl_1_1_affine2.html">Affine2</a>* cugl::Affine2::identify </td>
          <td>(</td>
          <td class="paramtype">float *&#160;</td>
          <td class="paramname"><em>dst</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>stride</em> = <code>2</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Sets the float array to be an identity affine transform.</p>
<p>The float arrays should have at least 6-elements where each of the three pairs have the given stride. Positions outside of the 6 core elements are untouched.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dst</td><td>The affine to reset in column major order </td></tr>
    <tr><td class="paramname">stride</td><td>The pairwise data stride</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A reference to dst for chaining </dd></dl>

</div>
</div>
<a id="a8fc06d785c74d017b9816e35dbacd615"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8fc06d785c74d017b9816e35dbacd615">&#9670;&nbsp;</a></span>invert() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcugl_1_1_affine2.html">Affine2</a>&amp; cugl::Affine2::invert </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Inverts this transform in place.</p>
<p>If the transform cannot be inverted, this method sets it to the zero transform.</p>
<dl class="section return"><dt>Returns</dt><dd>A reference to the <a class="el" href="classcugl_1_1_affine2.html">Affine2</a> after the inversion. </dd></dl>

</div>
</div>
<a id="a5a21fb146cc2fd4a9904cfe011cb667c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5a21fb146cc2fd4a9904cfe011cb667c">&#9670;&nbsp;</a></span>invert() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="classcugl_1_1_affine2.html">Affine2</a>* cugl::Affine2::invert </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classcugl_1_1_affine2.html">Affine2</a> &amp;&#160;</td>
          <td class="paramname"><em>m1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classcugl_1_1_affine2.html">Affine2</a> *&#160;</td>
          <td class="paramname"><em>dst</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Inverts m1 and stores the result in dst.</p>
<p>If the transform cannot be inverted, this method stores the zero transform in dst.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">m1</td><td>The transform to negate. </td></tr>
    <tr><td class="paramname">dst</td><td>A transform to store the result in.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A reference to dst for chaining </dd></dl>

</div>
</div>
<a id="a1879732f89f3065de65600974b57c26b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1879732f89f3065de65600974b57c26b">&#9670;&nbsp;</a></span>invert() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static float* cugl::Affine2::invert </td>
          <td>(</td>
          <td class="paramtype">const float *&#160;</td>
          <td class="paramname"><em>m1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float *&#160;</td>
          <td class="paramname"><em>dst</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>stride</em> = <code>2</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Inverts m1 and stores the result in dst.</p>
<p>If the transform cannot be inverted, this method stores the zero transform in dst. Both of the float arrays should have at least 6-elements where each of the three pairs have the given stride. When converting a matrix to the zero transform, positions outside of the 6 core elements are ignored.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">m1</td><td>The transform to negate in column major order </td></tr>
    <tr><td class="paramname">dst</td><td>A transform to store the result in column major order </td></tr>
    <tr><td class="paramname">stride</td><td>The pairwise data stride</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A reference to dst for chaining </dd></dl>

</div>
</div>
<a id="a9710c87a601a6be0149bfb1a4e85b94c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9710c87a601a6be0149bfb1a4e85b94c">&#9670;&nbsp;</a></span>isExactly()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool cugl::Affine2::isExactly </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classcugl_1_1_affine2.html">Affine2</a> &amp;&#160;</td>
          <td class="paramname"><em>aff</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns true if the transforms are exactly equal to each other.</p>
<p>This method may be unreliable given that the elements are floats. It should only be used to compared transform that have not undergone a lot of manipulation.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">aff</td><td>The transform to compare against.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if the transforms are exactly equal to each other. </dd></dl>

</div>
</div>
<a id="a5cfc7ef754d3013679c6cf1ead3cb0b3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5cfc7ef754d3013679c6cf1ead3cb0b3">&#9670;&nbsp;</a></span>isIdentity()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool cugl::Affine2::isIdentity </td>
          <td>(</td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>variance</em> = <code>0.0f</code></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns true if this transform is equal to the identity transform.</p>
<p>The optional comparison tolerance takes into accout that elements are floats and this may not be exact. The tolerance is applied to each element individually. By default, the match must be exact.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">variance</td><td>The comparison tolerance</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if this transform is equal to the identity transform. </dd></dl>

</div>
</div>
<a id="ab2321a2922cb78013afd101024b98722"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab2321a2922cb78013afd101024b98722">&#9670;&nbsp;</a></span>isInvertible()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool cugl::Affine2::isInvertible </td>
          <td>(</td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>variance</em> = <code>5.0e-4f</code></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns true if this transform is invertible.</p>
<p>The optional comparison tolerance takes into accout that elements are floats and this may not be exact. The tolerance is applied to the determinant of the core matrix.</p>
<dl class="section return"><dt>Returns</dt><dd>true if this transform is invertible. </dd></dl>

</div>
</div>
<a id="ab6dfc881e0e6937b67588cdf5f16f7c3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab6dfc881e0e6937b67588cdf5f16f7c3">&#9670;&nbsp;</a></span>multiply() <span class="overload">[1/9]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcugl_1_1_affine2.html">Affine2</a>&amp; cugl::Affine2::multiply </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classcugl_1_1_affine2.html">Affine2</a> &amp;&#160;</td>
          <td class="paramname"><em>aff</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Multiplies this matrix by the specified one.</p>
<p>Transform multiplication is defined as standard function composition. The transform m2 is on the right. This means that it corresponds to an subsequent transform; transforms are applied left-to-right.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">aff</td><td>The transform to multiply.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A reference to the <a class="el" href="classcugl_1_1_affine2.html">Affine2</a> after multiplication. </dd></dl>

</div>
</div>
<a id="ad400dddda62cc2a1eef110ae980a52d3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad400dddda62cc2a1eef110ae980a52d3">&#9670;&nbsp;</a></span>multiply() <span class="overload">[2/9]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="classcugl_1_1_affine2.html">Affine2</a>* cugl::Affine2::multiply </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classcugl_1_1_affine2.html">Affine2</a> &amp;&#160;</td>
          <td class="paramname"><em>m1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classcugl_1_1_affine2.html">Affine2</a> &amp;&#160;</td>
          <td class="paramname"><em>m2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classcugl_1_1_affine2.html">Affine2</a> *&#160;</td>
          <td class="paramname"><em>dst</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Multiplies m1 by the transform m2 and stores the result in dst.</p>
<p>Transform multiplication is defined as standard function composition. The transform m2 is on the right. This means that it corresponds to an subsequent transform; transforms are applied left-to-right.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">m1</td><td>The first transform to multiply. </td></tr>
    <tr><td class="paramname">m2</td><td>The second transform to multiply. </td></tr>
    <tr><td class="paramname">dst</td><td>A matrix to store the result in.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A reference to dst for chaining </dd></dl>

</div>
</div>
<a id="a4e9464864c05a7ad213296eb12d6b06c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4e9464864c05a7ad213296eb12d6b06c">&#9670;&nbsp;</a></span>multiply() <span class="overload">[3/9]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="classcugl_1_1_affine2.html">Affine2</a>* cugl::Affine2::multiply </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classcugl_1_1_affine2.html">Affine2</a> &amp;&#160;</td>
          <td class="paramname"><em>m1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classcugl_1_1_mat4.html">Mat4</a> &amp;&#160;</td>
          <td class="paramname"><em>m2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classcugl_1_1_affine2.html">Affine2</a> *&#160;</td>
          <td class="paramname"><em>dst</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Multiplies m1 by the matrix m2 and stores the result in dst.</p>
<p>The matrix m2 is on the right. This means that it corresponds to a subsequent transform, when looking at the order of transforms. The z component of m2 is ignored.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">m1</td><td>The first transform to multiply. </td></tr>
    <tr><td class="paramname">m2</td><td>The second transform to multiply. </td></tr>
    <tr><td class="paramname">dst</td><td>A matrix to store the result in.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A reference to dst for chaining </dd></dl>

</div>
</div>
<a id="a0a0b39bc452cc3747a59171ab342741f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0a0b39bc452cc3747a59171ab342741f">&#9670;&nbsp;</a></span>multiply() <span class="overload">[4/9]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="classcugl_1_1_affine2.html">Affine2</a>* cugl::Affine2::multiply </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classcugl_1_1_affine2.html">Affine2</a> &amp;&#160;</td>
          <td class="paramname"><em>mat</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>scalar</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classcugl_1_1_affine2.html">Affine2</a> *&#160;</td>
          <td class="paramname"><em>dst</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Multiplies the specified transform by a scalar and stores the result in dst.</p>
<p>The scalar is applied to BOTH the core matrix and the offset.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">mat</td><td>The transform. </td></tr>
    <tr><td class="paramname">scalar</td><td>The scalar value. </td></tr>
    <tr><td class="paramname">dst</td><td>A transform to store the result in.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A reference to dst for chaining </dd></dl>

</div>
</div>
<a id="a5ecdb5a5ca58db850ada534d01a01cf3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5ecdb5a5ca58db850ada534d01a01cf3">&#9670;&nbsp;</a></span>multiply() <span class="overload">[5/9]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static float* cugl::Affine2::multiply </td>
          <td>(</td>
          <td class="paramtype">const float *&#160;</td>
          <td class="paramname"><em>m1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const float *&#160;</td>
          <td class="paramname"><em>m2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float *&#160;</td>
          <td class="paramname"><em>dst</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>stride</em> = <code>2</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Multiplies m1 by the transform m2 and stores the result in dst.</p>
<p>Transform multiplication is defined as standard function composition. The transform m2 is on the right. This means that it corresponds to an subsequent transform; transforms are applied left-to-right.</p>
<p>Both of the float arrays should have at least 6-elements where each of the three pairs have the given stride.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">m1</td><td>The first transform to multiply in column major order </td></tr>
    <tr><td class="paramname">m2</td><td>The second transform to multiply in column major order </td></tr>
    <tr><td class="paramname">dst</td><td>A matrix to store the result in column major order </td></tr>
    <tr><td class="paramname">stride</td><td>The pairwise data stride</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A reference to dst for chaining </dd></dl>

</div>
</div>
<a id="aa6648f4c674c6540c977a721b8f5d6f1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa6648f4c674c6540c977a721b8f5d6f1">&#9670;&nbsp;</a></span>multiply() <span class="overload">[6/9]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static float* cugl::Affine2::multiply </td>
          <td>(</td>
          <td class="paramtype">const float *&#160;</td>
          <td class="paramname"><em>mat</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>scalar</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float *&#160;</td>
          <td class="paramname"><em>dst</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>stride</em> = <code>2</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Multiplies the specified transform by a scalar and stores the result in dst.</p>
<p>The scalar is applied to BOTH the core matrix and the offset. Both of the float arrays should have at least 6-elements where each of the three pairs have the given stride.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">mat</td><td>The transform in column major order </td></tr>
    <tr><td class="paramname">scalar</td><td>The scalar value. </td></tr>
    <tr><td class="paramname">dst</td><td>A transform to store the result in column major order </td></tr>
    <tr><td class="paramname">stride</td><td>The pairwise data stride</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A reference to dst for chaining </dd></dl>

</div>
</div>
<a id="ab7eae08e33c85e4e430a68cdea59de99"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab7eae08e33c85e4e430a68cdea59de99">&#9670;&nbsp;</a></span>multiply() <span class="overload">[7/9]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcugl_1_1_affine2.html">Affine2</a>* cugl::Affine2::multiply </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classcugl_1_1_mat4.html">Mat4</a> &amp;&#160;</td>
          <td class="paramname"><em>m1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classcugl_1_1_affine2.html">Affine2</a> &amp;&#160;</td>
          <td class="paramname"><em>m2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classcugl_1_1_affine2.html">Affine2</a> *&#160;</td>
          <td class="paramname"><em>dst</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Multiplies m1 by the matrix m2 and stores the result in dst.</p>
<p>The matrix m2 is on the right. This means that it corresponds to a subsequent transform, when looking at the order of transforms. The z component of m2 is ignored.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">m1</td><td>The first transform to multiply. </td></tr>
    <tr><td class="paramname">m2</td><td>The second transform to multiply. </td></tr>
    <tr><td class="paramname">dst</td><td>A matrix to store the result in.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A reference to dst for chaining </dd></dl>

</div>
</div>
<a id="a5ea3d783a93cc9880a3e4c8862b49de3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5ea3d783a93cc9880a3e4c8862b49de3">&#9670;&nbsp;</a></span>multiply() <span class="overload">[8/9]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcugl_1_1_affine2.html">Affine2</a>&amp; cugl::Affine2::multiply </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classcugl_1_1_mat4.html">Mat4</a> &amp;&#160;</td>
          <td class="paramname"><em>mat</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Multiplies this matrix by the specified one.</p>
<p>The matrix mat is on the right. This means that it corresponds to a subsequent transform, when looking at the order of transforms. The z compoent of mat is ignored.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">mat</td><td>The transform to multiply.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A reference to the <a class="el" href="classcugl_1_1_affine2.html">Affine2</a> after multiplication. </dd></dl>

</div>
</div>
<a id="a52d6387f69944fb7fcd76f2f11ec8ccb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a52d6387f69944fb7fcd76f2f11ec8ccb">&#9670;&nbsp;</a></span>multiply() <span class="overload">[9/9]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcugl_1_1_affine2.html">Affine2</a>&amp; cugl::Affine2::multiply </td>
          <td>(</td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>scalar</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Multiplies the components of this transform by the specified scalar.</p>
<p>The scalar is applied to BOTH the core matrix and the offset.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">scalar</td><td>The scalar value.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A reference to the <a class="el" href="classcugl_1_1_affine2.html">Affine2</a> after multiplication. </dd></dl>

</div>
</div>
<a id="aa5dd65252ef303fabc6374a99650112d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa5dd65252ef303fabc6374a99650112d">&#9670;&nbsp;</a></span>operator Mat4()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">cugl::Affine2::operator <a class="el" href="classcugl_1_1_mat4.html">Mat4</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Cast from <a class="el" href="classcugl_1_1_affine2.html">Affine2</a> to a <a class="el" href="classcugl_1_1_mat4.html">Mat4</a>. </p>

</div>
</div>
<a id="ac0aa5d7cb00a10d260c259d30972199d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac0aa5d7cb00a10d260c259d30972199d">&#9670;&nbsp;</a></span>operator std::string()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">cugl::Affine2::operator std::string </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Cast from <a class="el" href="classcugl_1_1_vec4.html">Vec4</a> to a string. </p>

</div>
</div>
<a id="aba3614aa9022ed81852094c03f5fec09"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aba3614aa9022ed81852094c03f5fec09">&#9670;&nbsp;</a></span>operator!=()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool cugl::Affine2::operator!= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classcugl_1_1_affine2.html">Affine2</a> &amp;&#160;</td>
          <td class="paramname"><em>aff</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns true if this transform is not equal to the given transform.</p>
<p>Comparison is exact, which may be unreliable given that the elements are floats.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">aff</td><td>The transform to compare against.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if this transform is not equal to the given transform. </dd></dl>

</div>
</div>
<a id="a7869daac19f7de0963016bae9ffa3a59"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7869daac19f7de0963016bae9ffa3a59">&#9670;&nbsp;</a></span>operator*() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcugl_1_1_affine2.html">Affine2</a> cugl::Affine2::operator* </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classcugl_1_1_affine2.html">Affine2</a> &amp;&#160;</td>
          <td class="paramname"><em>aff</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns the matrix product of this matrix with the given matrix.</p>
<p>Transform multiplication is defined as standard function composition. The transform aff is on the right. This means that it corresponds to an subsequent transform; transforms are applied left-to-right.</p>
<p>Note: This does not modify the matrix.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">aff</td><td>The transform to multiply by.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the matrix product of this matrix with the given matrix. </dd></dl>

</div>
</div>
<a id="a24bc1c1b2f17b7b82b8c79d01f20ef29"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a24bc1c1b2f17b7b82b8c79d01f20ef29">&#9670;&nbsp;</a></span>operator*() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcugl_1_1_affine2.html">Affine2</a> cugl::Affine2::operator* </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classcugl_1_1_mat4.html">Mat4</a> &amp;&#160;</td>
          <td class="paramname"><em>mat</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns the matrix product of this matrix with the given matrix.</p>
<p>Transform multiplication is defined as standard function composition. The transform aff is on the right. This means that it corresponds to an subsequent transform; transforms are applied left-to-right.</p>
<p>Note: This does not modify the matrix.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">mat</td><td>The transform to multiply by.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the matrix product of this matrix with the given matrix. </dd></dl>

</div>
</div>
<a id="ada987a7773358e1321469499656e0d1e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ada987a7773358e1321469499656e0d1e">&#9670;&nbsp;</a></span>operator*() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcugl_1_1_affine2.html">Affine2</a> cugl::Affine2::operator* </td>
          <td>(</td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>scalar</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns a copy of this matrix with all elements multiplied by the scalar.</p>
<p>The scalar is applied to BOTH the core matrix and the offset.</p>
<p>Note: This does not modify the matrix.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">scalar</td><td>The scalar value.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the product of this transform with the given scalar. </dd></dl>

</div>
</div>
<a id="a44980076db2f8ce759ed8faa8e3cd765"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a44980076db2f8ce759ed8faa8e3cd765">&#9670;&nbsp;</a></span>operator*=() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcugl_1_1_affine2.html">Affine2</a>&amp; cugl::Affine2::operator*= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classcugl_1_1_affine2.html">Affine2</a> &amp;&#160;</td>
          <td class="paramname"><em>aff</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Right-multiplies this transform by the given transform.</p>
<p>Transform multiplication is defined as standard function composition. The transform aff is on the right. This means that it corresponds to an subsequent transform; transforms are applied left-to-right.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">aff</td><td>The transform to multiply by.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A reference to this (modified) <a class="el" href="classcugl_1_1_affine2.html">Affine2</a> for chaining. </dd></dl>

</div>
</div>
<a id="a64bb5aa402b8338aa6d9966b664ab400"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a64bb5aa402b8338aa6d9966b664ab400">&#9670;&nbsp;</a></span>operator*=() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcugl_1_1_affine2.html">Affine2</a>&amp; cugl::Affine2::operator*= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classcugl_1_1_mat4.html">Mat4</a> &amp;&#160;</td>
          <td class="paramname"><em>mat</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Right-multiplies this transform by the given matrix.</p>
<p>The matrix mat is on the right. This means that it corresponds to a subsequent transform, when looking at the order of transforms. The z compoent of mat is ignored.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">mat</td><td>The matrix to multiply by.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A reference to this (modified) <a class="el" href="classcugl_1_1_affine2.html">Affine2</a> for chaining. </dd></dl>

</div>
</div>
<a id="a1dbc0227e613c4aeab18712a5bafda68"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1dbc0227e613c4aeab18712a5bafda68">&#9670;&nbsp;</a></span>operator*=() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcugl_1_1_affine2.html">Affine2</a>&amp; cugl::Affine2::operator*= </td>
          <td>(</td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>scalar</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Multiplies the components of this transform by the specified scalar.</p>
<p>The scalar is applied to BOTH the core matrix and the offset.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">scalar</td><td>The scalar value.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A reference to this (modified) <a class="el" href="classcugl_1_1_affine2.html">Affine2</a> for chaining. </dd></dl>

</div>
</div>
<a id="a4020ac8bf42d53bc503a45c9fbc6a717"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4020ac8bf42d53bc503a45c9fbc6a717">&#9670;&nbsp;</a></span>operator+()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcugl_1_1_affine2.html">Affine2</a> cugl::Affine2::operator+ </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classcugl_1_1_vec2.html">Vec2</a>&#160;</td>
          <td class="paramname"><em>v</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns the sum of this transform with the given offset.</p>
<p>Addition is applied to the offset only; the core matrix is unchanged.</p>
<p>Note: This does not modify the transform.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">v</td><td>The offset to add.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the sum of this transform with the given offset. </dd></dl>

</div>
</div>
<a id="aad621777355d0c7a3e3b910a4bda89f9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aad621777355d0c7a3e3b910a4bda89f9">&#9670;&nbsp;</a></span>operator+=()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcugl_1_1_affine2.html">Affine2</a>&amp; cugl::Affine2::operator+= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classcugl_1_1_vec2.html">Vec2</a>&#160;</td>
          <td class="paramname"><em>v</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Adds the given offset to this transform in place.</p>
<p>Addition is applied to the offset only; the core matrix is unchanged.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">v</td><td>The offset to add</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A reference to this (modified) <a class="el" href="classcugl_1_1_affine2.html">Affine2</a> for chaining. </dd></dl>

</div>
</div>
<a id="a753a56b81197c3794dd5553a3c0bf7ec"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a753a56b81197c3794dd5553a3c0bf7ec">&#9670;&nbsp;</a></span>operator-()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcugl_1_1_affine2.html">Affine2</a> cugl::Affine2::operator- </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classcugl_1_1_vec2.html">Vec2</a>&#160;</td>
          <td class="paramname"><em>v</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns the difference of this matrix with the given offset.</p>
<p>Subtraction is applied to the offset only; the core matrix is unchanged.</p>
<p>Note: This does not modify the transform.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">v</td><td>The offset to subtract.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the difference of this transform and the given offset. </dd></dl>

</div>
</div>
<a id="aaf0d8d25e81f4cbd9c01d9e5273846ca"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaf0d8d25e81f4cbd9c01d9e5273846ca">&#9670;&nbsp;</a></span>operator-=()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcugl_1_1_affine2.html">Affine2</a>&amp; cugl::Affine2::operator-= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classcugl_1_1_vec2.html">Vec2</a>&#160;</td>
          <td class="paramname"><em>v</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Subtracts the given offset from this transform in place.</p>
<p>Subtraction is applied to the offset only; the core matrix is unchanged.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">v</td><td>The offset to subtract</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A reference to this (modified) <a class="el" href="classcugl_1_1_affine2.html">Affine2</a> for chaining. </dd></dl>

</div>
</div>
<a id="a6488ba992de5a72c48523724cb1f30d9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6488ba992de5a72c48523724cb1f30d9">&#9670;&nbsp;</a></span>operator=() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcugl_1_1_affine2.html">Affine2</a>&amp; cugl::Affine2::operator= </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classcugl_1_1_affine2.html">Affine2</a> &amp;&amp;&#160;</td>
          <td class="paramname"><em>mat</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Sets the elements of this matrix to those in the specified one.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">mat</td><td>The matrix to take resources from.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A reference to this (modified) <a class="el" href="classcugl_1_1_mat4.html">Mat4</a> for chaining. </dd></dl>

</div>
</div>
<a id="accc78fab6e7925504813d05d8133b35b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#accc78fab6e7925504813d05d8133b35b">&#9670;&nbsp;</a></span>operator=() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcugl_1_1_affine2.html">Affine2</a>&amp; cugl::Affine2::operator= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classcugl_1_1_affine2.html">Affine2</a> &amp;&#160;</td>
          <td class="paramname"><em>mat</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Sets the elements of this transform to those in the specified transform.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">mat</td><td>The transform to copy.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A reference to this (modified) <a class="el" href="classcugl_1_1_affine2.html">Affine2</a> for chaining. </dd></dl>

</div>
</div>
<a id="ab8d463f5418645f7b54ae1ea46951e95"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab8d463f5418645f7b54ae1ea46951e95">&#9670;&nbsp;</a></span>operator=() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcugl_1_1_affine2.html">Affine2</a>&amp; cugl::Affine2::operator= </td>
          <td>(</td>
          <td class="paramtype">const float *&#160;</td>
          <td class="paramname"><em>array</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Sets the values of this transform to those in the specified column-major array.</p>
<p>The passed-in array is six elements in column-major order, with the last two elements being the translation offset. Hence the memory layout of the array is as follows: </p><pre class="fragment">0   2   4
1   3   5
</pre> <dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">array</td><td>An array containing 6 elements in column-major order.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A reference to this (modified) <a class="el" href="classcugl_1_1_affine2.html">Affine2</a> for chaining. </dd></dl>

</div>
</div>
<a id="a51ae7869d91de19cba43df15791eb41a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a51ae7869d91de19cba43df15791eb41a">&#9670;&nbsp;</a></span>operator=() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcugl_1_1_affine2.html">Affine2</a>&amp; cugl::Affine2::operator= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classcugl_1_1_mat4.html">Mat4</a> &amp;&#160;</td>
          <td class="paramname"><em>mat</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Sets the elements of this transform to those of the given matrix.</p>
<p>The z values are all uniformly ignored. However, it the final element of the matrix is not 1 (e.g. the translation has a w value of 1), then it divides the entire matrix before creating the affine transform</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">mat</td><td>The matrix to convert</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A reference to this (modified) <a class="el" href="classcugl_1_1_affine2.html">Affine2</a> for chaining. </dd></dl>

</div>
</div>
<a id="a0ebf099ed716e529492d20c371f8557a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0ebf099ed716e529492d20c371f8557a">&#9670;&nbsp;</a></span>operator==()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool cugl::Affine2::operator== </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classcugl_1_1_affine2.html">Affine2</a> &amp;&#160;</td>
          <td class="paramname"><em>aff</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns true if this transform is equal to the given transform.</p>
<p>Comparison is exact, which may be unreliable given that the elements are floats. It should only be used to compared transform that have not undergone a lot of manipulation.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">aff</td><td>The transform to compare against.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if this transform is equal to the given transform. </dd></dl>

</div>
</div>
<a id="ab93a31399d061455211ac38aa0df509b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab93a31399d061455211ac38aa0df509b">&#9670;&nbsp;</a></span>rotate() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="classcugl_1_1_affine2.html">Affine2</a>* cugl::Affine2::rotate </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classcugl_1_1_affine2.html">Affine2</a> &amp;&#160;</td>
          <td class="paramname"><em>aff</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>angle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classcugl_1_1_affine2.html">Affine2</a> *&#160;</td>
          <td class="paramname"><em>dst</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Applies a rotation to the given transform and stores the result in dst.</p>
<p>The rotation is in radians, counter-clockwise about the z-axis.</p>
<p>The rotation is applied on the right. Given our convention, that means that it takes place AFTER any previously applied transforms.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">aff</td><td>The transform to rotate. </td></tr>
    <tr><td class="paramname">angle</td><td>The angle (in radians). </td></tr>
    <tr><td class="paramname">dst</td><td>A transform to store the result in.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A reference to dst for chaining </dd></dl>

</div>
</div>
<a id="a5bded7ceec9dd162df4612e30b4a7934"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5bded7ceec9dd162df4612e30b4a7934">&#9670;&nbsp;</a></span>rotate() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static float* cugl::Affine2::rotate </td>
          <td>(</td>
          <td class="paramtype">const float *&#160;</td>
          <td class="paramname"><em>aff</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>angle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float *&#160;</td>
          <td class="paramname"><em>dst</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>stride</em> = <code>2</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Applies a rotation to the given transform and stores the result in dst.</p>
<p>The rotation is in radians, counter-clockwise about the z-axis. Both of the float arrays should have at least 6-elements where each of the three pairs have the given stride.</p>
<p>The rotation is applied on the right. Given our convention, that means that it takes place AFTER any previously applied transforms.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">aff</td><td>The transform to rotate in column major order </td></tr>
    <tr><td class="paramname">angle</td><td>The angle (in radians). </td></tr>
    <tr><td class="paramname">dst</td><td>A transform to store the result in column major order </td></tr>
    <tr><td class="paramname">stride</td><td>The pairwise data stride</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A reference to dst for chaining </dd></dl>

</div>
</div>
<a id="a9023ae447cea2fd1c1d3db512f6ea437"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9023ae447cea2fd1c1d3db512f6ea437">&#9670;&nbsp;</a></span>rotate() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcugl_1_1_affine2.html">Affine2</a>&amp; cugl::Affine2::rotate </td>
          <td>(</td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>angle</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Applies a rotation to this transform.</p>
<p>The rotation is in radians, counter-clockwise about the given axis.</p>
<p>The rotation is applied on the right. Given our convention, that means that it takes place AFTER any previously applied transforms.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">angle</td><td>The angle (in radians).</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>This transform, after rotation. </dd></dl>

</div>
</div>
<a id="a4d359bab497c661e6040f7c97de9ab6b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4d359bab497c661e6040f7c97de9ab6b">&#9670;&nbsp;</a></span>scale() <span class="overload">[1/9]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="classcugl_1_1_affine2.html">Affine2</a>* cugl::Affine2::scale </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classcugl_1_1_affine2.html">Affine2</a> &amp;&#160;</td>
          <td class="paramname"><em>aff</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classcugl_1_1_vec2.html">Vec2</a>&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classcugl_1_1_affine2.html">Affine2</a> *&#160;</td>
          <td class="paramname"><em>dst</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Applies a non-uniform scale to the given transform and stores the result in dst.</p>
<p>The scaling operation is applied on the right. Given our convention, that means that it takes place AFTER any previously applied transforms.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">aff</td><td>The transform to scale. </td></tr>
    <tr><td class="paramname">s</td><td>The vector storing the individual scaling factors </td></tr>
    <tr><td class="paramname">dst</td><td>A transform to store the result in.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A reference to dst for chaining </dd></dl>

</div>
</div>
<a id="a117a0e82c455b939cb393032e1a1cfb7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a117a0e82c455b939cb393032e1a1cfb7">&#9670;&nbsp;</a></span>scale() <span class="overload">[2/9]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="classcugl_1_1_affine2.html">Affine2</a>* cugl::Affine2::scale </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classcugl_1_1_affine2.html">Affine2</a> &amp;&#160;</td>
          <td class="paramname"><em>aff</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>sx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>sy</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classcugl_1_1_affine2.html">Affine2</a> *&#160;</td>
          <td class="paramname"><em>dst</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Applies a non-uniform scale to the given transform and stores the result in dst.</p>
<p>The scaling operation is applied on the right. Given our convention, that means that it takes place AFTER any previously applied transforms.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">aff</td><td>The transform to scale. </td></tr>
    <tr><td class="paramname">sx</td><td>The amount to scale along the x-axis. </td></tr>
    <tr><td class="paramname">sy</td><td>The amount to scale along the y-axis. </td></tr>
    <tr><td class="paramname">dst</td><td>A transform to store the result in.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A reference to dst for chaining </dd></dl>

</div>
</div>
<a id="a7227ee03e3435e83e02420c9ae316bf2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7227ee03e3435e83e02420c9ae316bf2">&#9670;&nbsp;</a></span>scale() <span class="overload">[3/9]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="classcugl_1_1_affine2.html">Affine2</a>* cugl::Affine2::scale </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classcugl_1_1_affine2.html">Affine2</a> &amp;&#160;</td>
          <td class="paramname"><em>aff</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classcugl_1_1_affine2.html">Affine2</a> *&#160;</td>
          <td class="paramname"><em>dst</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Applies a uniform scale to the given transform and stores the result in dst.</p>
<p>The scaling operation is applied on the right. Given our convention, that means that it takes place AFTER any previously applied transforms.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">aff</td><td>The transform to scale. </td></tr>
    <tr><td class="paramname">value</td><td>The scalar to multiply by. </td></tr>
    <tr><td class="paramname">dst</td><td>A transform to store the result in.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A reference to dst for chaining </dd></dl>

</div>
</div>
<a id="ad47245c0c51135cb26286f02e4a92400"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad47245c0c51135cb26286f02e4a92400">&#9670;&nbsp;</a></span>scale() <span class="overload">[4/9]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static float* cugl::Affine2::scale </td>
          <td>(</td>
          <td class="paramtype">const float *&#160;</td>
          <td class="paramname"><em>aff</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classcugl_1_1_vec2.html">Vec2</a>&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float *&#160;</td>
          <td class="paramname"><em>dst</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>stride</em> = <code>2</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Applies a non-uniform scale to the given transform and stores the result in dst.</p>
<p>Both of the float arrays should have at least 6-elements where each of the three pairs have the given stride.</p>
<p>The scaling operation is applied on the right. Given our convention, that means that it takes place AFTER any previously applied transforms.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">aff</td><td>The transform to scale in column major order </td></tr>
    <tr><td class="paramname">s</td><td>The vector storing the individual scaling factors </td></tr>
    <tr><td class="paramname">dst</td><td>A transform to store the result in column major order </td></tr>
    <tr><td class="paramname">stride</td><td>The pairwise data stride</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A reference to dst for chaining </dd></dl>

</div>
</div>
<a id="a67fcaa8fa03869283d236e92e40fa0fc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a67fcaa8fa03869283d236e92e40fa0fc">&#9670;&nbsp;</a></span>scale() <span class="overload">[5/9]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static float* cugl::Affine2::scale </td>
          <td>(</td>
          <td class="paramtype">const float *&#160;</td>
          <td class="paramname"><em>aff</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>sx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>sy</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float *&#160;</td>
          <td class="paramname"><em>dst</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>stride</em> = <code>2</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Applies a non-uniform scale to the given transform and stores the result in dst.</p>
<p>Both of the float arrays should have at least 6-elements where each of the three pairs have the given stride.</p>
<p>The scaling operation is applied on the right. Given our convention, that means that it takes place AFTER any previously applied transforms.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">aff</td><td>The transform to scale in column major order </td></tr>
    <tr><td class="paramname">sx</td><td>The amount to scale along the x-axis. </td></tr>
    <tr><td class="paramname">sy</td><td>The amount to scale along the y-axis. </td></tr>
    <tr><td class="paramname">dst</td><td>A transform to store the result in column major order </td></tr>
    <tr><td class="paramname">stride</td><td>The pairwise data stride</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A reference to dst for chaining </dd></dl>

</div>
</div>
<a id="a579f2e48effd1624ff6cb11524225b3a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a579f2e48effd1624ff6cb11524225b3a">&#9670;&nbsp;</a></span>scale() <span class="overload">[6/9]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static float* cugl::Affine2::scale </td>
          <td>(</td>
          <td class="paramtype">const float *&#160;</td>
          <td class="paramname"><em>aff</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float *&#160;</td>
          <td class="paramname"><em>dst</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>stride</em> = <code>2</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Applies a uniform scale to the given transform and stores the result in dst.</p>
<p>Both of the float arrays should have at least 6-elements where each of the three pairs have the given stride.</p>
<p>The scaling operation is applied on the right. Given our convention, that means that it takes place AFTER any previously applied transforms.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">aff</td><td>The transform to scale in column major order </td></tr>
    <tr><td class="paramname">value</td><td>The scalar to multiply by. </td></tr>
    <tr><td class="paramname">dst</td><td>A transform to store the result in column major order </td></tr>
    <tr><td class="paramname">stride</td><td>The pairwise data stride</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A reference to dst for chaining </dd></dl>

</div>
</div>
<a id="a5581e28d0d48e522f10b902f803c6960"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5581e28d0d48e522f10b902f803c6960">&#9670;&nbsp;</a></span>scale() <span class="overload">[7/9]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcugl_1_1_affine2.html">Affine2</a>&amp; cugl::Affine2::scale </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classcugl_1_1_vec2.html">Vec2</a>&#160;</td>
          <td class="paramname"><em>s</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Applies a non-uniform scale to this transform.</p>
<p>The scaling operation is applied on the right. Given our convention, that means that it takes place AFTER any previously applied transforms.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">s</td><td>The vector storing the individual scaling factors</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>This transform, after scaling. </dd></dl>

</div>
</div>
<a id="a9bc0c20b4ee6f8ca381dcd51a82d0f5c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9bc0c20b4ee6f8ca381dcd51a82d0f5c">&#9670;&nbsp;</a></span>scale() <span class="overload">[8/9]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcugl_1_1_affine2.html">Affine2</a>&amp; cugl::Affine2::scale </td>
          <td>(</td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>sx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>sy</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Applies a non-uniform scale to this transform.</p>
<p>The scaling operation is applied on the right. Given our convention, that means that it takes place AFTER any previously applied transforms.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">sx</td><td>The amount to scale along the x-axis. </td></tr>
    <tr><td class="paramname">sy</td><td>The amount to scale along the y-axis.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>This transform, after scaling. </dd></dl>

</div>
</div>
<a id="a6174a8cc971ac1ddddb4f83be35f7328"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6174a8cc971ac1ddddb4f83be35f7328">&#9670;&nbsp;</a></span>scale() <span class="overload">[9/9]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcugl_1_1_affine2.html">Affine2</a>&amp; cugl::Affine2::scale </td>
          <td>(</td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>value</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Applies a uniform scale to this transform.</p>
<p>The scaling operation is applied on the right. Given our convention, that means that it takes place AFTER any previously applied transforms.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">value</td><td>The scalar to multiply by.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>This transform, after scaling. </dd></dl>

</div>
</div>
<a id="add02033567fa0f676563557c689e5039"></a>
<h2 class="memtitle"><span class="permalink"><a href="#add02033567fa0f676563557c689e5039">&#9670;&nbsp;</a></span>set() <span class="overload">[1/5]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcugl_1_1_affine2.html">Affine2</a>&amp; cugl::Affine2::set </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classcugl_1_1_affine2.html">Affine2</a> &amp;&#160;</td>
          <td class="paramname"><em>mat</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Sets the elements of this transform to those in the specified transform.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">mat</td><td>The transform to copy.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A reference to this (modified) <a class="el" href="classcugl_1_1_affine2.html">Affine2</a> for chaining. </dd></dl>

</div>
</div>
<a id="af278299eff6733d7c28199aca350fc3e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af278299eff6733d7c28199aca350fc3e">&#9670;&nbsp;</a></span>set() <span class="overload">[2/5]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcugl_1_1_affine2.html">Affine2</a>&amp; cugl::Affine2::set </td>
          <td>(</td>
          <td class="paramtype">const float *&#160;</td>
          <td class="paramname"><em>mat</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Sets the values of this transform to those in the specified column-major array.</p>
<p>The passed-in array is six elements in column-major order, with the last two elements being the translation offset. Hence the memory layout of the array is as follows: </p><pre class="fragment">0   2   4
1   3   5
</pre> <dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">mat</td><td>An array containing 6 elements in column-major order.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A reference to this (modified) <a class="el" href="classcugl_1_1_affine2.html">Affine2</a> for chaining. </dd></dl>

</div>
</div>
<a id="aae626e2a19203d00e66c8df7c3336c57"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aae626e2a19203d00e66c8df7c3336c57">&#9670;&nbsp;</a></span>set() <span class="overload">[3/5]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcugl_1_1_affine2.html">Affine2</a>&amp; cugl::Affine2::set </td>
          <td>(</td>
          <td class="paramtype">const float *&#160;</td>
          <td class="paramname"><em>mat</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>stride</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Sets the values of this transform to those in the specified column-major array.</p>
<p>The passed-in array is six elements grouped in pairs, with each pair separated by a stride. For example, if stride is 4, then mat is a 12-element array with the first column at 0,1, the second column at 4,5 and the translation component at 8,9.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">mat</td><td>An array containing elements in column-major order. </td></tr>
    <tr><td class="paramname">stride</td><td>The pairwise data stride</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A reference to this (modified) <a class="el" href="classcugl_1_1_affine2.html">Affine2</a> for chaining. </dd></dl>

</div>
</div>
<a id="a0e77b5955070cae1f4d600f1dd4ced53"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0e77b5955070cae1f4d600f1dd4ced53">&#9670;&nbsp;</a></span>set() <span class="overload">[4/5]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcugl_1_1_affine2.html">Affine2</a>&amp; cugl::Affine2::set </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classcugl_1_1_mat4.html">Mat4</a> &amp;&#160;</td>
          <td class="paramname"><em>mat</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Sets the elements of this transform to those of the given matrix.</p>
<p>The z values are all uniformly ignored. However, it the final element of the matrix is not 1 (e.g. the translation has a w value of 1), then it divides the entire matrix before creating the affine transform</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">mat</td><td>The matrix to convert</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A reference to this (modified) <a class="el" href="classcugl_1_1_affine2.html">Affine2</a> for chaining. </dd></dl>

</div>
</div>
<a id="afccaf334303ae3e95b208b9af65d328e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afccaf334303ae3e95b208b9af65d328e">&#9670;&nbsp;</a></span>set() <span class="overload">[5/5]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcugl_1_1_affine2.html">Affine2</a>&amp; cugl::Affine2::set </td>
          <td>(</td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>m11</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>m12</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>m21</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>m22</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>tx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>ty</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Sets the individal values of this transform.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">m11</td><td>The first element of the first row. </td></tr>
    <tr><td class="paramname">m12</td><td>The second element of the first row. </td></tr>
    <tr><td class="paramname">m21</td><td>The first element of the second row. </td></tr>
    <tr><td class="paramname">m22</td><td>The second element of the second row. </td></tr>
    <tr><td class="paramname">tx</td><td>The translation offset for the x-coordinate. </td></tr>
    <tr><td class="paramname">ty</td><td>The translation offset for the y-coordinate.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A reference to this (modified) <a class="el" href="classcugl_1_1_affine2.html">Affine2</a> for chaining. </dd></dl>

</div>
</div>
<a id="acd01e54686c9af28b75ccd200cfd3dd3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acd01e54686c9af28b75ccd200cfd3dd3">&#9670;&nbsp;</a></span>setIdentity()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcugl_1_1_affine2.html">Affine2</a>&amp; cugl::Affine2::setIdentity </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Sets this transform to the identity transform.</p>
<dl class="section return"><dt>Returns</dt><dd>A reference to this (modified) <a class="el" href="classcugl_1_1_affine2.html">Affine2</a> for chaining. </dd></dl>

</div>
</div>
<a id="adc6f551ca7edcaecaad777b2811d7c82"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adc6f551ca7edcaecaad777b2811d7c82">&#9670;&nbsp;</a></span>setZero()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcugl_1_1_affine2.html">Affine2</a>&amp; cugl::Affine2::setZero </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Sets all elements of the current transform to zero.</p>
<dl class="section return"><dt>Returns</dt><dd>A reference to this (modified) <a class="el" href="classcugl_1_1_affine2.html">Affine2</a> for chaining. </dd></dl>

</div>
</div>
<a id="a7764131775d3cbc4c6fb544963f0a46d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7764131775d3cbc4c6fb544963f0a46d">&#9670;&nbsp;</a></span>subtract() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="classcugl_1_1_affine2.html">Affine2</a>* cugl::Affine2::subtract </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classcugl_1_1_affine2.html">Affine2</a> &amp;&#160;</td>
          <td class="paramname"><em>m1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classcugl_1_1_vec2.html">Vec2</a>&#160;</td>
          <td class="paramname"><em>v</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classcugl_1_1_affine2.html">Affine2</a> *&#160;</td>
          <td class="paramname"><em>dst</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Subtracts the offset v from m and stores the result in dst.</p>
<p>Subtraction is applied to the offset only; the core matrix is unchanged.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">m1</td><td>The initial transform. </td></tr>
    <tr><td class="paramname">v</td><td>The offset to subtract. </td></tr>
    <tr><td class="paramname">dst</td><td>A transform to store the result in.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A reference to dst for chaining </dd></dl>

</div>
</div>
<a id="a93c9ffcc42b0e0937604abed0bd75aa9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a93c9ffcc42b0e0937604abed0bd75aa9">&#9670;&nbsp;</a></span>subtract() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static float* cugl::Affine2::subtract </td>
          <td>(</td>
          <td class="paramtype">const float *&#160;</td>
          <td class="paramname"><em>m1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classcugl_1_1_vec2.html">Vec2</a>&#160;</td>
          <td class="paramname"><em>v</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float *&#160;</td>
          <td class="paramname"><em>dst</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>stride</em> = <code>2</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Subtracts the offset v from m and stores the result in dst.</p>
<p>Subtraction is applied to the offset only; the core matrix is unchanged. Both of the float arrays should have at least 6-elements where each of the three pairs have the given stride.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">m1</td><td>The initial transform in column major order </td></tr>
    <tr><td class="paramname">v</td><td>The offset to subtract. </td></tr>
    <tr><td class="paramname">dst</td><td>A transform to store the result in column major order </td></tr>
    <tr><td class="paramname">stride</td><td>The pairwise data stride</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A reference to dst for chaining </dd></dl>

</div>
</div>
<a id="a2613d3591e583e73e1c0c611b44f11b7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2613d3591e583e73e1c0c611b44f11b7">&#9670;&nbsp;</a></span>subtract() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcugl_1_1_affine2.html">Affine2</a>&amp; cugl::Affine2::subtract </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classcugl_1_1_vec2.html">Vec2</a>&#160;</td>
          <td class="paramname"><em>v</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Subtracts the specified offset from the current transform.</p>
<p>Subtraction is applied to the offset only; the core matrix is unchanged.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">v</td><td>The offset to subtract.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A reference to the <a class="el" href="classcugl_1_1_affine2.html">Affine2</a> after subtraction. </dd></dl>

</div>
</div>
<a id="a2e320f84f61281bfb460dabd44889bb7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2e320f84f61281bfb460dabd44889bb7">&#9670;&nbsp;</a></span>toString()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string cugl::Affine2::toString </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>verbose</em> = <code>false</code></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns a string representation of this transform for debugging purposes.</p>
<p>If verbose is true, the string will include class information. This allows us to unambiguously identify the class.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">verbose</td><td>Whether to include class information</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a string representation of this transform for debugging purposes. </dd></dl>

</div>
</div>
<a id="a713917416f9502b2ed1ebe7036fb4daa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a713917416f9502b2ed1ebe7036fb4daa">&#9670;&nbsp;</a></span>transform() <span class="overload">[1/5]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="classcugl_1_1_rect.html">Rect</a>* cugl::Affine2::transform </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classcugl_1_1_affine2.html">Affine2</a> &amp;&#160;</td>
          <td class="paramname"><em>aff</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classcugl_1_1_rect.html">Rect</a>&#160;</td>
          <td class="paramname"><em>rect</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classcugl_1_1_rect.html">Rect</a> *&#160;</td>
          <td class="paramname"><em>dst</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Transforms the rectangle and stores the result in dst.</p>
<p>This method transforms the four defining points of the rectangle. It then computes the minimal bounding box storing these four points</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">aff</td><td>The affine transform. </td></tr>
    <tr><td class="paramname">rect</td><td>The rect to transform. </td></tr>
    <tr><td class="paramname">dst</td><td>A rect to store the transformed rectangle in.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A reference to dst for chaining </dd></dl>

</div>
</div>
<a id="a66d1df3ac53032a47d7900d6ba84a173"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a66d1df3ac53032a47d7900d6ba84a173">&#9670;&nbsp;</a></span>transform() <span class="overload">[2/5]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="classcugl_1_1_vec2.html">Vec2</a>* cugl::Affine2::transform </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classcugl_1_1_affine2.html">Affine2</a> &amp;&#160;</td>
          <td class="paramname"><em>aff</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classcugl_1_1_vec2.html">Vec2</a>&#160;</td>
          <td class="paramname"><em>point</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classcugl_1_1_vec2.html">Vec2</a> *&#160;</td>
          <td class="paramname"><em>dst</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Transforms the point and stores the result in dst.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">aff</td><td>The affine transform. </td></tr>
    <tr><td class="paramname">point</td><td>The point to transform. </td></tr>
    <tr><td class="paramname">dst</td><td>A vector to store the transformed point in.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A reference to dst for chaining </dd></dl>

</div>
</div>
<a id="a1112dd1713f6ecf3c6aa131fd9828791"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1112dd1713f6ecf3c6aa131fd9828791">&#9670;&nbsp;</a></span>transform() <span class="overload">[3/5]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static float* cugl::Affine2::transform </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classcugl_1_1_affine2.html">Affine2</a> &amp;&#160;</td>
          <td class="paramname"><em>aff</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float const *&#160;</td>
          <td class="paramname"><em>input</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float *&#160;</td>
          <td class="paramname"><em>output</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Transforms the vector array, and stores the result in dst.</p>
<p>The vector is array is treated as a list of 2 element vectors (</p><dl class="section see"><dt>See also</dt><dd><a class="el" href="classcugl_1_1_vec2.html">Vec2</a>). The <a class="el" href="classcugl_1_1_affine2.html#a66d1df3ac53032a47d7900d6ba84a173">transform</a> is applied in order and written to the output array.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">aff</td><td>The transform matrix. </td></tr>
    <tr><td class="paramname">input</td><td>The array of vectors to transform. </td></tr>
    <tr><td class="paramname">output</td><td>The array to store the transformed vectors. </td></tr>
    <tr><td class="paramname">size</td><td>The size of the two arrays.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A reference to dst for chaining </dd></dl>

</div>
</div>
<a id="a2539597763eb5761ff8b1d00e484bef3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2539597763eb5761ff8b1d00e484bef3">&#9670;&nbsp;</a></span>transform() <span class="overload">[4/5]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcugl_1_1_rect.html">Rect</a> cugl::Affine2::transform </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classcugl_1_1_rect.html">Rect</a>&#160;</td>
          <td class="paramname"><em>rect</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns a copy of the given rectangle transformed.</p>
<p>This method transforms the four defining points of the rectangle. It then computes the minimal bounding box storing these four points</p>
<p>Note: This does not modify the original rectangle. To transform a point in place, use the static method.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">rect</td><td>The rect to transform.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A reference to dst for chaining </dd></dl>

</div>
</div>
<a id="a8d25a863f515dca681cd2ebaf417b4da"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8d25a863f515dca681cd2ebaf417b4da">&#9670;&nbsp;</a></span>transform() <span class="overload">[5/5]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcugl_1_1_vec2.html">Vec2</a> cugl::Affine2::transform </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classcugl_1_1_vec2.html">Vec2</a>&#160;</td>
          <td class="paramname"><em>point</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns a copy of the given point transformed.</p>
<p>Note: This does not modify the original point. To transform a point in place, use the static method (or the appropriate operator).</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">point</td><td>The point to transform.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a copy of this point transformed. </dd></dl>

</div>
</div>
<a id="a361b171ef04d9cf85d858a5bca15df6a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a361b171ef04d9cf85d858a5bca15df6a">&#9670;&nbsp;</a></span>translate() <span class="overload">[1/6]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="classcugl_1_1_affine2.html">Affine2</a>* cugl::Affine2::translate </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classcugl_1_1_affine2.html">Affine2</a> &amp;&#160;</td>
          <td class="paramname"><em>aff</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classcugl_1_1_vec2.html">Vec2</a>&#160;</td>
          <td class="paramname"><em>t</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classcugl_1_1_affine2.html">Affine2</a> *&#160;</td>
          <td class="paramname"><em>dst</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Applies a translation to the given transform and stores the result in dst.</p>
<p>The translation operation is applied on the right. Given our convention, that means that it takes place AFTER any previously applied transforms.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">aff</td><td>The transform to translate. </td></tr>
    <tr><td class="paramname">t</td><td>The vector storing the individual translation offsets </td></tr>
    <tr><td class="paramname">dst</td><td>A transform to store the result in.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A reference to dst for chaining </dd></dl>

</div>
</div>
<a id="af8a88b03c8c38cb2f6fd611edfa7346d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af8a88b03c8c38cb2f6fd611edfa7346d">&#9670;&nbsp;</a></span>translate() <span class="overload">[2/6]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="classcugl_1_1_affine2.html">Affine2</a>* cugl::Affine2::translate </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classcugl_1_1_affine2.html">Affine2</a> &amp;&#160;</td>
          <td class="paramname"><em>aff</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>tx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>ty</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classcugl_1_1_affine2.html">Affine2</a> *&#160;</td>
          <td class="paramname"><em>dst</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Applies a translation to the given transform and stores the result in dst.</p>
<p>The translation operation is applied on the right. Given our convention, that means that it takes place AFTER any previously applied transforms.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">aff</td><td>The transform to translate. </td></tr>
    <tr><td class="paramname">tx</td><td>The translation offset for the x-axis. </td></tr>
    <tr><td class="paramname">ty</td><td>The translation offset for the y-axis. </td></tr>
    <tr><td class="paramname">dst</td><td>A transform to store the result in.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A reference to dst for chaining </dd></dl>

</div>
</div>
<a id="afb1d13a4faf20426c7c288c9fb0429ea"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afb1d13a4faf20426c7c288c9fb0429ea">&#9670;&nbsp;</a></span>translate() <span class="overload">[3/6]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static float* cugl::Affine2::translate </td>
          <td>(</td>
          <td class="paramtype">const float *&#160;</td>
          <td class="paramname"><em>aff</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classcugl_1_1_vec2.html">Vec2</a>&#160;</td>
          <td class="paramname"><em>t</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float *&#160;</td>
          <td class="paramname"><em>dst</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>stride</em> = <code>2</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Applies a translation to the given transform and stores the result in dst.</p>
<p>Both of the float arrays should have at least 6-elements where each of the three pairs have the given stride.</p>
<p>The translation operation is applied on the right. Given our convention, that means that it takes place AFTER any previously applied transforms.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">aff</td><td>The transform to translate in column major order </td></tr>
    <tr><td class="paramname">t</td><td>The vector storing the individual translation offsets </td></tr>
    <tr><td class="paramname">dst</td><td>A transform to store the result in column major order </td></tr>
    <tr><td class="paramname">stride</td><td>The pairwise data stride</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A reference to dst for chaining </dd></dl>

</div>
</div>
<a id="aa4d61a865a27fa3609a93f3b12732a0d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa4d61a865a27fa3609a93f3b12732a0d">&#9670;&nbsp;</a></span>translate() <span class="overload">[4/6]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static float* cugl::Affine2::translate </td>
          <td>(</td>
          <td class="paramtype">const float *&#160;</td>
          <td class="paramname"><em>aff</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>tx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>ty</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float *&#160;</td>
          <td class="paramname"><em>dst</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>stride</em> = <code>2</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Applies a translation to the given transform and stores the result in dst.</p>
<p>Both of the float arrays should have at least 6-elements where each of the three pairs have the given stride.</p>
<p>The translation operation is applied on the right. Given our convention, that means that it takes place AFTER any previously applied transforms.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">aff</td><td>The transform to translate in column major order </td></tr>
    <tr><td class="paramname">tx</td><td>The translation offset for the x-axis. </td></tr>
    <tr><td class="paramname">ty</td><td>The translation offset for the y-axis. </td></tr>
    <tr><td class="paramname">dst</td><td>A transform to store the result in column major order </td></tr>
    <tr><td class="paramname">stride</td><td>The pairwise data stride</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A reference to dst for chaining </dd></dl>

</div>
</div>
<a id="acf48b7d1a8042f09d627b8ed03c253ae"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acf48b7d1a8042f09d627b8ed03c253ae">&#9670;&nbsp;</a></span>translate() <span class="overload">[5/6]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcugl_1_1_affine2.html">Affine2</a>&amp; cugl::Affine2::translate </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classcugl_1_1_vec2.html">Vec2</a>&#160;</td>
          <td class="paramname"><em>t</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Applies a translation to this transform.</p>
<p>The translation operation is applied on the right. Given our convention, that means that it takes place AFTER any previously applied transforms.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">t</td><td>The vector storing the individual translation offsets</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>This transform, after translation. </dd></dl>

</div>
</div>
<a id="a7e30c145c1d2ec95c052f3154d6f1b8f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7e30c145c1d2ec95c052f3154d6f1b8f">&#9670;&nbsp;</a></span>translate() <span class="overload">[6/6]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcugl_1_1_affine2.html">Affine2</a>&amp; cugl::Affine2::translate </td>
          <td>(</td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>tx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>ty</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Applies a translation to this transform.</p>
<p>The translation operation is applied on the right. Given our convention, that means that it takes place AFTER any previously applied transforms.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">tx</td><td>The translation offset for the x-axis. </td></tr>
    <tr><td class="paramname">ty</td><td>The translation offset for the y-axis.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>This transform, after translation. </dd></dl>

</div>
</div>
<h2 class="groupheader">Member Data Documentation</h2>
<a id="aefdf7abfee94c17467aac4ee96610917"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aefdf7abfee94c17467aac4ee96610917">&#9670;&nbsp;</a></span>IDENTITY</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classcugl_1_1_affine2.html">Affine2</a> cugl::Affine2::IDENTITY</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>The identity transform (ones on the diagonal) </p>

</div>
</div>
<a id="aa79b0aa7e82dfb4a4e55f21e46cf92e6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa79b0aa7e82dfb4a4e55f21e46cf92e6">&#9670;&nbsp;</a></span>m</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">float cugl::Affine2::m[6]</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>The condensed affine matrix </p>

</div>
</div>
<a id="a89d528a1f040fa2769cf93d1b8ef58dc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a89d528a1f040fa2769cf93d1b8ef58dc">&#9670;&nbsp;</a></span>ONE</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classcugl_1_1_affine2.html">Affine2</a> cugl::Affine2::ONE</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>The transform with all ones </p>

</div>
</div>
<a id="ae026a9986f11addd15e11f4c2529cef7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae026a9986f11addd15e11f4c2529cef7">&#9670;&nbsp;</a></span>ZERO</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classcugl_1_1_affine2.html">Affine2</a> cugl::Affine2::ZERO</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>The transform with all zeroes </p>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>include/cugl/math/<a class="el" href="_c_u_affine2_8h_source.html">CUAffine2.h</a></li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.1
</small></address>
</body>
</html>
