<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.9.1"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>CUGL 2.0: cugl::AudioDevices Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">CUGL 2.0
   </div>
   <div id="projectbrief">Cornell University Game Library</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.1 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search','.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespacecugl.html">cugl</a></li><li class="navelem"><a class="el" href="classcugl_1_1_audio_devices.html">AudioDevices</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-static-methods">Static Public Member Functions</a> &#124;
<a href="#pub-static-attribs">Static Public Attributes</a> &#124;
<a href="classcugl_1_1_audio_devices-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">cugl::AudioDevices Class Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p><code>#include &lt;<a class="el" href="_c_u_audio_devices_8h_source.html">CUAudioDevices.h</a>&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:aa5ff5ee2d9082beb885512513f985a00"><td class="memItemLeft" align="right" valign="top">Uint32&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1_audio_devices.html#aa5ff5ee2d9082beb885512513f985a00">getReadSize</a> () const</td></tr>
<tr class="separator:aa5ff5ee2d9082beb885512513f985a00"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4c87960ba67e85e78877f0685cfc34ef"><td class="memItemLeft" align="right" valign="top">Uint32&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1_audio_devices.html#a4c87960ba67e85e78877f0685cfc34ef">getWriteSize</a> () const</td></tr>
<tr class="separator:a4c87960ba67e85e78877f0685cfc34ef"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6971a9ab635a847428e1ae7bc3999102"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1_audio_devices.html#a6971a9ab635a847428e1ae7bc3999102">isActive</a> ()</td></tr>
<tr class="separator:a6971a9ab635a847428e1ae7bc3999102"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa7a694ece032657409b0e6db13e121b9"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1_audio_devices.html#aa7a694ece032657409b0e6db13e121b9">activate</a> ()</td></tr>
<tr class="separator:aa7a694ece032657409b0e6db13e121b9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeee4dca4084481aa67bce39a8268e942"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1_audio_devices.html#aeee4dca4084481aa67bce39a8268e942">deactivate</a> ()</td></tr>
<tr class="separator:aeee4dca4084481aa67bce39a8268e942"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a66df05a74167716acdf1f9a35c453123"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1_audio_devices.html#a66df05a74167716acdf1f9a35c453123">reset</a> ()</td></tr>
<tr class="separator:a66df05a74167716acdf1f9a35c453123"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af6cd9d932978d8e1f05c6ac30009a548"><td class="memItemLeft" align="right" valign="top">std::shared_ptr&lt; <a class="el" href="classcugl_1_1audio_1_1_audio_output.html">audio::AudioOutput</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1_audio_devices.html#af6cd9d932978d8e1f05c6ac30009a548">openOutput</a> ()</td></tr>
<tr class="separator:af6cd9d932978d8e1f05c6ac30009a548"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a97ffb75210063d0745321807c8f60ffa"><td class="memItemLeft" align="right" valign="top">std::shared_ptr&lt; <a class="el" href="classcugl_1_1audio_1_1_audio_output.html">audio::AudioOutput</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1_audio_devices.html#a97ffb75210063d0745321807c8f60ffa">openOutput</a> (Uint8 channels, Uint32 rate)</td></tr>
<tr class="separator:a97ffb75210063d0745321807c8f60ffa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac01c4e33bd886460c7d7d99d887e6bc2"><td class="memItemLeft" align="right" valign="top">std::shared_ptr&lt; <a class="el" href="classcugl_1_1audio_1_1_audio_output.html">audio::AudioOutput</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1_audio_devices.html#ac01c4e33bd886460c7d7d99d887e6bc2">openOutput</a> (const char *device)</td></tr>
<tr class="separator:ac01c4e33bd886460c7d7d99d887e6bc2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7a0c9d5a496f9e8da1b015234493d85d"><td class="memItemLeft" align="right" valign="top">std::shared_ptr&lt; <a class="el" href="classcugl_1_1audio_1_1_audio_output.html">audio::AudioOutput</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1_audio_devices.html#a7a0c9d5a496f9e8da1b015234493d85d">openOutput</a> (const std::string &amp;device)</td></tr>
<tr class="separator:a7a0c9d5a496f9e8da1b015234493d85d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5f47ddc14c3ddb504bad3b988a67e2af"><td class="memItemLeft" align="right" valign="top">std::shared_ptr&lt; <a class="el" href="classcugl_1_1audio_1_1_audio_output.html">audio::AudioOutput</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1_audio_devices.html#a5f47ddc14c3ddb504bad3b988a67e2af">openOutput</a> (const char *device, Uint8 channels, Uint32 rate)</td></tr>
<tr class="separator:a5f47ddc14c3ddb504bad3b988a67e2af"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad4eb3b4554481797223224200c9df36e"><td class="memItemLeft" align="right" valign="top">std::shared_ptr&lt; <a class="el" href="classcugl_1_1audio_1_1_audio_output.html">audio::AudioOutput</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1_audio_devices.html#ad4eb3b4554481797223224200c9df36e">openOutput</a> (const std::string &amp;device, Uint8 channels, Uint32 rate)</td></tr>
<tr class="separator:ad4eb3b4554481797223224200c9df36e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abc7936a32599044b77642c70fcdabbfc"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1_audio_devices.html#abc7936a32599044b77642c70fcdabbfc">closeOutput</a> (const std::shared_ptr&lt; <a class="el" href="classcugl_1_1audio_1_1_audio_output.html">audio::AudioOutput</a> &gt; &amp;device)</td></tr>
<tr class="separator:abc7936a32599044b77642c70fcdabbfc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4cae0ad8078ff4bbe563c1606a11fcfd"><td class="memItemLeft" align="right" valign="top">std::shared_ptr&lt; <a class="el" href="classcugl_1_1audio_1_1_audio_input.html">audio::AudioInput</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1_audio_devices.html#a4cae0ad8078ff4bbe563c1606a11fcfd">openInput</a> ()</td></tr>
<tr class="separator:a4cae0ad8078ff4bbe563c1606a11fcfd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4ee5d85360993437e81bd52ae0b69902"><td class="memItemLeft" align="right" valign="top">std::shared_ptr&lt; <a class="el" href="classcugl_1_1audio_1_1_audio_input.html">audio::AudioInput</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1_audio_devices.html#a4ee5d85360993437e81bd52ae0b69902">openInput</a> (Uint8 channels, Uint32 rate, Uint32 delay)</td></tr>
<tr class="separator:a4ee5d85360993437e81bd52ae0b69902"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5788d67ca306fc24d6e3eb55a3c7b473"><td class="memItemLeft" align="right" valign="top">std::shared_ptr&lt; <a class="el" href="classcugl_1_1audio_1_1_audio_input.html">audio::AudioInput</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1_audio_devices.html#a5788d67ca306fc24d6e3eb55a3c7b473">openInput</a> (const char *device)</td></tr>
<tr class="separator:a5788d67ca306fc24d6e3eb55a3c7b473"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9edc5c2466efd19638b04b0c8463aa56"><td class="memItemLeft" align="right" valign="top">std::shared_ptr&lt; <a class="el" href="classcugl_1_1audio_1_1_audio_input.html">audio::AudioInput</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1_audio_devices.html#a9edc5c2466efd19638b04b0c8463aa56">openInput</a> (const std::string &amp;device)</td></tr>
<tr class="separator:a9edc5c2466efd19638b04b0c8463aa56"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abdaed05a2b75bbe21338c98a8056cc53"><td class="memItemLeft" align="right" valign="top">std::shared_ptr&lt; <a class="el" href="classcugl_1_1audio_1_1_audio_input.html">audio::AudioInput</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1_audio_devices.html#abdaed05a2b75bbe21338c98a8056cc53">openInput</a> (const char *device, Uint8 channels, Uint32 rate, Uint32 delay)</td></tr>
<tr class="separator:abdaed05a2b75bbe21338c98a8056cc53"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa65ebca208456268af6e5588fb86afb4"><td class="memItemLeft" align="right" valign="top">std::shared_ptr&lt; <a class="el" href="classcugl_1_1audio_1_1_audio_input.html">audio::AudioInput</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1_audio_devices.html#aa65ebca208456268af6e5588fb86afb4">openInput</a> (const std::string &amp;device, Uint8 channels, Uint32 rate, Uint32 delay)</td></tr>
<tr class="separator:aa65ebca208456268af6e5588fb86afb4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3e139898712fca3a123725a4c9f4b1e2"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1_audio_devices.html#a3e139898712fca3a123725a4c9f4b1e2">closeInput</a> (const std::shared_ptr&lt; <a class="el" href="classcugl_1_1audio_1_1_audio_input.html">audio::AudioInput</a> &gt; &amp;device)</td></tr>
<tr class="separator:a3e139898712fca3a123725a4c9f4b1e2"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-static-methods"></a>
Static Public Member Functions</h2></td></tr>
<tr class="memitem:afc7ab63f730a42173a3e081dc3704c29"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classcugl_1_1_audio_devices.html">AudioDevices</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1_audio_devices.html#afc7ab63f730a42173a3e081dc3704c29">get</a> ()</td></tr>
<tr class="separator:afc7ab63f730a42173a3e081dc3704c29"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9e1398e8b36364ed923338de00c75b43"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1_audio_devices.html#a9e1398e8b36364ed923338de00c75b43">start</a> ()</td></tr>
<tr class="separator:a9e1398e8b36364ed923338de00c75b43"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7c506c762e3c4128a6178d0feeeda00a"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1_audio_devices.html#a7c506c762e3c4128a6178d0feeeda00a">start</a> (Uint32 frames)</td></tr>
<tr class="separator:a7c506c762e3c4128a6178d0feeeda00a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a484deafe4d48f8a93b47359818e6ef46"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1_audio_devices.html#a484deafe4d48f8a93b47359818e6ef46">start</a> (Uint32 output, Uint32 input)</td></tr>
<tr class="separator:a484deafe4d48f8a93b47359818e6ef46"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa44eda654f67db26bc679dcfaa17bb8c"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1_audio_devices.html#aa44eda654f67db26bc679dcfaa17bb8c">stop</a> ()</td></tr>
<tr class="separator:aa44eda654f67db26bc679dcfaa17bb8c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a911648a1ccc6a8d134ce570d11d74ebe"><td class="memItemLeft" align="right" valign="top">static std::vector&lt; std::string &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1_audio_devices.html#a911648a1ccc6a8d134ce570d11d74ebe">devices</a> (bool output)</td></tr>
<tr class="separator:a911648a1ccc6a8d134ce570d11d74ebe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7521857f65c40898877153f4dab3110b"><td class="memItemLeft" align="right" valign="top">static std::vector&lt; std::string &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1_audio_devices.html#a7521857f65c40898877153f4dab3110b">occupied</a> (bool output)</td></tr>
<tr class="separator:a7521857f65c40898877153f4dab3110b"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-static-attribs"></a>
Static Public Attributes</h2></td></tr>
<tr class="memitem:ae740ebb67d8fbb8ea40c6f64a4360727"><td class="memItemLeft" align="right" valign="top">static const Uint32&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1_audio_devices.html#ae740ebb67d8fbb8ea40c6f64a4360727">DEFAULT_OUTPUT_BUFFER</a></td></tr>
<tr class="separator:ae740ebb67d8fbb8ea40c6f64a4360727"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acabed4ac8b0d4e3cb1ffd10638b7ed2c"><td class="memItemLeft" align="right" valign="top">static const Uint32&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1_audio_devices.html#acabed4ac8b0d4e3cb1ffd10638b7ed2c">DEFAULT_INPUT_BUFFER</a></td></tr>
<tr class="separator:acabed4ac8b0d4e3cb1ffd10638b7ed2c"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Class providing a singleton audio device manager</p>
<p>This class is provides the most basic support for a modern audio engine. It has a factory for managing multiple input and output devices. However, it is up to the developer to connect these together to form audio graphs. Therefore, a developer should only use this class when direct access to the audio graph is necessary. Most developers can use <a class="el" href="classcugl_1_1_audio_engine.html">AudioEngine</a> instead. As that class is built on top of this one, the developer should only ever use one of the two classes.</p>
<p>You cannot create new instances of this class. Instead, you should access the singleton through the three static methods: <a class="el" href="classcugl_1_1_audio_devices.html#a9e1398e8b36364ed923338de00c75b43">start()</a>, <a class="el" href="classcugl_1_1_audio_devices.html#aa44eda654f67db26bc679dcfaa17bb8c">stop()</a>, and <a class="el" href="classcugl_1_1_audio_devices.html#afc7ab63f730a42173a3e081dc3704c29">get()</a>.</p>
<p>IMPORTANT: Like the OpenGL context, this class is not thread-safe. It is only safe to access this class in the main application thread. This means it should never be called in a call-back function as those are typically executed in the host thread. If you need to access the AudioManager in a callback function, you should use the <a class="el" href="classcugl_1_1_application.html#a3b277c28091afb74571dee5723fa78d8">Application#schedule</a> method to delay until the main thread is next available. </p>
</div><h2 class="groupheader">Member Function Documentation</h2>
<a id="aa7a694ece032657409b0e6db13e121b9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa7a694ece032657409b0e6db13e121b9">&#9670;&nbsp;</a></span>activate()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void cugl::AudioDevices::activate </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Activates the audio device manager.</p>
<p>This method is used to resume audio behavior after a call to the method <a class="el" href="classcugl_1_1_audio_devices.html#aeee4dca4084481aa67bce39a8268e942">deactivate()</a>. This provides a uniform way of renabling audio devices (such as after an application switch).</p>
<p>This method is not the same as <a class="el" href="classcugl_1_1_audio_devices.html#a9e1398e8b36364ed923338de00c75b43">start()</a>. It does not allocate any new resources. </p>

</div>
</div>
<a id="a3e139898712fca3a123725a4c9f4b1e2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3e139898712fca3a123725a4c9f4b1e2">&#9670;&nbsp;</a></span>closeInput()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool cugl::AudioDevices::closeInput </td>
          <td>(</td>
          <td class="paramtype">const std::shared_ptr&lt; <a class="el" href="classcugl_1_1audio_1_1_audio_input.html">audio::AudioInput</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>device</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Closes the output device and disposes all resources.</p>
<p>Once this method is called, the <a class="el" href="classcugl_1_1audio_1_1_audio_output.html">audio::AudioOutput</a> is invalidated and is no longer safe to use.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">device</td><td>The output device to close</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>whether the device was successfully closed. </dd></dl>

</div>
</div>
<a id="abc7936a32599044b77642c70fcdabbfc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abc7936a32599044b77642c70fcdabbfc">&#9670;&nbsp;</a></span>closeOutput()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool cugl::AudioDevices::closeOutput </td>
          <td>(</td>
          <td class="paramtype">const std::shared_ptr&lt; <a class="el" href="classcugl_1_1audio_1_1_audio_output.html">audio::AudioOutput</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>device</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Closes the output device and disposes all resources.</p>
<p>Once this method is called, the <a class="el" href="classcugl_1_1audio_1_1_audio_output.html">audio::AudioOutput</a> is invalidated and is no longer safe to use.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">device</td><td>The output device to close</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>whether the device was successfully closed. </dd></dl>

</div>
</div>
<a id="aeee4dca4084481aa67bce39a8268e942"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aeee4dca4084481aa67bce39a8268e942">&#9670;&nbsp;</a></span>deactivate()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void cugl::AudioDevices::deactivate </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Deactivates the audio device manager.</p>
<p>This method is used to pause all output nodes and release all input nodes from recording. This is important during an application switch, such as when the game goes into the background. All of the devices may be resumed with a call to <a class="el" href="classcugl_1_1_audio_devices.html#aeee4dca4084481aa67bce39a8268e942">deactivate()</a>.</p>
<p>This method is not the same as <a class="el" href="classcugl_1_1_audio_devices.html#aa44eda654f67db26bc679dcfaa17bb8c">stop()</a>. It does not release any resources and no audio graphs are invalidated. </p>

</div>
</div>
<a id="a911648a1ccc6a8d134ce570d11d74ebe"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a911648a1ccc6a8d134ce570d11d74ebe">&#9670;&nbsp;</a></span>devices()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static std::vector&lt;std::string&gt; cugl::AudioDevices::devices </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>output</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns the list of all the audio devices</p>
<p>This value may change and should be polled regularly to provide an up-to-date list. The provided argument determines whether this is for output or input devices.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">output</td><td>Whether to list output (instead of input) devices</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the list of all the audio devices </dd></dl>

</div>
</div>
<a id="afc7ab63f730a42173a3e081dc3704c29"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afc7ab63f730a42173a3e081dc3704c29">&#9670;&nbsp;</a></span>get()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="classcugl_1_1_audio_devices.html">AudioDevices</a>* cugl::AudioDevices::get </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns the singleton instance of the device manager.</p>
<p>If the audio manager has not been started, then this method will return nullptr.</p>
<dl class="section return"><dt>Returns</dt><dd>the singleton instance of the audio manager. </dd></dl>

</div>
</div>
<a id="aa5ff5ee2d9082beb885512513f985a00"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa5ff5ee2d9082beb885512513f985a00">&#9670;&nbsp;</a></span>getReadSize()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Uint32 cugl::AudioDevices::getReadSize </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns the size of the read buffer (in frames) for output nodes.</p>
<p>While output devices do not need to have uniform buffer sizes, we require this to ensure that audio graph nodes are all interchangeable. Therefore, a suitable buffer size (that works for all relevant devices) should be set at activation.</p>
<p>Note that the value is in frames. Therefore, output devices with different numbers of channels will have a different raw buffer size.</p>
<dl class="section return"><dt>Returns</dt><dd>the size of the read buffer (in frames) for output nodes. </dd></dl>

</div>
</div>
<a id="a4c87960ba67e85e78877f0685cfc34ef"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4c87960ba67e85e78877f0685cfc34ef">&#9670;&nbsp;</a></span>getWriteSize()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Uint32 cugl::AudioDevices::getWriteSize </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns the size of the write buffer (in frames) for input nodes.</p>
<p>While input devices do not need to have uniform buffer sizes, we require this to ensure that audio graph nodes are all interchangeable. Therefore, a suitable buffer size (that works for all relevant devices) should be set at activation.</p>
<p>Note that the value is in frames. Therefore, input devices with different numbers of channels will have a different raw buffer size.</p>
<dl class="section return"><dt>Returns</dt><dd>the size of the write buffer (in frames) for input nodes. </dd></dl>

</div>
</div>
<a id="a6971a9ab635a847428e1ae7bc3999102"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6971a9ab635a847428e1ae7bc3999102">&#9670;&nbsp;</a></span>isActive()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool cugl::AudioDevices::isActive </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns true if the audio device manager is active.</p>
<p>An active audio manager will regularly poll data from any unpaused output node, and regular write data to any unreleased input node.</p>
<dl class="section return"><dt>Returns</dt><dd>true if the audio manager is active. </dd></dl>

</div>
</div>
<a id="a7521857f65c40898877153f4dab3110b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7521857f65c40898877153f4dab3110b">&#9670;&nbsp;</a></span>occupied()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static std::vector&lt;std::string&gt; cugl::AudioDevices::occupied </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>output</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns the list of devices with attached audio nodes.</p>
<p>If there is an audio node on the default device, this will include the current default. The provided argument determines whether this is for output or input devices.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">output</td><td>Whether to list output (instead of input) devices</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the list of devices with attached audio nodes. </dd></dl>

</div>
</div>
<a id="a4cae0ad8078ff4bbe563c1606a11fcfd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4cae0ad8078ff4bbe563c1606a11fcfd">&#9670;&nbsp;</a></span>openInput() <span class="overload">[1/6]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::shared_ptr&lt;<a class="el" href="classcugl_1_1audio_1_1_audio_input.html">audio::AudioInput</a>&gt; cugl::AudioDevices::openInput </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns the default input device with 2 channels at 48000 Hz.</p>
<p>The input delay will be equal to the value <a class="el" href="classcugl_1_1_audio_devices.html#a4c87960ba67e85e78877f0685cfc34ef">getWriteSize()</a>. This means that playback is only available after two calls to <a class="el" href="classcugl_1_1audio_1_1_audio_input.html#a44fd891471348d7bb3ea08a13bf69db2">audio::AudioInput#record()</a>. This is the minimal value for smooth real-time playback of recorded audio.</p>
<p>An input device is initialized with both active as false and record as true. That means it will start recording as soon as the AudioManager is activated. In addition, it is also unpaused, meaning that playback will start as soon as it is attached to an audio graph.</p>
<p>This node is always logically attached to the default input device. That means it will switch devices whenever the default input changes. This method may fail if the default device is in use.</p>
<dl class="section return"><dt>Returns</dt><dd>the default input device with 2 channels at 48000 Hz. </dd></dl>

</div>
</div>
<a id="a5788d67ca306fc24d6e3eb55a3c7b473"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5788d67ca306fc24d6e3eb55a3c7b473">&#9670;&nbsp;</a></span>openInput() <span class="overload">[2/6]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::shared_ptr&lt;<a class="el" href="classcugl_1_1audio_1_1_audio_input.html">audio::AudioInput</a>&gt; cugl::AudioDevices::openInput </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>device</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns the given input device with 2 channels at 48000 Hz.</p>
<p>The input delay will be equal to the value <a class="el" href="classcugl_1_1_audio_devices.html#a4c87960ba67e85e78877f0685cfc34ef">getWriteSize()</a>. This means that playback is only available after two calls to <a class="el" href="classcugl_1_1audio_1_1_audio_input.html#a44fd891471348d7bb3ea08a13bf69db2">audio::AudioInput#record()</a>. This is the minimal value for smooth real-time playback of recorded audio.</p>
<p>An input device is initialized with both active as false and record as true. That means it will start recording as soon as the AudioManager is activated. In addition, it is also unpaused, meaning that playback will start as soon as it is attached to an audio graph.</p>
<p>This method may fail if the given device is in use.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">device</td><td>The name of the output device</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the given input device with 2 channels at 48000 Hz. </dd></dl>

</div>
</div>
<a id="abdaed05a2b75bbe21338c98a8056cc53"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abdaed05a2b75bbe21338c98a8056cc53">&#9670;&nbsp;</a></span>openInput() <span class="overload">[3/6]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::shared_ptr&lt;<a class="el" href="classcugl_1_1audio_1_1_audio_input.html">audio::AudioInput</a>&gt; cugl::AudioDevices::openInput </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>device</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Uint8&#160;</td>
          <td class="paramname"><em>channels</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Uint32&#160;</td>
          <td class="paramname"><em>rate</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Uint32&#160;</td>
          <td class="paramname"><em>delay</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns the given output device with the given channels and sample rate.</p>
<p>The delay value is the number of frames that must be recorded before a single frame. This determines the playback latency. While it is possible to have a delay of 0, this is unlikely to provide smooth real-time playback of recorded audio. That is because there are no guarantees about the thread interleaving of input and output devices. A delay of at least <a class="el" href="classcugl_1_1_audio_devices.html#a4c87960ba67e85e78877f0685cfc34ef">getWriteSize()</a>, and maybe even more, is recommended.</p>
<p>An input device is initialized with both active as false and record as true. That means it will start recording as soon as the AudioManager is activated. In addition, it is also unpaused, meaning that playback will start as soon as it is attached to an audio graph.</p>
<p>This method may fail if the given device is in use.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">device</td><td>The name of the output device </td></tr>
    <tr><td class="paramname">channels</td><td>The number of audio channels </td></tr>
    <tr><td class="paramname">rate</td><td>The sample rate (frequency) in Hz </td></tr>
    <tr><td class="paramname">delay</td><td>The playback delay between recording and reading</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the given output device with the given channels and sample rate. </dd></dl>

</div>
</div>
<a id="a9edc5c2466efd19638b04b0c8463aa56"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9edc5c2466efd19638b04b0c8463aa56">&#9670;&nbsp;</a></span>openInput() <span class="overload">[4/6]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::shared_ptr&lt;<a class="el" href="classcugl_1_1audio_1_1_audio_input.html">audio::AudioInput</a>&gt; cugl::AudioDevices::openInput </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>device</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns the given input device with 2 channels at 48000 Hz.</p>
<p>The input delay will be equal to the value <a class="el" href="classcugl_1_1_audio_devices.html#a4c87960ba67e85e78877f0685cfc34ef">getWriteSize()</a>. This means that playback is only available after two calls to <a class="el" href="classcugl_1_1audio_1_1_audio_input.html#a44fd891471348d7bb3ea08a13bf69db2">audio::AudioInput#record()</a>. This is the minimal value for smooth real-time playback of recorded audio.</p>
<p>An input device is initialized with both active as false and record as true. That means it will start recording as soon as the AudioManager is activated. In addition, it is also unpaused, meaning that playback will start as soon as it is attached to an audio graph.</p>
<p>This method may fail if the given device is in use.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">device</td><td>The name of the output device</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the given input device with 2 channels at 48000 Hz. </dd></dl>

</div>
</div>
<a id="aa65ebca208456268af6e5588fb86afb4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa65ebca208456268af6e5588fb86afb4">&#9670;&nbsp;</a></span>openInput() <span class="overload">[5/6]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::shared_ptr&lt;<a class="el" href="classcugl_1_1audio_1_1_audio_input.html">audio::AudioInput</a>&gt; cugl::AudioDevices::openInput </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>device</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Uint8&#160;</td>
          <td class="paramname"><em>channels</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Uint32&#160;</td>
          <td class="paramname"><em>rate</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Uint32&#160;</td>
          <td class="paramname"><em>delay</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns the given output device with the given channels and sample rate.</p>
<p>The delay value is the number of frames that must be recorded before a single frame. This determines the playback latency. While it is possible to have a delay of 0, this is unlikely to provide smooth real-time playback of recorded audio. That is because there are no guarantees about the thread interleaving of input and output devices. A delay of at least <a class="el" href="classcugl_1_1_audio_devices.html#a4c87960ba67e85e78877f0685cfc34ef">getWriteSize()</a>, and maybe even more, is recommended.</p>
<p>An input device is initialized with both active as false and record as true. That means it will start recording as soon as the AudioManager is activated. In addition, it is also unpaused, meaning that playback will start as soon as it is attached to an audio graph.</p>
<p>This method may fail if the given device is in use.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">device</td><td>The name of the output device </td></tr>
    <tr><td class="paramname">channels</td><td>The number of audio channels </td></tr>
    <tr><td class="paramname">rate</td><td>The sample rate (frequency) in Hz </td></tr>
    <tr><td class="paramname">delay</td><td>The playback delay between recording and reading</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the given output device with the given channels and sample rate. </dd></dl>

</div>
</div>
<a id="a4ee5d85360993437e81bd52ae0b69902"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4ee5d85360993437e81bd52ae0b69902">&#9670;&nbsp;</a></span>openInput() <span class="overload">[6/6]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::shared_ptr&lt;<a class="el" href="classcugl_1_1audio_1_1_audio_input.html">audio::AudioInput</a>&gt; cugl::AudioDevices::openInput </td>
          <td>(</td>
          <td class="paramtype">Uint8&#160;</td>
          <td class="paramname"><em>channels</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Uint32&#160;</td>
          <td class="paramname"><em>rate</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Uint32&#160;</td>
          <td class="paramname"><em>delay</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns the default input device with the given channels and sample rate.</p>
<p>The delay value is the number of frames that must be recorded before a single frame. This determines the playback latency. While it is possible to have a delay of 0, this is unlikely to provide smooth real-time playback of recorded audio. That is because there are no guarantees about the thread interleaving of input and output devices. A delay of at least <a class="el" href="classcugl_1_1_audio_devices.html#a4c87960ba67e85e78877f0685cfc34ef">getWriteSize()</a>, and maybe even more, is recommended.</p>
<p>An input device is initialized with both active as false and record as true. That means it will start recording as soon as the AudioManager is activated. In addition, it is also unpaused, meaning that playback will start as soon as it is attached to an audio graph.</p>
<p>This node is always logically attached to the default input device. That means it will switch devices whenever the default input changes. This method may fail if the default input device is in use.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">channels</td><td>The number of audio channels </td></tr>
    <tr><td class="paramname">rate</td><td>The sample rate (frequency) in Hz </td></tr>
    <tr><td class="paramname">delay</td><td>The playback delay between recording and reading</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the default input device with the given channels and sample rate. </dd></dl>

</div>
</div>
<a id="af6cd9d932978d8e1f05c6ac30009a548"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af6cd9d932978d8e1f05c6ac30009a548">&#9670;&nbsp;</a></span>openOutput() <span class="overload">[1/6]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::shared_ptr&lt;<a class="el" href="classcugl_1_1audio_1_1_audio_output.html">audio::AudioOutput</a>&gt; cugl::AudioDevices::openOutput </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns the default output device with 2 channels at 48000 Hz.</p>
<p>An output device is initialized with both active and paused as false. That means it will begin playback as soon as the audio manager is activated.</p>
<p>This node is always logically attached to the default output device. That means it will switch devices whenever the default output changes. This method may fail if the default device is in use.</p>
<dl class="section return"><dt>Returns</dt><dd>the default output device with 2 channels at 48000 Hz. </dd></dl>

</div>
</div>
<a id="ac01c4e33bd886460c7d7d99d887e6bc2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac01c4e33bd886460c7d7d99d887e6bc2">&#9670;&nbsp;</a></span>openOutput() <span class="overload">[2/6]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::shared_ptr&lt;<a class="el" href="classcugl_1_1audio_1_1_audio_output.html">audio::AudioOutput</a>&gt; cugl::AudioDevices::openOutput </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>device</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns the given output device with 2 channels at 48000 Hz.</p>
<p>An output device is initialized with both active and paused as false. That means it will begin playback as soon as the audio manager is activated.</p>
<p>This method may fail if the given device is in use.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">device</td><td>The name of the output device</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the given output device with 2 channels at 48000 Hz. </dd></dl>

</div>
</div>
<a id="a5f47ddc14c3ddb504bad3b988a67e2af"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5f47ddc14c3ddb504bad3b988a67e2af">&#9670;&nbsp;</a></span>openOutput() <span class="overload">[3/6]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::shared_ptr&lt;<a class="el" href="classcugl_1_1audio_1_1_audio_output.html">audio::AudioOutput</a>&gt; cugl::AudioDevices::openOutput </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>device</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Uint8&#160;</td>
          <td class="paramname"><em>channels</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Uint32&#160;</td>
          <td class="paramname"><em>rate</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns the output device with the given channels and sample rate.</p>
<p>An output device is initialized with both active and paused as false. That means it will begin playback as soon as the audio manager is activated.</p>
<p>This method may fail if the given device is in use.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">device</td><td>The name of the output device </td></tr>
    <tr><td class="paramname">channels</td><td>The number of audio channels </td></tr>
    <tr><td class="paramname">rate</td><td>The sample rate (frequency) in Hz</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the output device with the given channels and sample rate. </dd></dl>

</div>
</div>
<a id="a7a0c9d5a496f9e8da1b015234493d85d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7a0c9d5a496f9e8da1b015234493d85d">&#9670;&nbsp;</a></span>openOutput() <span class="overload">[4/6]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::shared_ptr&lt;<a class="el" href="classcugl_1_1audio_1_1_audio_output.html">audio::AudioOutput</a>&gt; cugl::AudioDevices::openOutput </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>device</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns the given output device with 2 channels at 48000 Hz.</p>
<p>An output device is initialized with both active and paused as false. That means it will begin playback as soon as the audio manager is activated.</p>
<p>This method may fail if the given device is in use.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">device</td><td>The name of the output device</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the given output device with 2 channels at 48000 Hz. </dd></dl>

</div>
</div>
<a id="ad4eb3b4554481797223224200c9df36e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad4eb3b4554481797223224200c9df36e">&#9670;&nbsp;</a></span>openOutput() <span class="overload">[5/6]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::shared_ptr&lt;<a class="el" href="classcugl_1_1audio_1_1_audio_output.html">audio::AudioOutput</a>&gt; cugl::AudioDevices::openOutput </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>device</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Uint8&#160;</td>
          <td class="paramname"><em>channels</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Uint32&#160;</td>
          <td class="paramname"><em>rate</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns the output device with the given channels and sample rate.</p>
<p>An output device is initialized with both active and paused as false. That means it will begin playback as soon as the audio manager is activated.</p>
<p>This method may fail if the given device is in use.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">device</td><td>The name of the output device </td></tr>
    <tr><td class="paramname">channels</td><td>The number of audio channels </td></tr>
    <tr><td class="paramname">rate</td><td>The sample rate (frequency) in Hz</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the output device with the given channels and sample rate. </dd></dl>

</div>
</div>
<a id="a97ffb75210063d0745321807c8f60ffa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a97ffb75210063d0745321807c8f60ffa">&#9670;&nbsp;</a></span>openOutput() <span class="overload">[6/6]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::shared_ptr&lt;<a class="el" href="classcugl_1_1audio_1_1_audio_output.html">audio::AudioOutput</a>&gt; cugl::AudioDevices::openOutput </td>
          <td>(</td>
          <td class="paramtype">Uint8&#160;</td>
          <td class="paramname"><em>channels</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Uint32&#160;</td>
          <td class="paramname"><em>rate</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns the default output device with the given channels and sample rate.</p>
<p>An output device is initialized with both active and paused as false. That means it will begin playback as soon as the audio manager is activated.</p>
<p>This node is always logically attached to the default output device. That means it will switch devices whenever the default output changes. This method may fail if the default output device is in use.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">channels</td><td>The number of audio channels </td></tr>
    <tr><td class="paramname">rate</td><td>The sample rate (frequency) in Hz</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the default output device with the given channels and sample rate. </dd></dl>

</div>
</div>
<a id="a66df05a74167716acdf1f9a35c453123"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a66df05a74167716acdf1f9a35c453123">&#9670;&nbsp;</a></span>reset()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void cugl::AudioDevices::reset </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Resets any stopped or failed audio devices.</p>
<p>This method will also roll over the default output (not input) device if it changes.</p>
<p>This method is necessary for when an audio device is unplugged. While SDL often does this automatically, this method is provided for platforms (e.g. CoreAudio on MacOS) where this must be done explicitly. </p>

</div>
</div>
<a id="a9e1398e8b36364ed923338de00c75b43"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9e1398e8b36364ed923338de00c75b43">&#9670;&nbsp;</a></span>start() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void cugl::AudioDevices::start </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Starts the singleton audio device manager.</p>
<p>Once this method is called, the method <a class="el" href="classcugl_1_1_audio_devices.html#afc7ab63f730a42173a3e081dc3704c29">get()</a> will no longer return nullptr. Calling the method multiple times (without calling stop) will have no effect. In addition, an audio manager will start off as inactive, and must be activated.</p>
<p>Instances of <a class="el" href="classcugl_1_1audio_1_1_audio_node.html">audio::AudioNode</a> (and its subclasses) cannot be initialized until this manager is activated. That is because audio nodes need a uniform buffer size (set by this method) in order to coordinate with one another.</p>
<p>This method will create a manager where the input and output buffer sizes are the default values. </p>

</div>
</div>
<a id="a7c506c762e3c4128a6178d0feeeda00a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7c506c762e3c4128a6178d0feeeda00a">&#9670;&nbsp;</a></span>start() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void cugl::AudioDevices::start </td>
          <td>(</td>
          <td class="paramtype">Uint32&#160;</td>
          <td class="paramname"><em>frames</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Starts the singleton audio device manager.</p>
<p>Once this method is called, the method <a class="el" href="classcugl_1_1_audio_devices.html#afc7ab63f730a42173a3e081dc3704c29">get()</a> will no longer return nullptr. Calling the method multiple times (without calling stop) will have no effect. In addition, an audio manager will start off as inactive, and must be activated.</p>
<p>Instances of <a class="el" href="classcugl_1_1audio_1_1_audio_node.html">audio::AudioNode</a> (and its subclasses) cannot be initialized until this manager is activated. That is because audio nodes need a uniform buffer size (set by this method) in order to coordinate with one another.</p>
<p>This method will create a manager where the output and input buffer share the same size.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">frames</td><td>The output and input buffer size in frames. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a484deafe4d48f8a93b47359818e6ef46"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a484deafe4d48f8a93b47359818e6ef46">&#9670;&nbsp;</a></span>start() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void cugl::AudioDevices::start </td>
          <td>(</td>
          <td class="paramtype">Uint32&#160;</td>
          <td class="paramname"><em>output</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Uint32&#160;</td>
          <td class="paramname"><em>input</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Starts the singleton audio device manager.</p>
<p>Once this method is called, the method <a class="el" href="classcugl_1_1_audio_devices.html#afc7ab63f730a42173a3e081dc3704c29">get()</a> will no longer return nullptr. Calling the method multiple times (without calling stop) will have no effect. In addition, an audio manager will start off as inactive, and must be activated.</p>
<p>Instances of <a class="el" href="classcugl_1_1audio_1_1_audio_node.html">audio::AudioNode</a> (and its subclasses) cannot be initialized until this manager is activated. That is because audio nodes need a uniform buffer size (set by this method) in order to coordinate with one another.</p>
<p>This method will create a manager where the output and input buffer have the specified sizes. It is not necessary for the buffer value of an input device match the buffer value of an output device. Indeed, on many systems, an input buffer size of less than 1024 samples is not supported, while output devices can process much faster than that. What is important is ensuring enough delay so that the audio graph does not outrun the input device. Therefore, an input delay of less than the input buffer size is not recommended for real-time audio processing.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">output</td><td>The size of the output buffer in frames. </td></tr>
    <tr><td class="paramname">input</td><td>The size of the input buffer in frames. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aa44eda654f67db26bc679dcfaa17bb8c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa44eda654f67db26bc679dcfaa17bb8c">&#9670;&nbsp;</a></span>stop()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void cugl::AudioDevices::stop </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Stops the singleton device manager, releasing all resources.</p>
<p>Once this method is called, the method <a class="el" href="classcugl_1_1_audio_devices.html#afc7ab63f730a42173a3e081dc3704c29">get()</a> will return nullptr. Calling the method multiple times (without calling stop) will have no effect. In addition, the audio manager will no longer be active.</p>
<p>Once this method is called, all instances of <a class="el" href="classcugl_1_1audio_1_1_audio_node.html">audio::AudioNode</a> become invalid. In addition, no future instances of <a class="el" href="classcugl_1_1audio_1_1_audio_node.html">audio::AudioNode</a> may be created. This method should only be called at application shutdown. </p>

</div>
</div>
<h2 class="groupheader">Member Data Documentation</h2>
<a id="acabed4ac8b0d4e3cb1ffd10638b7ed2c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acabed4ac8b0d4e3cb1ffd10638b7ed2c">&#9670;&nbsp;</a></span>DEFAULT_INPUT_BUFFER</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const Uint32 cugl::AudioDevices::DEFAULT_INPUT_BUFFER</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>The default input buffer size for each audio node </p>

</div>
</div>
<a id="ae740ebb67d8fbb8ea40c6f64a4360727"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae740ebb67d8fbb8ea40c6f64a4360727">&#9670;&nbsp;</a></span>DEFAULT_OUTPUT_BUFFER</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const Uint32 cugl::AudioDevices::DEFAULT_OUTPUT_BUFFER</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>The default input buffer size for each audio node </p>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>include/cugl/audio/<a class="el" href="_c_u_audio_devices_8h_source.html">CUAudioDevices.h</a></li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.1
</small></address>
</body>
</html>
