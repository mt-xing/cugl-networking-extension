<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.9.1"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>CUGL 2.0: cugl::Poly2 Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">CUGL 2.0
   </div>
   <div id="projectbrief">Cornell University Game Library</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.1 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search','.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespacecugl.html">cugl</a></li><li class="navelem"><a class="el" href="classcugl_1_1_poly2.html">Poly2</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-static-methods">Static Public Member Functions</a> &#124;
<a href="#friends">Friends</a> &#124;
<a href="classcugl_1_1_poly2-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">cugl::Poly2 Class Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p><code>#include &lt;<a class="el" href="_c_u_poly2_8h_source.html">CUPoly2.h</a>&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:ad36500275b41ae48913824f24cb59428"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1_poly2.html#ad36500275b41ae48913824f24cb59428">Poly2</a> ()</td></tr>
<tr class="separator:ad36500275b41ae48913824f24cb59428"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a63eb274b29f3beb7d0999deeb5190b8a"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1_poly2.html#a63eb274b29f3beb7d0999deeb5190b8a">Poly2</a> (const std::vector&lt; <a class="el" href="classcugl_1_1_vec2.html">Vec2</a> &gt; &amp;<a class="el" href="classcugl_1_1_poly2.html#a261758c43911ac08b4889effe6d45253">vertices</a>)</td></tr>
<tr class="separator:a63eb274b29f3beb7d0999deeb5190b8a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4690381d3582cd041145de5f15d67c82"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1_poly2.html#a4690381d3582cd041145de5f15d67c82">Poly2</a> (const std::vector&lt; <a class="el" href="classcugl_1_1_vec2.html">Vec2</a> &gt; &amp;<a class="el" href="classcugl_1_1_poly2.html#a261758c43911ac08b4889effe6d45253">vertices</a>, const std::vector&lt; Uint32 &gt; &amp;<a class="el" href="classcugl_1_1_poly2.html#a1c973c09c9c018eb312a64024171b512">indices</a>)</td></tr>
<tr class="separator:a4690381d3582cd041145de5f15d67c82"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afd60a8920a146c79a83dc748b47c759e"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1_poly2.html#afd60a8920a146c79a83dc748b47c759e">Poly2</a> (const std::vector&lt; float &gt; &amp;<a class="el" href="classcugl_1_1_poly2.html#a261758c43911ac08b4889effe6d45253">vertices</a>)</td></tr>
<tr class="separator:afd60a8920a146c79a83dc748b47c759e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9f280a863a4171159e385e447859b224"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1_poly2.html#a9f280a863a4171159e385e447859b224">Poly2</a> (const std::vector&lt; float &gt; &amp;<a class="el" href="classcugl_1_1_poly2.html#a261758c43911ac08b4889effe6d45253">vertices</a>, const std::vector&lt; Uint32 &gt; &amp;<a class="el" href="classcugl_1_1_poly2.html#a1c973c09c9c018eb312a64024171b512">indices</a>)</td></tr>
<tr class="separator:a9f280a863a4171159e385e447859b224"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0ee7bbe772a9a59cdfae4b0aa552ca28"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1_poly2.html#a0ee7bbe772a9a59cdfae4b0aa552ca28">Poly2</a> (const float *<a class="el" href="classcugl_1_1_poly2.html#a261758c43911ac08b4889effe6d45253">vertices</a>, size_t vertsize)</td></tr>
<tr class="separator:a0ee7bbe772a9a59cdfae4b0aa552ca28"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adbadaa87b1409167328b35b7408f5648"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1_poly2.html#adbadaa87b1409167328b35b7408f5648">Poly2</a> (const float *<a class="el" href="classcugl_1_1_poly2.html#a261758c43911ac08b4889effe6d45253">vertices</a>, size_t vertsize, const Uint32 *<a class="el" href="classcugl_1_1_poly2.html#a1c973c09c9c018eb312a64024171b512">indices</a>, size_t indxsize)</td></tr>
<tr class="separator:adbadaa87b1409167328b35b7408f5648"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a21093987251fe8a1ecf4b880a7b320a8"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1_poly2.html#a21093987251fe8a1ecf4b880a7b320a8">Poly2</a> (const <a class="el" href="classcugl_1_1_poly2.html">Poly2</a> &amp;poly)</td></tr>
<tr class="separator:a21093987251fe8a1ecf4b880a7b320a8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a02c6a814620aab3d2de59582a307bca8"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1_poly2.html#a02c6a814620aab3d2de59582a307bca8">Poly2</a> (<a class="el" href="classcugl_1_1_poly2.html">Poly2</a> &amp;&amp;poly)</td></tr>
<tr class="separator:a02c6a814620aab3d2de59582a307bca8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a872fcad0e6881ef8cb6ab0ef6464705e"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1_poly2.html#a872fcad0e6881ef8cb6ab0ef6464705e">Poly2</a> (const <a class="el" href="classcugl_1_1_rect.html">Rect</a> rect, bool solid=true)</td></tr>
<tr class="separator:a872fcad0e6881ef8cb6ab0ef6464705e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a98c9fd41a7666abf2ca1bd337ecf5054"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1_poly2.html#a98c9fd41a7666abf2ca1bd337ecf5054">~Poly2</a> ()</td></tr>
<tr class="separator:a98c9fd41a7666abf2ca1bd337ecf5054"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa1e51d73ea036f2efa9123d3952916ee"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classcugl_1_1_poly2.html">Poly2</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1_poly2.html#aa1e51d73ea036f2efa9123d3952916ee">operator=</a> (const <a class="el" href="classcugl_1_1_poly2.html">Poly2</a> &amp;other)</td></tr>
<tr class="separator:aa1e51d73ea036f2efa9123d3952916ee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4d097e4cd083f54a55d2d07a7c63a5a1"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classcugl_1_1_poly2.html">Poly2</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1_poly2.html#a4d097e4cd083f54a55d2d07a7c63a5a1">operator=</a> (<a class="el" href="classcugl_1_1_poly2.html">Poly2</a> &amp;&amp;other)</td></tr>
<tr class="separator:a4d097e4cd083f54a55d2d07a7c63a5a1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a726425b72ce40474100a546896eed6c3"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classcugl_1_1_poly2.html">Poly2</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1_poly2.html#a726425b72ce40474100a546896eed6c3">operator=</a> (const <a class="el" href="classcugl_1_1_rect.html">Rect</a> rect)</td></tr>
<tr class="separator:a726425b72ce40474100a546896eed6c3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a33366d9d9a73620d93591dfdd78f177d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classcugl_1_1_poly2.html">Poly2</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1_poly2.html#a33366d9d9a73620d93591dfdd78f177d">set</a> (const std::vector&lt; <a class="el" href="classcugl_1_1_vec2.html">Vec2</a> &gt; &amp;<a class="el" href="classcugl_1_1_poly2.html#a261758c43911ac08b4889effe6d45253">vertices</a>)</td></tr>
<tr class="separator:a33366d9d9a73620d93591dfdd78f177d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a03babab1cb75704f3c1b24b4cb26ec42"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classcugl_1_1_poly2.html">Poly2</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1_poly2.html#a03babab1cb75704f3c1b24b4cb26ec42">set</a> (const std::vector&lt; <a class="el" href="classcugl_1_1_vec2.html">Vec2</a> &gt; &amp;<a class="el" href="classcugl_1_1_poly2.html#a261758c43911ac08b4889effe6d45253">vertices</a>, const std::vector&lt; Uint32 &gt; &amp;<a class="el" href="classcugl_1_1_poly2.html#a1c973c09c9c018eb312a64024171b512">indices</a>)</td></tr>
<tr class="separator:a03babab1cb75704f3c1b24b4cb26ec42"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aca03a89eba69a6f74989a19fe2ca7b4d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classcugl_1_1_poly2.html">Poly2</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1_poly2.html#aca03a89eba69a6f74989a19fe2ca7b4d">set</a> (const std::vector&lt; float &gt; &amp;<a class="el" href="classcugl_1_1_poly2.html#a261758c43911ac08b4889effe6d45253">vertices</a>)</td></tr>
<tr class="separator:aca03a89eba69a6f74989a19fe2ca7b4d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5131d586746dacc3bdd9af4f3e5532b6"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classcugl_1_1_poly2.html">Poly2</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1_poly2.html#a5131d586746dacc3bdd9af4f3e5532b6">set</a> (const std::vector&lt; float &gt; &amp;<a class="el" href="classcugl_1_1_poly2.html#a261758c43911ac08b4889effe6d45253">vertices</a>, const std::vector&lt; Uint32 &gt; &amp;<a class="el" href="classcugl_1_1_poly2.html#a1c973c09c9c018eb312a64024171b512">indices</a>)</td></tr>
<tr class="separator:a5131d586746dacc3bdd9af4f3e5532b6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a46c65307bf770be577cf2ee822147b4b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classcugl_1_1_poly2.html">Poly2</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1_poly2.html#a46c65307bf770be577cf2ee822147b4b">set</a> (const <a class="el" href="classcugl_1_1_vec2.html">Vec2</a> *<a class="el" href="classcugl_1_1_poly2.html#a261758c43911ac08b4889effe6d45253">vertices</a>, size_t vertsize)</td></tr>
<tr class="separator:a46c65307bf770be577cf2ee822147b4b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab1e03291c994013b9bebc84f6c0f09e7"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classcugl_1_1_poly2.html">Poly2</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1_poly2.html#ab1e03291c994013b9bebc84f6c0f09e7">set</a> (const float *<a class="el" href="classcugl_1_1_poly2.html#a261758c43911ac08b4889effe6d45253">vertices</a>, size_t vertsize)</td></tr>
<tr class="separator:ab1e03291c994013b9bebc84f6c0f09e7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afb94ca298051246f1e8d7914729a1c8e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classcugl_1_1_poly2.html">Poly2</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1_poly2.html#afb94ca298051246f1e8d7914729a1c8e">set</a> (const <a class="el" href="classcugl_1_1_vec2.html">Vec2</a> *<a class="el" href="classcugl_1_1_poly2.html#a261758c43911ac08b4889effe6d45253">vertices</a>, size_t vertsize, const Uint32 *<a class="el" href="classcugl_1_1_poly2.html#a1c973c09c9c018eb312a64024171b512">indices</a>, size_t indxsize)</td></tr>
<tr class="separator:afb94ca298051246f1e8d7914729a1c8e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae4083d3601353e3f4933e55f67cb9a5c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classcugl_1_1_poly2.html">Poly2</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1_poly2.html#ae4083d3601353e3f4933e55f67cb9a5c">set</a> (const float *<a class="el" href="classcugl_1_1_poly2.html#a261758c43911ac08b4889effe6d45253">vertices</a>, size_t vertsize, const Uint32 *<a class="el" href="classcugl_1_1_poly2.html#a1c973c09c9c018eb312a64024171b512">indices</a>, size_t indxsize)</td></tr>
<tr class="separator:ae4083d3601353e3f4933e55f67cb9a5c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a28397786382add4ef7f89e0ed85c4a4f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classcugl_1_1_poly2.html">Poly2</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1_poly2.html#a28397786382add4ef7f89e0ed85c4a4f">set</a> (const <a class="el" href="classcugl_1_1_poly2.html">Poly2</a> &amp;poly)</td></tr>
<tr class="separator:a28397786382add4ef7f89e0ed85c4a4f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab2e8cbcac97231ead348552e2fb31878"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classcugl_1_1_poly2.html">Poly2</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1_poly2.html#ab2e8cbcac97231ead348552e2fb31878">set</a> (const <a class="el" href="classcugl_1_1_rect.html">Rect</a> rect, bool solid=true)</td></tr>
<tr class="separator:ab2e8cbcac97231ead348552e2fb31878"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5d2104d6584cab63a9b947af24e81b23"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classcugl_1_1_poly2.html">Poly2</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1_poly2.html#a5d2104d6584cab63a9b947af24e81b23">setIndices</a> (const std::vector&lt; Uint32 &gt; &amp;<a class="el" href="classcugl_1_1_poly2.html#a1c973c09c9c018eb312a64024171b512">indices</a>)</td></tr>
<tr class="separator:a5d2104d6584cab63a9b947af24e81b23"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ade6cd9e64f7fbc4636544736dff6f5ed"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classcugl_1_1_poly2.html">Poly2</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1_poly2.html#ade6cd9e64f7fbc4636544736dff6f5ed">setIndices</a> (const Uint32 *<a class="el" href="classcugl_1_1_poly2.html#a1c973c09c9c018eb312a64024171b512">indices</a>, size_t indxsize)</td></tr>
<tr class="separator:ade6cd9e64f7fbc4636544736dff6f5ed"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6958e6551dfbc82a1f70ee67887f0258"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classcugl_1_1_poly2.html">Poly2</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1_poly2.html#a6958e6551dfbc82a1f70ee67887f0258">clear</a> ()</td></tr>
<tr class="separator:a6958e6551dfbc82a1f70ee67887f0258"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abb707fec08fa4b1fea47996292f47570"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1_poly2.html#abb707fec08fa4b1fea47996292f47570">size</a> () const</td></tr>
<tr class="separator:abb707fec08fa4b1fea47996292f47570"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afd0144296a9b8416146e3b34252d17f2"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1_poly2.html#afd0144296a9b8416146e3b34252d17f2">indexSize</a> () const</td></tr>
<tr class="separator:afd0144296a9b8416146e3b34252d17f2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a62777945434b34ba0b5be4133639d208"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classcugl_1_1_vec2.html">Vec2</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1_poly2.html#a62777945434b34ba0b5be4133639d208">at</a> (int index)</td></tr>
<tr class="separator:a62777945434b34ba0b5be4133639d208"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a261758c43911ac08b4889effe6d45253"><td class="memItemLeft" align="right" valign="top">const std::vector&lt; <a class="el" href="classcugl_1_1_vec2.html">Vec2</a> &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1_poly2.html#a261758c43911ac08b4889effe6d45253">vertices</a> () const</td></tr>
<tr class="separator:a261758c43911ac08b4889effe6d45253"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad2d588486c60528899bbc10e797e6fa2"><td class="memItemLeft" align="right" valign="top">std::vector&lt; <a class="el" href="classcugl_1_1_vec2.html">Vec2</a> &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1_poly2.html#ad2d588486c60528899bbc10e797e6fa2">vertices</a> ()</td></tr>
<tr class="separator:ad2d588486c60528899bbc10e797e6fa2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1c973c09c9c018eb312a64024171b512"><td class="memItemLeft" align="right" valign="top">const std::vector&lt; Uint32 &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1_poly2.html#a1c973c09c9c018eb312a64024171b512">indices</a> () const</td></tr>
<tr class="separator:a1c973c09c9c018eb312a64024171b512"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aba612cf31d8af93c9b3d445dca49d8c5"><td class="memItemLeft" align="right" valign="top">std::vector&lt; Uint32 &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1_poly2.html#aba612cf31d8af93c9b3d445dca49d8c5">indices</a> ()</td></tr>
<tr class="separator:aba612cf31d8af93c9b3d445dca49d8c5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a32c556ea07df156fd3658f7894f2a704"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classcugl_1_1_rect.html">Rect</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1_poly2.html#a32c556ea07df156fd3658f7894f2a704">getBounds</a> () const</td></tr>
<tr class="separator:a32c556ea07df156fd3658f7894f2a704"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aed1c7ad12f1f281048c981683aa1068c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classcugl_1_1_geometry.html">Geometry</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1_poly2.html#aed1c7ad12f1f281048c981683aa1068c">getGeometry</a> () const</td></tr>
<tr class="separator:aed1c7ad12f1f281048c981683aa1068c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a970f2aa0fa32f21fb8134a31a911c66d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1_poly2.html#a970f2aa0fa32f21fb8134a31a911c66d">setGeometry</a> (<a class="el" href="classcugl_1_1_geometry.html">Geometry</a> geom)</td></tr>
<tr class="separator:a970f2aa0fa32f21fb8134a31a911c66d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aadd955e9a4490209fb083c9b97f4c331"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classcugl_1_1_poly2.html">Poly2</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1_poly2.html#aadd955e9a4490209fb083c9b97f4c331">operator*=</a> (float scale)</td></tr>
<tr class="separator:aadd955e9a4490209fb083c9b97f4c331"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0dfef1a8280639ae720b116a521e2cc7"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classcugl_1_1_poly2.html">Poly2</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1_poly2.html#a0dfef1a8280639ae720b116a521e2cc7">operator*=</a> (const <a class="el" href="classcugl_1_1_vec2.html">Vec2</a> scale)</td></tr>
<tr class="separator:a0dfef1a8280639ae720b116a521e2cc7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acc4bc214a1acbfb72d922cd6965f7e9b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classcugl_1_1_poly2.html">Poly2</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1_poly2.html#acc4bc214a1acbfb72d922cd6965f7e9b">operator*=</a> (const <a class="el" href="classcugl_1_1_affine2.html">Affine2</a> &amp;transform)</td></tr>
<tr class="separator:acc4bc214a1acbfb72d922cd6965f7e9b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeccc10956ac546f4fee38e0999bc995c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classcugl_1_1_poly2.html">Poly2</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1_poly2.html#aeccc10956ac546f4fee38e0999bc995c">operator*=</a> (const <a class="el" href="classcugl_1_1_mat4.html">Mat4</a> &amp;transform)</td></tr>
<tr class="separator:aeccc10956ac546f4fee38e0999bc995c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a355a0700d44a713bd0ad8c46c14d042d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classcugl_1_1_poly2.html">Poly2</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1_poly2.html#a355a0700d44a713bd0ad8c46c14d042d">operator/=</a> (float scale)</td></tr>
<tr class="separator:a355a0700d44a713bd0ad8c46c14d042d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad9b965c4252f2ec445517cf0c3a90b25"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classcugl_1_1_poly2.html">Poly2</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1_poly2.html#ad9b965c4252f2ec445517cf0c3a90b25">operator/=</a> (const <a class="el" href="classcugl_1_1_vec2.html">Vec2</a> scale)</td></tr>
<tr class="separator:ad9b965c4252f2ec445517cf0c3a90b25"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a96ac040b2285273f3084bae4ccfe5de0"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classcugl_1_1_poly2.html">Poly2</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1_poly2.html#a96ac040b2285273f3084bae4ccfe5de0">operator+=</a> (float offset)</td></tr>
<tr class="separator:a96ac040b2285273f3084bae4ccfe5de0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a10c8adb3804b5d1dcab2ea2138b9c7e7"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classcugl_1_1_poly2.html">Poly2</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1_poly2.html#a10c8adb3804b5d1dcab2ea2138b9c7e7">operator+=</a> (const <a class="el" href="classcugl_1_1_vec2.html">Vec2</a> offset)</td></tr>
<tr class="separator:a10c8adb3804b5d1dcab2ea2138b9c7e7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a311dfe1493e17b55a8a6053639acb7b8"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classcugl_1_1_poly2.html">Poly2</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1_poly2.html#a311dfe1493e17b55a8a6053639acb7b8">operator-=</a> (float offset)</td></tr>
<tr class="separator:a311dfe1493e17b55a8a6053639acb7b8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5dcc06559e149c5d6b65265acff351bd"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classcugl_1_1_poly2.html">Poly2</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1_poly2.html#a5dcc06559e149c5d6b65265acff351bd">operator-=</a> (const <a class="el" href="classcugl_1_1_vec2.html">Vec2</a> offset)</td></tr>
<tr class="separator:a5dcc06559e149c5d6b65265acff351bd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa3977dc0cb3f1b5b94e34e9516b00762"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classcugl_1_1_poly2.html">Poly2</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1_poly2.html#aa3977dc0cb3f1b5b94e34e9516b00762">operator*</a> (float scale) const</td></tr>
<tr class="separator:aa3977dc0cb3f1b5b94e34e9516b00762"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4ac6aaf85c1b1c0ee0221fc410a7e4ce"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classcugl_1_1_poly2.html">Poly2</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1_poly2.html#a4ac6aaf85c1b1c0ee0221fc410a7e4ce">operator*</a> (const <a class="el" href="classcugl_1_1_vec2.html">Vec2</a> scale) const</td></tr>
<tr class="separator:a4ac6aaf85c1b1c0ee0221fc410a7e4ce"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3e3f1e6cf8575241fbebe5de05bbbbf1"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classcugl_1_1_poly2.html">Poly2</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1_poly2.html#a3e3f1e6cf8575241fbebe5de05bbbbf1">operator*</a> (const <a class="el" href="classcugl_1_1_affine2.html">Affine2</a> &amp;transform) const</td></tr>
<tr class="separator:a3e3f1e6cf8575241fbebe5de05bbbbf1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac89d5996b72c847c11f002c42a03954b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classcugl_1_1_poly2.html">Poly2</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1_poly2.html#ac89d5996b72c847c11f002c42a03954b">operator*</a> (const <a class="el" href="classcugl_1_1_mat4.html">Mat4</a> &amp;transform) const</td></tr>
<tr class="separator:ac89d5996b72c847c11f002c42a03954b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae6821a805d598c3cb9315d3db3950c9d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classcugl_1_1_poly2.html">Poly2</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1_poly2.html#ae6821a805d598c3cb9315d3db3950c9d">operator/</a> (float scale) const</td></tr>
<tr class="separator:ae6821a805d598c3cb9315d3db3950c9d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a95c776939534ac4bbd4c799cfa2559c0"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classcugl_1_1_poly2.html">Poly2</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1_poly2.html#a95c776939534ac4bbd4c799cfa2559c0">operator/</a> (const <a class="el" href="classcugl_1_1_vec2.html">Vec2</a> scale) const</td></tr>
<tr class="separator:a95c776939534ac4bbd4c799cfa2559c0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adeca9a101f46155362df17c7cd214eb1"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classcugl_1_1_poly2.html">Poly2</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1_poly2.html#adeca9a101f46155362df17c7cd214eb1">operator+</a> (float offset) const</td></tr>
<tr class="separator:adeca9a101f46155362df17c7cd214eb1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab67708c681602d5a5b2d5fafff118bbe"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classcugl_1_1_poly2.html">Poly2</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1_poly2.html#ab67708c681602d5a5b2d5fafff118bbe">operator+</a> (const <a class="el" href="classcugl_1_1_vec2.html">Vec2</a> offset) const</td></tr>
<tr class="separator:ab67708c681602d5a5b2d5fafff118bbe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a92f415df334678257b7fb42e3c05130c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classcugl_1_1_poly2.html">Poly2</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1_poly2.html#a92f415df334678257b7fb42e3c05130c">operator-</a> (float offset)</td></tr>
<tr class="separator:a92f415df334678257b7fb42e3c05130c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a11ea5623ea7ac422a357ab2eb4d37073"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classcugl_1_1_poly2.html">Poly2</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1_poly2.html#a11ea5623ea7ac422a357ab2eb4d37073">operator-</a> (const <a class="el" href="classcugl_1_1_vec2.html">Vec2</a> offset)</td></tr>
<tr class="separator:a11ea5623ea7ac422a357ab2eb4d37073"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2439c5ed2bab415890c23ea3b3611c3d"><td class="memItemLeft" align="right" valign="top">std::vector&lt; <a class="el" href="classcugl_1_1_vec2.html">Vec2</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1_poly2.html#a2439c5ed2bab415890c23ea3b3611c3d">convexHull</a> () const</td></tr>
<tr class="separator:a2439c5ed2bab415890c23ea3b3611c3d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a37d6e733edad11937d1188b29d0d221f"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1_poly2.html#a37d6e733edad11937d1188b29d0d221f">contains</a> (<a class="el" href="classcugl_1_1_vec2.html">Vec2</a> point, bool implicit=false) const</td></tr>
<tr class="separator:a37d6e733edad11937d1188b29d0d221f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9f426b3eb754bb854bf3d01eabd5c307"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1_poly2.html#a9f426b3eb754bb854bf3d01eabd5c307">contains</a> (float x, float y, bool implicit=false) const</td></tr>
<tr class="separator:a9f426b3eb754bb854bf3d01eabd5c307"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a31486a2e03fa6b10991ccbefa2c7286b"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1_poly2.html#a31486a2e03fa6b10991ccbefa2c7286b">incident</a> (<a class="el" href="classcugl_1_1_vec2.html">Vec2</a> point, float err=CU_MATH_EPSILON) const</td></tr>
<tr class="separator:a31486a2e03fa6b10991ccbefa2c7286b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a908563e3ba38140d01ef1e40527714b2"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1_poly2.html#a908563e3ba38140d01ef1e40527714b2">incident</a> (float x, float y, float err=CU_MATH_EPSILON) const</td></tr>
<tr class="separator:a908563e3ba38140d01ef1e40527714b2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0d4ef0263dab04834308e25abe8816df"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1_poly2.html#a0d4ef0263dab04834308e25abe8816df">orientation</a> () const</td></tr>
<tr class="separator:a0d4ef0263dab04834308e25abe8816df"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab988f04b1c87b34677e59407b3f2f548"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1_poly2.html#ab988f04b1c87b34677e59407b3f2f548">reverse</a> ()</td></tr>
<tr class="separator:ab988f04b1c87b34677e59407b3f2f548"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8a1bf499f18cf07e2ccb3d85d10b8b14"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1_poly2.html#a8a1bf499f18cf07e2ccb3d85d10b8b14">toString</a> (bool verbose=false) const</td></tr>
<tr class="separator:a8a1bf499f18cf07e2ccb3d85d10b8b14"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8cbef20c18ca2f1e3df4b037904ce95d"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1_poly2.html#a8cbef20c18ca2f1e3df4b037904ce95d">operator std::string</a> () const</td></tr>
<tr class="separator:a8cbef20c18ca2f1e3df4b037904ce95d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a218d53ad795098969e3e21af271445d3"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1_poly2.html#a218d53ad795098969e3e21af271445d3">operator Rect</a> () const</td></tr>
<tr class="separator:a218d53ad795098969e3e21af271445d3"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-static-methods"></a>
Static Public Member Functions</h2></td></tr>
<tr class="memitem:afbcf9e317fec7f8d41aac537aeeddef8"><td class="memItemLeft" align="right" valign="top">static int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1_poly2.html#afbcf9e317fec7f8d41aac537aeeddef8">orientation</a> (<a class="el" href="classcugl_1_1_vec2.html">Vec2</a> a, <a class="el" href="classcugl_1_1_vec2.html">Vec2</a> b, <a class="el" href="classcugl_1_1_vec2.html">Vec2</a> c)</td></tr>
<tr class="separator:afbcf9e317fec7f8d41aac537aeeddef8"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="friends"></a>
Friends</h2></td></tr>
<tr class="memitem:aa89c17022ebf69f880ca27f30f97ebdb"><td class="memItemLeft" align="right" valign="top"><a id="aa89c17022ebf69f880ca27f30f97ebdb"></a>
class&#160;</td><td class="memItemRight" valign="bottom"><b>PolyFactory</b></td></tr>
<tr class="separator:aa89c17022ebf69f880ca27f30f97ebdb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a71f420307b8ecc0bc5adcd62f81adec4"><td class="memItemLeft" align="right" valign="top"><a id="a71f420307b8ecc0bc5adcd62f81adec4"></a>
class&#160;</td><td class="memItemRight" valign="bottom"><b>PolySplineFactory</b></td></tr>
<tr class="separator:a71f420307b8ecc0bc5adcd62f81adec4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa0c05fc3ec7fc37ee87f0811d29c641d"><td class="memItemLeft" align="right" valign="top"><a id="aa0c05fc3ec7fc37ee87f0811d29c641d"></a>
class&#160;</td><td class="memItemRight" valign="bottom"><b>SimpleTriangulator</b></td></tr>
<tr class="separator:aa0c05fc3ec7fc37ee87f0811d29c641d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a45d48a6e22365313a665ec5f2f311197"><td class="memItemLeft" align="right" valign="top"><a id="a45d48a6e22365313a665ec5f2f311197"></a>
class&#160;</td><td class="memItemRight" valign="bottom"><b>ComplexTriangulator</b></td></tr>
<tr class="separator:a45d48a6e22365313a665ec5f2f311197"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a57172dfa087d0069d14a1e700fc6f2ea"><td class="memItemLeft" align="right" valign="top"><a id="a57172dfa087d0069d14a1e700fc6f2ea"></a>
class&#160;</td><td class="memItemRight" valign="bottom"><b>SimpleExtruder</b></td></tr>
<tr class="separator:a57172dfa087d0069d14a1e700fc6f2ea"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a60be208a1c80426681b54458c8d9fd26"><td class="memItemLeft" align="right" valign="top"><a id="a60be208a1c80426681b54458c8d9fd26"></a>
class&#160;</td><td class="memItemRight" valign="bottom"><b>ComplexExtruder</b></td></tr>
<tr class="separator:a60be208a1c80426681b54458c8d9fd26"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad9a607abf40823204008f899970abc43"><td class="memItemLeft" align="right" valign="top"><a id="ad9a607abf40823204008f899970abc43"></a>
class&#160;</td><td class="memItemRight" valign="bottom"><b>PathSmoother</b></td></tr>
<tr class="separator:ad9a607abf40823204008f899970abc43"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af8ef5e90dbed6e69b06346ceeddb4b0a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classcugl_1_1_poly2.html">Poly2</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1_poly2.html#af8ef5e90dbed6e69b06346ceeddb4b0a">operator*</a> (float scale, const <a class="el" href="classcugl_1_1_poly2.html">Poly2</a> &amp;poly)</td></tr>
<tr class="separator:af8ef5e90dbed6e69b06346ceeddb4b0a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0c31c4aecf2ff550474d415d76723b1c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classcugl_1_1_poly2.html">Poly2</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1_poly2.html#a0c31c4aecf2ff550474d415d76723b1c">operator*</a> (const <a class="el" href="classcugl_1_1_vec2.html">Vec2</a> scale, const <a class="el" href="classcugl_1_1_poly2.html">Poly2</a> &amp;poly)</td></tr>
<tr class="separator:a0c31c4aecf2ff550474d415d76723b1c"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Class to represent a simple polygon.</p>
<p>This class is intended to represent any polygon (including non-convex polygons). that does not have self-interections (as these can cause serious problems with the mathematics). Most polygons are simple, meaning that they have no holes. However, this class does support complex polygons with holes, provided that the polygon is not implicit and has an corresponding mesh.</p>
<p>To define a mesh, the user should provide a set of indices which will be used in rendering. These indices can either represent a triangulation of the polygon, or they can represent a traversal (for a wireframe). The semantics of these indices is provided by the associated <a class="el" href="classcugl_1_1_geometry.html">value</a>. This class performs no verification. It will not check that a mesh is in proper form, nor will it search for holes or self-intersections. These are the responsibility of the programmer.</p>
<p>Generating indices for a <a class="el" href="classcugl_1_1_poly2.html">Poly2</a> can be nontrivial. While this class has standard constructors, allowing the programmer full control, most <a class="el" href="classcugl_1_1_poly2.html">Poly2</a> objects are created through alternate means. For simple shapes, like lines, triangles, and ellipses, this class has several static constructors.</p>
<p>For more complex shapes, we have several <a class="el" href="classcugl_1_1_poly2.html">Poly2</a> factories. These factories allow for delegating index computation to a separate thread, if it takes too long. These factories are as follows:</p>
<p><a class="el" href="classcugl_1_1_simple_triangulator.html">SimpleTriangulator</a>: This is a simple earclipping-triangulator for tesselating simple, solid polygons (e.g. no holes or self-intersections).</p>
<p><a class="el" href="classcugl_1_1_complex_triangulator.html">ComplexTriangulator</a>: This is a Delaunay Triangular that gives a more uniform triangulation in accordance to the Vornoi diagram. It also allows you to create 2d meshes while holes inside of them.</p>
<p><a class="el" href="classcugl_1_1_poly_factory.html">PolyFactory</a>: This is a tool is used to generate several basic path shapes, such as rounded rectangles or arcs. It also allows you construct wireframe traversals of existing polygons.</p>
<p><a class="el" href="classcugl_1_1_poly_spline_factory.html">PolySplineFactory</a>: This is a tool is used to generate a <a class="el" href="classcugl_1_1_poly2.html">Poly2</a> object from a Cubic Bezier curve.</p>
<p><a class="el" href="classcugl_1_1_simple_extruder.html">SimpleExtruder</a>: This is a tool can take a path polygon and convert it into a solid polygon. This solid polygon is the same as the path, except that the path now has a width and a mitre at the joints. It is fast, but has graphical limitations.</p>
<p><a class="el" href="classcugl_1_1_complex_extruder.html">ComplexExtruder</a>: Like <a class="el" href="classcugl_1_1_simple_extruder.html">SimpleExtruder</a>, this is a tool can take a path polygon and convert it into a solid polygon. It is incredibly versatile and works in all instances. However, it is extremely slow (in the 10s of milliseconds) and is unsuitable for calcuations at framerate. </p>
</div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="ad36500275b41ae48913824f24cb59428"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad36500275b41ae48913824f24cb59428">&#9670;&nbsp;</a></span>Poly2() <span class="overload">[1/10]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">cugl::Poly2::Poly2 </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Creates an empty polygon.</p>
<p>The created polygon has no vertices and no triangulation. The bounding box is trivial. </p>

</div>
</div>
<a id="a63eb274b29f3beb7d0999deeb5190b8a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a63eb274b29f3beb7d0999deeb5190b8a">&#9670;&nbsp;</a></span>Poly2() <span class="overload">[2/10]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">cugl::Poly2::Poly2 </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="classcugl_1_1_vec2.html">Vec2</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>vertices</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Creates a polygon with the given vertices</p>
<p>The new polygon has no indices and the geometry is <code>IMPLICIT</code>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">vertices</td><td>The vector of vertices (as <a class="el" href="classcugl_1_1_vec2.html">Vec2</a>) in this polygon </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a4690381d3582cd041145de5f15d67c82"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4690381d3582cd041145de5f15d67c82">&#9670;&nbsp;</a></span>Poly2() <span class="overload">[3/10]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">cugl::Poly2::Poly2 </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="classcugl_1_1_vec2.html">Vec2</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>vertices</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; Uint32 &gt; &amp;&#160;</td>
          <td class="paramname"><em>indices</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Creates a polygon with the given vertices and indices.</p>
<p>A valid list of indices must only refer to vertices in the vertex array. That is, the indices should all be non-negative, and each value should be less than the number of vertices.</p>
<p>The index geometry will be assigned via <a class="el" href="classcugl_1_1_geometry.html#ae8d10b1530c4b2e8707fd77ccd87bfb2">Geometry#categorize</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">vertices</td><td>The vector of vertices (as <a class="el" href="classcugl_1_1_vec2.html">Vec2</a>) in this polygon </td></tr>
    <tr><td class="paramname">indices</td><td>The vector of indices for the rendering </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="afd60a8920a146c79a83dc748b47c759e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afd60a8920a146c79a83dc748b47c759e">&#9670;&nbsp;</a></span>Poly2() <span class="overload">[4/10]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">cugl::Poly2::Poly2 </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; float &gt; &amp;&#160;</td>
          <td class="paramname"><em>vertices</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Creates a polygon with the given vertices</p>
<p>The new polygon has no indices.</p>
<p>The float array should have an even number of elements. The number of vertices is half of the size of the array. For each value ii, 2*ii and 2*ii+1 are the coordinates of a single vertex.</p>
<p>The new polygon has no indices and the geometry is <code>IMPLICIT</code>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">vertices</td><td>The vector of vertices (as floats) in this polygon </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a9f280a863a4171159e385e447859b224"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9f280a863a4171159e385e447859b224">&#9670;&nbsp;</a></span>Poly2() <span class="overload">[5/10]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">cugl::Poly2::Poly2 </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; float &gt; &amp;&#160;</td>
          <td class="paramname"><em>vertices</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; Uint32 &gt; &amp;&#160;</td>
          <td class="paramname"><em>indices</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Creates a polygon with the given vertices and indices.</p>
<p>The float array should have an even number of elements. The number of vertices is half of the size of the array. For each value ii, 2*ii and 2*ii+1 are the coordinates of a single vertex.</p>
<p>A valid list of indices must only refer to vertices in the vertex array. That is, the indices should all be non-negative, and each value should be less than the number of vertices.</p>
<p>The index geometry will be assigned via <a class="el" href="classcugl_1_1_geometry.html#ae8d10b1530c4b2e8707fd77ccd87bfb2">Geometry#categorize</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">vertices</td><td>The vector of vertices (as floats) in this polygon </td></tr>
    <tr><td class="paramname">indices</td><td>The vector of indices for the rendering </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a0ee7bbe772a9a59cdfae4b0aa552ca28"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0ee7bbe772a9a59cdfae4b0aa552ca28">&#9670;&nbsp;</a></span>Poly2() <span class="overload">[6/10]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">cugl::Poly2::Poly2 </td>
          <td>(</td>
          <td class="paramtype">const float *&#160;</td>
          <td class="paramname"><em>vertices</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>vertsize</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Creates a polygon with the given vertices</p>
<p>The new polygon has no indices and the geometry is <code>IMPLICIT</code>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">vertices</td><td>The array of vertices (as <a class="el" href="classcugl_1_1_vec2.html">Vec2</a>) in this polygon </td></tr>
    <tr><td class="paramname">vertsize</td><td>The number of elements to use from vertices </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="adbadaa87b1409167328b35b7408f5648"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adbadaa87b1409167328b35b7408f5648">&#9670;&nbsp;</a></span>Poly2() <span class="overload">[7/10]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">cugl::Poly2::Poly2 </td>
          <td>(</td>
          <td class="paramtype">const float *&#160;</td>
          <td class="paramname"><em>vertices</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>vertsize</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Uint32 *&#160;</td>
          <td class="paramname"><em>indices</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>indxsize</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Creates a polygon with the given vertices and indices.</p>
<p>A valid list of indices must only refer to vertices in the vertex array. That is, the indices should all be non-negative, and each value should be less than the number of vertices.</p>
<p>The index geometry will be assigned via <a class="el" href="classcugl_1_1_geometry.html#ae8d10b1530c4b2e8707fd77ccd87bfb2">Geometry#categorize</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">vertices</td><td>The array of vertices (as <a class="el" href="classcugl_1_1_vec2.html">Vec2</a>) in this polygon </td></tr>
    <tr><td class="paramname">vertsize</td><td>The number of elements to use from vertices </td></tr>
    <tr><td class="paramname">indices</td><td>The array of indices for the rendering </td></tr>
    <tr><td class="paramname">indxsize</td><td>The number of elements to use for the indices </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a21093987251fe8a1ecf4b880a7b320a8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a21093987251fe8a1ecf4b880a7b320a8">&#9670;&nbsp;</a></span>Poly2() <span class="overload">[8/10]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">cugl::Poly2::Poly2 </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classcugl_1_1_poly2.html">Poly2</a> &amp;&#160;</td>
          <td class="paramname"><em>poly</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Creates a copy of the given polygon.</p>
<p>Both the vertices and the indices are copied.No references to the original polygon are kept.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">poly</td><td>The polygon to copy </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a02c6a814620aab3d2de59582a307bca8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a02c6a814620aab3d2de59582a307bca8">&#9670;&nbsp;</a></span>Poly2() <span class="overload">[9/10]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">cugl::Poly2::Poly2 </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classcugl_1_1_poly2.html">Poly2</a> &amp;&amp;&#160;</td>
          <td class="paramname"><em>poly</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Creates a copy with the resource of the given polygon.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">poly</td><td>The polygon to take from </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a872fcad0e6881ef8cb6ab0ef6464705e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a872fcad0e6881ef8cb6ab0ef6464705e">&#9670;&nbsp;</a></span>Poly2() <span class="overload">[10/10]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">cugl::Poly2::Poly2 </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classcugl_1_1_rect.html">Rect</a>&#160;</td>
          <td class="paramname"><em>rect</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>solid</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Creates a polygon for the given rectangle.</p>
<p>The polygon will have four vertices, one for each corner of the rectangle. This optional argument (which is true by default) will initialize the indices with a triangulation of the rectangle. In other words, the geometry will be <code>SOLID</code>. This is faster than using one of the more heavy-weight triangulators.</p>
<p>If solid is false, it will still generate indices, but will have <code>CLOSED</code> geometry instead.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">rect</td><td>The rectangle to copy </td></tr>
    <tr><td class="paramname">solid</td><td>Whether to treat this rectangle as a solid polygon </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a98c9fd41a7666abf2ca1bd337ecf5054"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a98c9fd41a7666abf2ca1bd337ecf5054">&#9670;&nbsp;</a></span>~Poly2()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">cugl::Poly2::~Poly2 </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Deletes the given polygon, freeing all resources. </p>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="a62777945434b34ba0b5be4133639d208"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a62777945434b34ba0b5be4133639d208">&#9670;&nbsp;</a></span>at()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcugl_1_1_vec2.html">Vec2</a>&amp; cugl::Poly2::at </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>index</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns a reference to the attribute at the given index.</p>
<p>This accessor will allow you to change the (singular) vertex. It is intended to allow minor distortions to the polygon without changing the underlying mesh.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">index</td><td>The attribute index</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a reference to the attribute at the given index. </dd></dl>

</div>
</div>
<a id="a6958e6551dfbc82a1f70ee67887f0258"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6958e6551dfbc82a1f70ee67887f0258">&#9670;&nbsp;</a></span>clear()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcugl_1_1_poly2.html">Poly2</a>&amp; cugl::Poly2::clear </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Clears the contents of this polygon and sets the geometry to <code>IMPLICIT</code></p>
<dl class="section return"><dt>Returns</dt><dd>This polygon, returned for chaining </dd></dl>

</div>
</div>
<a id="a9f426b3eb754bb854bf3d01eabd5c307"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9f426b3eb754bb854bf3d01eabd5c307">&#9670;&nbsp;</a></span>contains() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool cugl::Poly2::contains </td>
          <td>(</td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>implicit</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns true if this polygon contains the given point.</p>
<p>This method returns false is the geometry is <code>POINTS</code>. If the geometry is <code>SOLID</code>, it checks for containment within the associated triangle mesh. Otherwise, it uses an even-odd crossing rule on the polygon edges (either explicit or implicit) to determine containment.</p>
<p>If the value implicit is true, it will treat the polygon implicitly, even if it has a mesh (and no matter the geometry).</p>
<p>Containment is not strict. Points on the boundary are contained within this polygon.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>The x-coordinate to test </td></tr>
    <tr><td class="paramname">y</td><td>The y-coordinate to test </td></tr>
    <tr><td class="paramname">implicit</td><td>Whether to ignore indices and use even-odd on vertices</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if this polygon contains the given point. </dd></dl>

</div>
</div>
<a id="a37d6e733edad11937d1188b29d0d221f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a37d6e733edad11937d1188b29d0d221f">&#9670;&nbsp;</a></span>contains() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool cugl::Poly2::contains </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classcugl_1_1_vec2.html">Vec2</a>&#160;</td>
          <td class="paramname"><em>point</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>implicit</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns true if this polygon contains the given point.</p>
<p>This method returns false is the geometry is <code>POINTS</code>. If the geometry is <code>SOLID</code>, it checks for containment within the associated triangle mesh. Otherwise, it uses an even-odd crossing rule on the polygon edges (either explicit or implicit) to determine containment.</p>
<p>If the value implicit is true, it will treat the polygon implicitly, even if it has a mesh (and no matter the geometry).</p>
<p>Containment is not strict. Points on the boundary are contained within this polygon.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">point</td><td>The point to test </td></tr>
    <tr><td class="paramname">implicit</td><td>Whether to ignore indices and use even-odd on vertices</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if this polygon contains the given point. </dd></dl>

</div>
</div>
<a id="a2439c5ed2bab415890c23ea3b3611c3d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2439c5ed2bab415890c23ea3b3611c3d">&#9670;&nbsp;</a></span>convexHull()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;<a class="el" href="classcugl_1_1_vec2.html">Vec2</a>&gt; cugl::Poly2::convexHull </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns the set of points forming the convex hull of this polygon.</p>
<p>The returned set of points is guaranteed to be a counter-clockwise traversal of the hull.</p>
<p>The points on the convex hull define the "border" of the shape. In addition to minimizing the number of vertices, this is useful for determining whether or not a point lies on the boundary.</p>
<p>This implementation is adapted from the example at</p>
<p><a href="http://www.geeksforgeeks.org/convex-hull-set-2-graham-scan/">http://www.geeksforgeeks.org/convex-hull-set-2-graham-scan/</a></p>
<dl class="section return"><dt>Returns</dt><dd>the set of points forming the convex hull of this polygon. </dd></dl>

</div>
</div>
<a id="a32c556ea07df156fd3658f7894f2a704"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a32c556ea07df156fd3658f7894f2a704">&#9670;&nbsp;</a></span>getBounds()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classcugl_1_1_rect.html">Rect</a> cugl::Poly2::getBounds </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns the bounding box for the polygon</p>
<p>The bounding box is the minimal rectangle that contains all of the vertices in this polygon. It is recomputed whenever the vertices are set.</p>
<dl class="section return"><dt>Returns</dt><dd>the bounding box for the polygon </dd></dl>

</div>
</div>
<a id="aed1c7ad12f1f281048c981683aa1068c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aed1c7ad12f1f281048c981683aa1068c">&#9670;&nbsp;</a></span>getGeometry()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcugl_1_1_geometry.html">Geometry</a> cugl::Poly2::getGeometry </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns the geometry of this polygon.</p>
<p>The type determines the proper form of the indices.</p>
<p>If the geometry is <code>SOLID</code>, the number of indices should be a multiple of 3. Each triplet should define a triangle over the vertices.</p>
<p>If the geometry is <code>PATH</code>, the number of indices should be a multiple of 2. Each pair should define a line segment over the vertices.</p>
<p>If the polygon is <code>IMPLICIT</code>, the index list should be empty.</p>
<dl class="section return"><dt>Returns</dt><dd>the geometry of this polygon. </dd></dl>

</div>
</div>
<a id="a908563e3ba38140d01ef1e40527714b2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a908563e3ba38140d01ef1e40527714b2">&#9670;&nbsp;</a></span>incident() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool cugl::Poly2::incident </td>
          <td>(</td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>err</em> = <code>CU_MATH_EPSILON</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns true if the given point is on the boundary of this polygon.</p>
<p>This method generates uses <a class="el" href="classcugl_1_1_geometry.html">Geometry</a> to determine the boundaries. For `POINTS, it returns true if point is with margin of error of a vertex. For all other shapes it returns true if it is within margin of error of a line segment.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>The x-coordinate to test </td></tr>
    <tr><td class="paramname">y</td><td>The y-coordinate to test </td></tr>
    <tr><td class="paramname">err</td><td>The distance tolerance</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if the given point is on the boundary of this polygon. </dd></dl>

</div>
</div>
<a id="a31486a2e03fa6b10991ccbefa2c7286b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a31486a2e03fa6b10991ccbefa2c7286b">&#9670;&nbsp;</a></span>incident() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool cugl::Poly2::incident </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classcugl_1_1_vec2.html">Vec2</a>&#160;</td>
          <td class="paramname"><em>point</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>err</em> = <code>CU_MATH_EPSILON</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns true if the given point is on the boundary of this polygon.</p>
<p>This method generates uses <a class="el" href="classcugl_1_1_geometry.html">Geometry</a> to determine the boundaries. For `POINTS, it returns true if point is with margin of error of a vertex. For all other shapes it returns true if it is within margin of error of a line segment.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">point</td><td>The point to check </td></tr>
    <tr><td class="paramname">err</td><td>The distance tolerance</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if the given point is on the boundary of this polygon. </dd></dl>

</div>
</div>
<a id="afd0144296a9b8416146e3b34252d17f2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afd0144296a9b8416146e3b34252d17f2">&#9670;&nbsp;</a></span>indexSize()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_t cugl::Poly2::indexSize </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns the number of indices in a polygon.</p>
<dl class="section return"><dt>Returns</dt><dd>the number of indices in a polygon. </dd></dl>

</div>
</div>
<a id="aba612cf31d8af93c9b3d445dca49d8c5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aba612cf31d8af93c9b3d445dca49d8c5">&#9670;&nbsp;</a></span>indices() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;Uint32&gt;&amp; cugl::Poly2::indices </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns a reference to list of indices.</p>
<p>This accessor will not permit any changes to the index array. To change the array, you must change the polygon via a <a class="el" href="classcugl_1_1_poly2.html#a33366d9d9a73620d93591dfdd78f177d">set()</a> method.</p>
<p>This non-const version of the method is used by triangulators.</p>
<dl class="section return"><dt>Returns</dt><dd>a reference to the vertex array </dd></dl>

</div>
</div>
<a id="a1c973c09c9c018eb312a64024171b512"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1c973c09c9c018eb312a64024171b512">&#9670;&nbsp;</a></span>indices() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const std::vector&lt;Uint32&gt;&amp; cugl::Poly2::indices </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns a reference to list of indices.</p>
<p>This accessor will not permit any changes to the index array. To change the array, you must change the polygon via a <a class="el" href="classcugl_1_1_poly2.html#a33366d9d9a73620d93591dfdd78f177d">set()</a> method.</p>
<dl class="section return"><dt>Returns</dt><dd>a reference to the vertex array </dd></dl>

</div>
</div>
<a id="a218d53ad795098969e3e21af271445d3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a218d53ad795098969e3e21af271445d3">&#9670;&nbsp;</a></span>operator Rect()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">cugl::Poly2::operator <a class="el" href="classcugl_1_1_rect.html">Rect</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Cast from <a class="el" href="classcugl_1_1_poly2.html">Poly2</a> to a <a class="el" href="classcugl_1_1_rect.html">Rect</a>. </p>

</div>
</div>
<a id="a8cbef20c18ca2f1e3df4b037904ce95d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8cbef20c18ca2f1e3df4b037904ce95d">&#9670;&nbsp;</a></span>operator std::string()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">cugl::Poly2::operator std::string </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Cast from Poly to a string. </p>

</div>
</div>
<a id="a3e3f1e6cf8575241fbebe5de05bbbbf1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3e3f1e6cf8575241fbebe5de05bbbbf1">&#9670;&nbsp;</a></span>operator*() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcugl_1_1_poly2.html">Poly2</a> cugl::Poly2::operator* </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classcugl_1_1_affine2.html">Affine2</a> &amp;&#160;</td>
          <td class="paramname"><em>transform</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns a new polygon by transforming all of the vertices of this polygon.</p>
<p>Note: This method does not modify the polygon.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">transform</td><td>The affine transform</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The transformed polygon </dd></dl>

</div>
</div>
<a id="ac89d5996b72c847c11f002c42a03954b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac89d5996b72c847c11f002c42a03954b">&#9670;&nbsp;</a></span>operator*() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcugl_1_1_poly2.html">Poly2</a> cugl::Poly2::operator* </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classcugl_1_1_mat4.html">Mat4</a> &amp;&#160;</td>
          <td class="paramname"><em>transform</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns a new polygon by transforming all of the vertices of this polygon.</p>
<p>The vertices are transformed as points. The z-value is 0.</p>
<p>Note: This method does not modify the polygon.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">transform</td><td>The transform matrix</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The transformed polygon </dd></dl>

</div>
</div>
<a id="a4ac6aaf85c1b1c0ee0221fc410a7e4ce"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4ac6aaf85c1b1c0ee0221fc410a7e4ce">&#9670;&nbsp;</a></span>operator*() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcugl_1_1_poly2.html">Poly2</a> cugl::Poly2::operator* </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classcugl_1_1_vec2.html">Vec2</a>&#160;</td>
          <td class="paramname"><em>scale</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns a new polygon by scaling the vertices non-uniformly.</p>
<p>The vertices are scaled from the origin of the coordinate space. This means that if the origin is not in the interior of this polygon, the polygon will be effectively translated by the scaling.</p>
<p>Note: This method does not modify the polygon.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">scale</td><td>The non-uniform scaling factor</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The scaled polygon </dd></dl>

</div>
</div>
<a id="aa3977dc0cb3f1b5b94e34e9516b00762"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa3977dc0cb3f1b5b94e34e9516b00762">&#9670;&nbsp;</a></span>operator*() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcugl_1_1_poly2.html">Poly2</a> cugl::Poly2::operator* </td>
          <td>(</td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>scale</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns a new polygon by scaling the vertices uniformly.</p>
<p>The vertices are scaled from the origin of the coordinate space. This means that if the origin is not in the interior of this polygon, the polygon will be effectively translated by the scaling.</p>
<p>Note: This method does not modify the polygon.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">scale</td><td>The uniform scaling factor</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The scaled polygon </dd></dl>

</div>
</div>
<a id="acc4bc214a1acbfb72d922cd6965f7e9b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acc4bc214a1acbfb72d922cd6965f7e9b">&#9670;&nbsp;</a></span>operator*=() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcugl_1_1_poly2.html">Poly2</a>&amp; cugl::Poly2::operator*= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classcugl_1_1_affine2.html">Affine2</a> &amp;&#160;</td>
          <td class="paramname"><em>transform</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Transforms all of the vertices of this polygon.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">transform</td><td>The affine transform</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>This polygon with the vertices transformed </dd></dl>

</div>
</div>
<a id="aeccc10956ac546f4fee38e0999bc995c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aeccc10956ac546f4fee38e0999bc995c">&#9670;&nbsp;</a></span>operator*=() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcugl_1_1_poly2.html">Poly2</a>&amp; cugl::Poly2::operator*= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classcugl_1_1_mat4.html">Mat4</a> &amp;&#160;</td>
          <td class="paramname"><em>transform</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Transforms all of the vertices of this polygon.</p>
<p>The vertices are transformed as points. The z-value is 0.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">transform</td><td>The transform matrix</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>This polygon with the vertices transformed </dd></dl>

</div>
</div>
<a id="a0dfef1a8280639ae720b116a521e2cc7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0dfef1a8280639ae720b116a521e2cc7">&#9670;&nbsp;</a></span>operator*=() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcugl_1_1_poly2.html">Poly2</a>&amp; cugl::Poly2::operator*= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classcugl_1_1_vec2.html">Vec2</a>&#160;</td>
          <td class="paramname"><em>scale</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Nonuniformly scales all of the vertices of this polygon.</p>
<p>The vertices are scaled from the origin of the coordinate space. This means that if the origin is not in the interior of this polygon, the polygon will be effectively translated by the scaling.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">scale</td><td>The non-uniform scaling factor</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>This polygon, scaled non-uniformly. </dd></dl>

</div>
</div>
<a id="aadd955e9a4490209fb083c9b97f4c331"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aadd955e9a4490209fb083c9b97f4c331">&#9670;&nbsp;</a></span>operator*=() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcugl_1_1_poly2.html">Poly2</a>&amp; cugl::Poly2::operator*= </td>
          <td>(</td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>scale</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Uniformly scales all of the vertices of this polygon.</p>
<p>The vertices are scaled from the origin of the coordinate space. This means that if the origin is not in the interior of this polygon, the polygon will be effectively translated by the scaling.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">scale</td><td>The uniform scaling factor</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>This polygon, scaled uniformly. </dd></dl>

</div>
</div>
<a id="ab67708c681602d5a5b2d5fafff118bbe"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab67708c681602d5a5b2d5fafff118bbe">&#9670;&nbsp;</a></span>operator+() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcugl_1_1_poly2.html">Poly2</a> cugl::Poly2::operator+ </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classcugl_1_1_vec2.html">Vec2</a>&#160;</td>
          <td class="paramname"><em>offset</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns a new polygon by translating the vertices non-uniformly.</p>
<p>Note: This method does not modify the polygon.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">offset</td><td>The non-uniform translation amount</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The translated polygon </dd></dl>

</div>
</div>
<a id="adeca9a101f46155362df17c7cd214eb1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adeca9a101f46155362df17c7cd214eb1">&#9670;&nbsp;</a></span>operator+() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcugl_1_1_poly2.html">Poly2</a> cugl::Poly2::operator+ </td>
          <td>(</td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>offset</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns a new polygon by translating the vertices uniformly.</p>
<p>Note: This method does not modify the polygon.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">offset</td><td>The uniform translation amount</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The translated polygon </dd></dl>

</div>
</div>
<a id="a10c8adb3804b5d1dcab2ea2138b9c7e7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a10c8adb3804b5d1dcab2ea2138b9c7e7">&#9670;&nbsp;</a></span>operator+=() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcugl_1_1_poly2.html">Poly2</a>&amp; cugl::Poly2::operator+= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classcugl_1_1_vec2.html">Vec2</a>&#160;</td>
          <td class="paramname"><em>offset</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Non-uniformly translates all of the vertices of this polygon.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">offset</td><td>The non-uniform translation amount</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>This polygon, translated non-uniformly. </dd></dl>

</div>
</div>
<a id="a96ac040b2285273f3084bae4ccfe5de0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a96ac040b2285273f3084bae4ccfe5de0">&#9670;&nbsp;</a></span>operator+=() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcugl_1_1_poly2.html">Poly2</a>&amp; cugl::Poly2::operator+= </td>
          <td>(</td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>offset</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Uniformly translates all of the vertices of this polygon.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">offset</td><td>The uniform translation amount</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>This polygon, translated uniformly. </dd></dl>

</div>
</div>
<a id="a11ea5623ea7ac422a357ab2eb4d37073"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a11ea5623ea7ac422a357ab2eb4d37073">&#9670;&nbsp;</a></span>operator-() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcugl_1_1_poly2.html">Poly2</a> cugl::Poly2::operator- </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classcugl_1_1_vec2.html">Vec2</a>&#160;</td>
          <td class="paramname"><em>offset</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns a new polygon by translating the vertices non-uniformly.</p>
<p>Note: This method does not modify the polygon.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">offset</td><td>The inverse of the non-uniform translation amount</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The translated polygon </dd></dl>

</div>
</div>
<a id="a92f415df334678257b7fb42e3c05130c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a92f415df334678257b7fb42e3c05130c">&#9670;&nbsp;</a></span>operator-() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcugl_1_1_poly2.html">Poly2</a> cugl::Poly2::operator- </td>
          <td>(</td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>offset</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns a new polygon by translating the vertices uniformly.</p>
<p>Note: This method does not modify the polygon.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">offset</td><td>The inverse of the uniform translation amount</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The translated polygon </dd></dl>

</div>
</div>
<a id="a5dcc06559e149c5d6b65265acff351bd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5dcc06559e149c5d6b65265acff351bd">&#9670;&nbsp;</a></span>operator-=() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcugl_1_1_poly2.html">Poly2</a>&amp; cugl::Poly2::operator-= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classcugl_1_1_vec2.html">Vec2</a>&#160;</td>
          <td class="paramname"><em>offset</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Non-uniformly translates all of the vertices of this polygon.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">offset</td><td>The inverse of the non-uniform translation amount</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>This polygon, translated non-uniformly. </dd></dl>

</div>
</div>
<a id="a311dfe1493e17b55a8a6053639acb7b8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a311dfe1493e17b55a8a6053639acb7b8">&#9670;&nbsp;</a></span>operator-=() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcugl_1_1_poly2.html">Poly2</a>&amp; cugl::Poly2::operator-= </td>
          <td>(</td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>offset</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Uniformly translates all of the vertices of this polygon.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">offset</td><td>The inverse of the uniform translation amount</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>This polygon, translated uniformly. </dd></dl>

</div>
</div>
<a id="a95c776939534ac4bbd4c799cfa2559c0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a95c776939534ac4bbd4c799cfa2559c0">&#9670;&nbsp;</a></span>operator/() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcugl_1_1_poly2.html">Poly2</a> cugl::Poly2::operator/ </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classcugl_1_1_vec2.html">Vec2</a>&#160;</td>
          <td class="paramname"><em>scale</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns a new polygon by scaling the vertices non-uniformly.</p>
<p>The vertices are scaled from the origin of the coordinate space. This means that if the origin is not in the interior of this polygon, the polygon will be effectively translated by the scaling.</p>
<p>Note: This method does not modify the polygon.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">scale</td><td>The inverse of the non-uniform scaling factor</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The scaled polygon </dd></dl>

</div>
</div>
<a id="ae6821a805d598c3cb9315d3db3950c9d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae6821a805d598c3cb9315d3db3950c9d">&#9670;&nbsp;</a></span>operator/() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcugl_1_1_poly2.html">Poly2</a> cugl::Poly2::operator/ </td>
          <td>(</td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>scale</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns a new polygon by scaling the vertices uniformly.</p>
<p>The vertices are scaled from the origin of the coordinate space. This means that if the origin is not in the interior of this polygon, the polygon will be effectively translated by the scaling.</p>
<p>Note: This method does not modify the polygon.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">scale</td><td>The inverse of the uniform scaling factor</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The scaled polygon </dd></dl>

</div>
</div>
<a id="ad9b965c4252f2ec445517cf0c3a90b25"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad9b965c4252f2ec445517cf0c3a90b25">&#9670;&nbsp;</a></span>operator/=() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcugl_1_1_poly2.html">Poly2</a>&amp; cugl::Poly2::operator/= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classcugl_1_1_vec2.html">Vec2</a>&#160;</td>
          <td class="paramname"><em>scale</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Nonuniformly scales all of the vertices of this polygon.</p>
<p>The vertices are scaled from the origin of the coordinate space. This means that if the origin is not in the interior of this polygon, the polygon will be effectively translated by the scaling.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">scale</td><td>The inverse of the non-uniform scaling factor</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>This polygon, scaled non-uniformly. </dd></dl>

</div>
</div>
<a id="a355a0700d44a713bd0ad8c46c14d042d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a355a0700d44a713bd0ad8c46c14d042d">&#9670;&nbsp;</a></span>operator/=() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcugl_1_1_poly2.html">Poly2</a>&amp; cugl::Poly2::operator/= </td>
          <td>(</td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>scale</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Uniformly scales all of the vertices of this polygon.</p>
<p>The vertices are scaled from the origin of the coordinate space. This means that if the origin is not in the interior of this polygon, the polygon will be effectively translated by the scaling.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">scale</td><td>The inverse of the uniform scaling factor</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>This polygon, scaled uniformly. </dd></dl>

</div>
</div>
<a id="aa1e51d73ea036f2efa9123d3952916ee"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa1e51d73ea036f2efa9123d3952916ee">&#9670;&nbsp;</a></span>operator=() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcugl_1_1_poly2.html">Poly2</a>&amp; cugl::Poly2::operator= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classcugl_1_1_poly2.html">Poly2</a> &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Sets this polygon to be a copy of the given one.</p>
<p>All of the contents are copied, so that this polygon does not hold any references to elements of the other polygon. This method returns a reference to this polygon for chaining.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">other</td><td>The polygon to copy</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>This polygon, returned for chaining </dd></dl>

</div>
</div>
<a id="a726425b72ce40474100a546896eed6c3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a726425b72ce40474100a546896eed6c3">&#9670;&nbsp;</a></span>operator=() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcugl_1_1_poly2.html">Poly2</a>&amp; cugl::Poly2::operator= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classcugl_1_1_rect.html">Rect</a>&#160;</td>
          <td class="paramname"><em>rect</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Sets this polygon to be a copy of the given rectangle.</p>
<p>The polygon will have four vertices, one for each corner of the rectangle. In addition, this assignment will initialize the indices with a simple triangulation of the rectangle. The geometry will be <code>SOLID</code>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">rect</td><td>The rectangle to copy</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>This polygon, returned for chaining </dd></dl>

</div>
</div>
<a id="a4d097e4cd083f54a55d2d07a7c63a5a1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4d097e4cd083f54a55d2d07a7c63a5a1">&#9670;&nbsp;</a></span>operator=() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcugl_1_1_poly2.html">Poly2</a>&amp; cugl::Poly2::operator= </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classcugl_1_1_poly2.html">Poly2</a> &amp;&amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Sets this polygon to be have the resources of the given one.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">other</td><td>The polygon to take from</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>This polygon, returned for chaining </dd></dl>

</div>
</div>
<a id="a0d4ef0263dab04834308e25abe8816df"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0d4ef0263dab04834308e25abe8816df">&#9670;&nbsp;</a></span>orientation() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int cugl::Poly2::orientation </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns -1, 0, or 1 indicating the polygon orientation.</p>
<p>If the method returns -1, this is a counter-clockwise polygon. If 1, it is a clockwise polygon. If 0, that means it is undefined. The orientation of an <code>IMPLICIT</code> polygon is always defined as long as it has at least three vertices. Polygons with <code>POINTS</code> geometry never have a defined orientation.</p>
<p>For polygons with <code>PATH</code> geometry, the orientation is determined by following the path. However, if the path is disconnected, this could result in more than one orientation, making the orientation undefined.</p>
<p>For polygons with <code>SOLID</code> geometry, the orientiation is that of the triangles in the triangle mesh. However, if this value is not uniform (some triangles have one orientation and others do not), then this orientation is undefined.</p>
<dl class="section return"><dt>Returns</dt><dd>-1, 0, or 1 indicating the polygon orientation. </dd></dl>

</div>
</div>
<a id="afbcf9e317fec7f8d41aac537aeeddef8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afbcf9e317fec7f8d41aac537aeeddef8">&#9670;&nbsp;</a></span>orientation() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static int cugl::Poly2::orientation </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classcugl_1_1_vec2.html">Vec2</a>&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classcugl_1_1_vec2.html">Vec2</a>&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classcugl_1_1_vec2.html">Vec2</a>&#160;</td>
          <td class="paramname"><em>c</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns -1, 0, or 1 indicating the orientation of a -&gt; b -&gt; c</p>
<p>If the function returns -1, this is a counter-clockwise turn. If 1, it is a clockwise turn. If 0, it is colinear.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">a</td><td>The first point </td></tr>
    <tr><td class="paramname">b</td><td>The second point </td></tr>
    <tr><td class="paramname">c</td><td>The third point</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>-1, 0, or 1 indicating the orientation of a -&gt; b -&gt; c </dd></dl>

</div>
</div>
<a id="ab988f04b1c87b34677e59407b3f2f548"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab988f04b1c87b34677e59407b3f2f548">&#9670;&nbsp;</a></span>reverse()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void cugl::Poly2::reverse </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Reverses the orientation of this polygon.</p>
<p>If the polygon orientation is undefined, then this method does nothing. Otherwise, it reorders either the vertices or the mesh indices to reverse the orientation. Which one is resorted (vertices or indices) is undefined. </p>

</div>
</div>
<a id="ab1e03291c994013b9bebc84f6c0f09e7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab1e03291c994013b9bebc84f6c0f09e7">&#9670;&nbsp;</a></span>set() <span class="overload">[1/10]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcugl_1_1_poly2.html">Poly2</a>&amp; cugl::Poly2::set </td>
          <td>(</td>
          <td class="paramtype">const float *&#160;</td>
          <td class="paramname"><em>vertices</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>vertsize</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Sets the polygon to have the given vertices.</p>
<p>The float array should have an even number of elements. The number of vertices is half of the size of the array. For each value ii, 2*ii and 2*ii+1 are the coordinates of a single vertex.</p>
<p>The resulting polygon has no indices and the geometry is <code>IMPLICIT</code>.</p>
<p>This method returns a reference to this polygon for chaining.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">vertices</td><td>The array of vertices (as floats) in this polygon </td></tr>
    <tr><td class="paramname">vertsize</td><td>The number of elements to use from vertices</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>This polygon, returned for chaining </dd></dl>

</div>
</div>
<a id="ae4083d3601353e3f4933e55f67cb9a5c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae4083d3601353e3f4933e55f67cb9a5c">&#9670;&nbsp;</a></span>set() <span class="overload">[2/10]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcugl_1_1_poly2.html">Poly2</a>&amp; cugl::Poly2::set </td>
          <td>(</td>
          <td class="paramtype">const float *&#160;</td>
          <td class="paramname"><em>vertices</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>vertsize</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Uint32 *&#160;</td>
          <td class="paramname"><em>indices</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>indxsize</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Sets the polygon to have the given vertices and indices.</p>
<p>The float array should have an even number of elements. The number of vertices is half of the size of the array. For each value ii, 2*ii and 2*ii+1 are the coordinates of a single vertex.</p>
<p>A valid list of indices must only refer to vertices in the vertex array. That is, the indices should all be non-negative, and each value should be less than the number of vertices.</p>
<p>The index geometry will be assigned via <a class="el" href="classcugl_1_1_geometry.html#ae8d10b1530c4b2e8707fd77ccd87bfb2">Geometry#categorize</a>. This method returns a reference to this polygon for chaining.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">vertices</td><td>The array of vertices (as floats) in this polygon </td></tr>
    <tr><td class="paramname">vertsize</td><td>The number of elements to use from vertices </td></tr>
    <tr><td class="paramname">indices</td><td>The array of indices for the rendering </td></tr>
    <tr><td class="paramname">indxsize</td><td>The number of elements to use for the indices</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>This polygon, returned for chaining </dd></dl>

</div>
</div>
<a id="a28397786382add4ef7f89e0ed85c4a4f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a28397786382add4ef7f89e0ed85c4a4f">&#9670;&nbsp;</a></span>set() <span class="overload">[3/10]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcugl_1_1_poly2.html">Poly2</a>&amp; cugl::Poly2::set </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classcugl_1_1_poly2.html">Poly2</a> &amp;&#160;</td>
          <td class="paramname"><em>poly</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Sets this polygon to be a copy of the given one.</p>
<p>All of the contents are copied, so that this polygon does not hold any references to elements of the other polygon. This method returns a reference to this polygon for chaining.</p>
<p>This method returns a reference to this polygon for chaining.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">poly</td><td>The polygon to copy</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>This polygon, returned for chaining </dd></dl>

</div>
</div>
<a id="ab2e8cbcac97231ead348552e2fb31878"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab2e8cbcac97231ead348552e2fb31878">&#9670;&nbsp;</a></span>set() <span class="overload">[4/10]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcugl_1_1_poly2.html">Poly2</a>&amp; cugl::Poly2::set </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classcugl_1_1_rect.html">Rect</a>&#160;</td>
          <td class="paramname"><em>rect</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>solid</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Sets the polygon to represent the given rectangle.</p>
<p>The polygon will have four vertices, one for each corner of the rectangle. This optional argument (which is true by default) will initialize the indices with a triangulation of the rectangle. In other words, the geometry will be <code>SOLID</code>. This is faster than using one of the more heavy-weight triangulators.</p>
<p>If solid is false, it will still generate indices, but will have <code>CLOSED</code> geometry instead.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">rect</td><td>The rectangle to copy </td></tr>
    <tr><td class="paramname">solid</td><td>Whether to treat this rectangle as a solid polygon</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>This polygon, returned for chaining </dd></dl>

</div>
</div>
<a id="aca03a89eba69a6f74989a19fe2ca7b4d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aca03a89eba69a6f74989a19fe2ca7b4d">&#9670;&nbsp;</a></span>set() <span class="overload">[5/10]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcugl_1_1_poly2.html">Poly2</a>&amp; cugl::Poly2::set </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; float &gt; &amp;&#160;</td>
          <td class="paramname"><em>vertices</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Sets the polygon to have the given vertices</p>
<p>The float array should have an even number of elements. The number of vertices is half of the size of the array. For each value ii, 2*ii and 2*ii+1 are the coordinates of a single vertex.</p>
<p>The resulting polygon has no indices and the geometry is <code>IMPLICIT</code>.</p>
<p>This method returns a reference to this polygon for chaining.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">vertices</td><td>The vector of vertices (as floats) in this polygon</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>This polygon, returned for chaining </dd></dl>

</div>
</div>
<a id="a5131d586746dacc3bdd9af4f3e5532b6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5131d586746dacc3bdd9af4f3e5532b6">&#9670;&nbsp;</a></span>set() <span class="overload">[6/10]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcugl_1_1_poly2.html">Poly2</a>&amp; cugl::Poly2::set </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; float &gt; &amp;&#160;</td>
          <td class="paramname"><em>vertices</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; Uint32 &gt; &amp;&#160;</td>
          <td class="paramname"><em>indices</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Sets a polygon to have the given vertices and indices.</p>
<p>The float array should have an even number of elements. The number of vertices is half of the size of the array. For each value ii, 2*ii and 2*ii+1 are the coordinates of a single vertex.</p>
<p>A valid list of indices must only refer to vertices in the vertex array. That is, the indices should all be non-negative, and each value should be less than the number of vertices.</p>
<p>The index geometry will be assigned via <a class="el" href="classcugl_1_1_geometry.html#ae8d10b1530c4b2e8707fd77ccd87bfb2">Geometry#categorize</a>.</p>
<p>This method returns a reference to this polygon for chaining.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">vertices</td><td>The vector of vertices (as floats) in this polygon </td></tr>
    <tr><td class="paramname">indices</td><td>The vector of indices for the rendering</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>This polygon, returned for chaining </dd></dl>

</div>
</div>
<a id="a33366d9d9a73620d93591dfdd78f177d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a33366d9d9a73620d93591dfdd78f177d">&#9670;&nbsp;</a></span>set() <span class="overload">[7/10]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcugl_1_1_poly2.html">Poly2</a>&amp; cugl::Poly2::set </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="classcugl_1_1_vec2.html">Vec2</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>vertices</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Sets the polygon to have the given vertices</p>
<p>The resulting polygon has no indices and the geometry is <code>IMPLICIT</code>.</p>
<p>This method returns a reference to this polygon for chaining.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">vertices</td><td>The vector of vertices (as <a class="el" href="classcugl_1_1_vec2.html">Vec2</a>) in this polygon</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>This polygon, returned for chaining </dd></dl>

</div>
</div>
<a id="a03babab1cb75704f3c1b24b4cb26ec42"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a03babab1cb75704f3c1b24b4cb26ec42">&#9670;&nbsp;</a></span>set() <span class="overload">[8/10]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcugl_1_1_poly2.html">Poly2</a>&amp; cugl::Poly2::set </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="classcugl_1_1_vec2.html">Vec2</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>vertices</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; Uint32 &gt; &amp;&#160;</td>
          <td class="paramname"><em>indices</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Sets the polygon to have the given vertices and indices.</p>
<p>A valid list of indices must only refer to vertices in the vertex array. That is, the indices should all be non-negative, and each value should be less than the number of vertices.</p>
<p>The index geometry will be assigned via <a class="el" href="classcugl_1_1_geometry.html#ae8d10b1530c4b2e8707fd77ccd87bfb2">Geometry#categorize</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">vertices</td><td>The vector of vertices (as <a class="el" href="classcugl_1_1_vec2.html">Vec2</a>) in this polygon </td></tr>
    <tr><td class="paramname">indices</td><td>The vector of indices for the rendering</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>This polygon, returned for chaining </dd></dl>

</div>
</div>
<a id="a46c65307bf770be577cf2ee822147b4b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a46c65307bf770be577cf2ee822147b4b">&#9670;&nbsp;</a></span>set() <span class="overload">[9/10]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcugl_1_1_poly2.html">Poly2</a>&amp; cugl::Poly2::set </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classcugl_1_1_vec2.html">Vec2</a> *&#160;</td>
          <td class="paramname"><em>vertices</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>vertsize</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Sets the polygon to have the given vertices.</p>
<p>The resulting polygon has no indices and the geometry is <code>IMPLICIT</code>.</p>
<p>This method returns a reference to this polygon for chaining.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">vertices</td><td>The array of vertices (as <a class="el" href="classcugl_1_1_vec2.html">Vec2</a>) in this polygon </td></tr>
    <tr><td class="paramname">vertsize</td><td>The number of elements to use from vertices</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>This polygon, returned for chaining </dd></dl>

</div>
</div>
<a id="afb94ca298051246f1e8d7914729a1c8e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afb94ca298051246f1e8d7914729a1c8e">&#9670;&nbsp;</a></span>set() <span class="overload">[10/10]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcugl_1_1_poly2.html">Poly2</a>&amp; cugl::Poly2::set </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classcugl_1_1_vec2.html">Vec2</a> *&#160;</td>
          <td class="paramname"><em>vertices</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>vertsize</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Uint32 *&#160;</td>
          <td class="paramname"><em>indices</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>indxsize</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Sets the polygon to have the given vertices and indices.</p>
<p>A valid list of indices must only refer to vertices in the vertex array. That is, the indices should all be non-negative, and each value should be less than the number of vertices.</p>
<p>The index geometry will be assigned via <a class="el" href="classcugl_1_1_geometry.html#ae8d10b1530c4b2e8707fd77ccd87bfb2">Geometry#categorize</a>. This method returns a reference to this polygon for chaining.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">vertices</td><td>The array of vertices (as <a class="el" href="classcugl_1_1_vec2.html">Vec2</a>) in this polygon </td></tr>
    <tr><td class="paramname">vertsize</td><td>The number of elements to use from vertices </td></tr>
    <tr><td class="paramname">indices</td><td>The array of indices for the rendering </td></tr>
    <tr><td class="paramname">indxsize</td><td>The number of elements to use for the indices</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>This polygon, returned for chaining </dd></dl>

</div>
</div>
<a id="a970f2aa0fa32f21fb8134a31a911c66d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a970f2aa0fa32f21fb8134a31a911c66d">&#9670;&nbsp;</a></span>setGeometry()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void cugl::Poly2::setGeometry </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classcugl_1_1_geometry.html">Geometry</a>&#160;</td>
          <td class="paramname"><em>geom</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns the geometry of this polygon.</p>
<p>The type determines the proper form of the indices.</p>
<p>If the geometry is <code>SOLID</code>, the number of indices should be a multiple of 3. Each triplet should define a triangle over the vertices.</p>
<p>If the geometry is <code>PATH</code>, the number of indices should be a multiple of 2. Each pair should define a line segment over the vertices.</p>
<p>If the polygon is <code>IMPLICIT</code>, the index list should be empty.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">geom</td><td>The geometry of this polygon. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a5d2104d6584cab63a9b947af24e81b23"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5d2104d6584cab63a9b947af24e81b23">&#9670;&nbsp;</a></span>setIndices() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcugl_1_1_poly2.html">Poly2</a>&amp; cugl::Poly2::setIndices </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; Uint32 &gt; &amp;&#160;</td>
          <td class="paramname"><em>indices</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Sets the indices for this polygon to the ones given.</p>
<p>A valid list of indices must only refer to vertices in the vertex array. That is, the indices should all be non-negative, and each value should be less than the number of vertices.</p>
<p>The index geometry will be assigned via <a class="el" href="classcugl_1_1_geometry.html#ae8d10b1530c4b2e8707fd77ccd87bfb2">Geometry#categorize</a>. This method returns a reference to this polygon for chaining.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">indices</td><td>The vector of indices for the shape</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>This polygon, returned for chaining </dd></dl>

</div>
</div>
<a id="ade6cd9e64f7fbc4636544736dff6f5ed"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ade6cd9e64f7fbc4636544736dff6f5ed">&#9670;&nbsp;</a></span>setIndices() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcugl_1_1_poly2.html">Poly2</a>&amp; cugl::Poly2::setIndices </td>
          <td>(</td>
          <td class="paramtype">const Uint32 *&#160;</td>
          <td class="paramname"><em>indices</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>indxsize</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Sets the indices for this polygon to the ones given.</p>
<p>A valid list of indices must only refer to vertices in the vertex array. That is, the indices should all be non-negative, and each value should be less than the number of vertices.</p>
<p>The provided array is copied. The polygon does not retain a reference.</p>
<p>The index geometry will be assigned via <a class="el" href="classcugl_1_1_geometry.html#ae8d10b1530c4b2e8707fd77ccd87bfb2">Geometry#categorize</a>. This method returns a reference to this polygon for chaining.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">indices</td><td>The array of indices for the rendering </td></tr>
    <tr><td class="paramname">indxsize</td><td>The number of elements to use for the indices</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>This polygon, returned for chaining </dd></dl>

</div>
</div>
<a id="abb707fec08fa4b1fea47996292f47570"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abb707fec08fa4b1fea47996292f47570">&#9670;&nbsp;</a></span>size()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_t cugl::Poly2::size </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns the number of vertices in a polygon.</p>
<dl class="section return"><dt>Returns</dt><dd>the number of vertices in a polygon. </dd></dl>

</div>
</div>
<a id="a8a1bf499f18cf07e2ccb3d85d10b8b14"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8a1bf499f18cf07e2ccb3d85d10b8b14">&#9670;&nbsp;</a></span>toString()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string cugl::Poly2::toString </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>verbose</em> = <code>false</code></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns a string representation of this polygon for debugging purposes.</p>
<p>If verbose is true, the string will include class information. This allows us to unambiguously identify the class.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">verbose</td><td>Whether to include class information</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a string representation of this polygon for debuggging purposes. </dd></dl>

</div>
</div>
<a id="ad2d588486c60528899bbc10e797e6fa2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad2d588486c60528899bbc10e797e6fa2">&#9670;&nbsp;</a></span>vertices() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;<a class="el" href="classcugl_1_1_vec2.html">Vec2</a>&gt;&amp; cugl::Poly2::vertices </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns the list of vertices</p>
<p>This accessor will not permit any changes to the vertex array. To change the array, you must change the polygon via a <a class="el" href="classcugl_1_1_poly2.html#a33366d9d9a73620d93591dfdd78f177d">set()</a> method.</p>
<dl class="section return"><dt>Returns</dt><dd>a reference to the vertex array </dd></dl>

</div>
</div>
<a id="a261758c43911ac08b4889effe6d45253"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a261758c43911ac08b4889effe6d45253">&#9670;&nbsp;</a></span>vertices() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const std::vector&lt;<a class="el" href="classcugl_1_1_vec2.html">Vec2</a>&gt;&amp; cugl::Poly2::vertices </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns the list of vertices</p>
<p>This accessor will not permit any changes to the vertex array. To change the array, you must change the polygon via a <a class="el" href="classcugl_1_1_poly2.html#a33366d9d9a73620d93591dfdd78f177d">set()</a> method.</p>
<dl class="section return"><dt>Returns</dt><dd>a reference to the vertex array </dd></dl>

</div>
</div>
<h2 class="groupheader">Friends And Related Function Documentation</h2>
<a id="a0c31c4aecf2ff550474d415d76723b1c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0c31c4aecf2ff550474d415d76723b1c">&#9670;&nbsp;</a></span>operator* <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcugl_1_1_poly2.html">Poly2</a> operator* </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classcugl_1_1_vec2.html">Vec2</a>&#160;</td>
          <td class="paramname"><em>scale</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classcugl_1_1_poly2.html">Poly2</a> &amp;&#160;</td>
          <td class="paramname"><em>poly</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">friend</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns a new polygon by scaling the vertices non-uniformly.</p>
<p>The vertices are scaled from the origin of the coordinate space. This means that if the origin is not in the interior of this polygon, the polygon will be effectively translated by the scaling.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">scale</td><td>The non-uniform scaling factor </td></tr>
    <tr><td class="paramname">poly</td><td>The polygon to scale</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The scaled polygon </dd></dl>

</div>
</div>
<a id="af8ef5e90dbed6e69b06346ceeddb4b0a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af8ef5e90dbed6e69b06346ceeddb4b0a">&#9670;&nbsp;</a></span>operator* <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcugl_1_1_poly2.html">Poly2</a> operator* </td>
          <td>(</td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>scale</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classcugl_1_1_poly2.html">Poly2</a> &amp;&#160;</td>
          <td class="paramname"><em>poly</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">friend</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns a new polygon by scaling the vertices uniformly.</p>
<p>The vertices are scaled from the origin of the coordinate space. This means that if the origin is not in the interior of this polygon, the polygon will be effectively translated by the scaling.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">scale</td><td>The uniform scaling factor </td></tr>
    <tr><td class="paramname">poly</td><td>The polygon to scale</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The scaled polygon </dd></dl>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>include/cugl/math/<a class="el" href="_c_u_poly2_8h_source.html">CUPoly2.h</a></li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.1
</small></address>
</body>
</html>
