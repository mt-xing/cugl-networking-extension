<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.9.1"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>CUGL 2.0: cugl::VertexBuffer Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">CUGL 2.0
   </div>
   <div id="projectbrief">Cornell University Game Library</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.1 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search','.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespacecugl.html">cugl</a></li><li class="navelem"><a class="el" href="classcugl_1_1_vertex_buffer.html">VertexBuffer</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-static-methods">Static Public Member Functions</a> &#124;
<a href="classcugl_1_1_vertex_buffer-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">cugl::VertexBuffer Class Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p><code>#include &lt;<a class="el" href="_c_u_vertex_buffer_8h_source.html">CUVertexBuffer.h</a>&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a6c48c3fdd358c0091d49405ed5ec1374"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1_vertex_buffer.html#a6c48c3fdd358c0091d49405ed5ec1374">VertexBuffer</a> ()</td></tr>
<tr class="separator:a6c48c3fdd358c0091d49405ed5ec1374"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a54f88a9c818cde2c6014520525ccb6f0"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1_vertex_buffer.html#a54f88a9c818cde2c6014520525ccb6f0">~VertexBuffer</a> ()</td></tr>
<tr class="separator:a54f88a9c818cde2c6014520525ccb6f0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5cd8482e8006ba497b3e39f7d760660b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1_vertex_buffer.html#a5cd8482e8006ba497b3e39f7d760660b">dispose</a> ()</td></tr>
<tr class="separator:a5cd8482e8006ba497b3e39f7d760660b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad9325767d1ed64a85bcc810fa0dcf85e"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1_vertex_buffer.html#ad9325767d1ed64a85bcc810fa0dcf85e">init</a> (GLsizei stride)</td></tr>
<tr class="separator:ad9325767d1ed64a85bcc810fa0dcf85e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9b9133024f8c93d96f1579d1ded46efe"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1_vertex_buffer.html#a9b9133024f8c93d96f1579d1ded46efe">bind</a> ()</td></tr>
<tr class="separator:a9b9133024f8c93d96f1579d1ded46efe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9b42f19831ade0a128b504b7459e8561"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1_vertex_buffer.html#a9b42f19831ade0a128b504b7459e8561">unbind</a> ()</td></tr>
<tr class="separator:a9b42f19831ade0a128b504b7459e8561"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9d1fc8712ac94048635e51744a55baba"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1_vertex_buffer.html#a9d1fc8712ac94048635e51744a55baba">attach</a> (const std::shared_ptr&lt; <a class="el" href="classcugl_1_1_shader.html">Shader</a> &gt; &amp;shader)</td></tr>
<tr class="separator:a9d1fc8712ac94048635e51744a55baba"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6c0f9a27070ce09a0907fbf9a8e8b068"><td class="memItemLeft" align="right" valign="top">std::shared_ptr&lt; <a class="el" href="classcugl_1_1_shader.html">Shader</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1_vertex_buffer.html#a6c0f9a27070ce09a0907fbf9a8e8b068">detach</a> ()</td></tr>
<tr class="separator:a6c0f9a27070ce09a0907fbf9a8e8b068"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aedc8ba52efe62c007e19e9ddd1db50fa"><td class="memItemLeft" align="right" valign="top">std::shared_ptr&lt; <a class="el" href="classcugl_1_1_shader.html">Shader</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1_vertex_buffer.html#aedc8ba52efe62c007e19e9ddd1db50fa">getShader</a> () const</td></tr>
<tr class="separator:aedc8ba52efe62c007e19e9ddd1db50fa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a453ff4c7b1871c89c43ccae3ca2f02fd"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1_vertex_buffer.html#a453ff4c7b1871c89c43ccae3ca2f02fd">isBound</a> () const</td></tr>
<tr class="separator:a453ff4c7b1871c89c43ccae3ca2f02fd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a526e53b4f7700c8a8b4a8c1a0d7b21df"><td class="memItemLeft" align="right" valign="top">GLsizei&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1_vertex_buffer.html#a526e53b4f7700c8a8b4a8c1a0d7b21df">getStride</a> () const</td></tr>
<tr class="separator:a526e53b4f7700c8a8b4a8c1a0d7b21df"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a88fe1c309b508cfd82968a0e16c04377"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1_vertex_buffer.html#a88fe1c309b508cfd82968a0e16c04377">loadVertexData</a> (const void *data, GLsizei size, GLenum usage=GL_STREAM_DRAW)</td></tr>
<tr class="separator:a88fe1c309b508cfd82968a0e16c04377"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab9086f2a7c7e545e2c0c7f07e67b4a97"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1_vertex_buffer.html#ab9086f2a7c7e545e2c0c7f07e67b4a97">loadIndexData</a> (const void *data, GLsizei size, GLenum usage=GL_STREAM_DRAW)</td></tr>
<tr class="separator:ab9086f2a7c7e545e2c0c7f07e67b4a97"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac07c631783f167b7df58472e60d5be7a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1_vertex_buffer.html#ac07c631783f167b7df58472e60d5be7a">draw</a> (GLenum mode, GLsizei count, GLsizei offset=0)</td></tr>
<tr class="separator:ac07c631783f167b7df58472e60d5be7a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af1588d3859ae49586612cf47495539c1"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1_vertex_buffer.html#af1588d3859ae49586612cf47495539c1">drawInstanced</a> (GLenum mode, GLsizei count, GLsizei instances, GLsizei offset=0)</td></tr>
<tr class="separator:af1588d3859ae49586612cf47495539c1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a09b1632f3c6116ed95d146a4ba1866fa"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1_vertex_buffer.html#a09b1632f3c6116ed95d146a4ba1866fa">setupAttribute</a> (const std::string name, GLint size, GLenum type, GLboolean norm, GLsizei offset)</td></tr>
<tr class="separator:a09b1632f3c6116ed95d146a4ba1866fa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac37e38d66290dda646ac7dd13c57e4ed"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1_vertex_buffer.html#ac37e38d66290dda646ac7dd13c57e4ed">enableAttribute</a> (const std::string name)</td></tr>
<tr class="separator:ac37e38d66290dda646ac7dd13c57e4ed"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a28e490da85bfecfa36315a56423238ef"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1_vertex_buffer.html#a28e490da85bfecfa36315a56423238ef">disableAttribute</a> (const std::string name)</td></tr>
<tr class="separator:a28e490da85bfecfa36315a56423238ef"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-static-methods"></a>
Static Public Member Functions</h2></td></tr>
<tr class="memitem:a98d621528b9aa01fda5cdda53ad4f990"><td class="memItemLeft" align="right" valign="top">static std::shared_ptr&lt; <a class="el" href="classcugl_1_1_vertex_buffer.html">VertexBuffer</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1_vertex_buffer.html#a98d621528b9aa01fda5cdda53ad4f990">alloc</a> (GLsizei stride)</td></tr>
<tr class="separator:a98d621528b9aa01fda5cdda53ad4f990"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>This class defines a vertex buffer for drawing with a shader.</p>
<p>What we are calling a vertex buffer is technically a vertex array plus its associated buffers in OpenGL. A vertex buffer receives vertices and passes them to a shader. A vertex buffer must be attached to a shader to be used. However, a vertex buffer can swap shaders at any time, which is why this class is separated out.</p>
<p>Unlike <a class="el" href="classcugl_1_1_texture.html">Texture</a> and <a class="el" href="classcugl_1_1_uniform_buffer.html">UniformBuffer</a>, a vertex buffer does not have a true many one relationship with a <a class="el" href="classcugl_1_1_shader.html">Shader</a> object. A vertex buffer can only be connected to one shader at a time and vice versa. So we model this as a direct connection. As vertex buffers push data to a shader, the dependency requires that a shader be linked to a vertex buffer object.</p>
<p>This class tries to remain loosely coupled with its shader. If the vertex buffer has attributes lacking in the shader, they will be ignored. If it is missing attributes that the shader expects, the shader will use the default value for the type. </p>
</div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="a6c48c3fdd358c0091d49405ed5ec1374"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6c48c3fdd358c0091d49405ed5ec1374">&#9670;&nbsp;</a></span>VertexBuffer()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">cugl::VertexBuffer::VertexBuffer </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Creates an uninitialized vertex buffer.</p>
<p>You must initialize the vertex buffer to allocate buffer memory. </p>

</div>
</div>
<a id="a54f88a9c818cde2c6014520525ccb6f0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a54f88a9c818cde2c6014520525ccb6f0">&#9670;&nbsp;</a></span>~VertexBuffer()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">cugl::VertexBuffer::~VertexBuffer </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Deletes this vertex buffer, disposing all resources. </p>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="a98d621528b9aa01fda5cdda53ad4f990"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a98d621528b9aa01fda5cdda53ad4f990">&#9670;&nbsp;</a></span>alloc()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static std::shared_ptr&lt;<a class="el" href="classcugl_1_1_vertex_buffer.html">VertexBuffer</a>&gt; cugl::VertexBuffer::alloc </td>
          <td>(</td>
          <td class="paramtype">GLsizei&#160;</td>
          <td class="paramname"><em>stride</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns a new vertex buffer to support the given stride.</p>
<p>The stride is the size of a single piece of vertex data. The vertex buffer needs this value to set attribute locations. Since changing this value fundamentally changes the type of data that can be sent to this vertex buffer, it is set at buffer creation and cannot be changed.</p>
<p>It is possible for the stride to be 0, but only if the shader consists of a single attribute. Using stride 0 is not recommended.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">stride</td><td>The size of a single piece of vertex data.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a new vertex buffer to support the given stride. </dd></dl>

</div>
</div>
<a id="a9d1fc8712ac94048635e51744a55baba"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9d1fc8712ac94048635e51744a55baba">&#9670;&nbsp;</a></span>attach()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void cugl::VertexBuffer::attach </td>
          <td>(</td>
          <td class="paramtype">const std::shared_ptr&lt; <a class="el" href="classcugl_1_1_shader.html">Shader</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>shader</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Attaches the given shader to this vertex buffer.</p>
<p>This method will link all enabled attributes in this vertex buffer (warning about any attributes that are missing from the shader). It will also immediately bind both the vertex buffer and the shader, making them ready to use.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">shader</td><td>The shader to attach </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a9b9133024f8c93d96f1579d1ded46efe"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9b9133024f8c93d96f1579d1ded46efe">&#9670;&nbsp;</a></span>bind()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void cugl::VertexBuffer::bind </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Binds this vertex buffer, making it active.</p>
<p>If this vertex buffer has an attached shader, this will bind the shader as well. Once bound, all vertex data and uniforms will be sent to the associated shader.</p>
<p>A vertex buffer can be bound without being attached to a shader. However, if it is actively attached to a shader, this method will bind that shader as well. </p>

</div>
</div>
<a id="a6c0f9a27070ce09a0907fbf9a8e8b068"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6c0f9a27070ce09a0907fbf9a8e8b068">&#9670;&nbsp;</a></span>detach()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::shared_ptr&lt;<a class="el" href="classcugl_1_1_shader.html">Shader</a>&gt; cugl::VertexBuffer::detach </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns the previously active shader, after detaching it.</p>
<p>This method will unbind the vertex buffer, but not the shader.</p>
<dl class="section return"><dt>Returns</dt><dd>The previously active shader (or null if none) </dd></dl>

</div>
</div>
<a id="a28e490da85bfecfa36315a56423238ef"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a28e490da85bfecfa36315a56423238ef">&#9670;&nbsp;</a></span>disableAttribute()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void cugl::VertexBuffer::disableAttribute </td>
          <td>(</td>
          <td class="paramtype">const std::string&#160;</td>
          <td class="paramname"><em>name</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Disables the given attribute</p>
<p>Attributes are immediately enabled once they are set-up. This method allows you to temporarily turn off an attribute. If that attribute is required by the shader, it will use the default value for the type instead.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">name</td><td>The attribute to disable. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a5cd8482e8006ba497b3e39f7d760660b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5cd8482e8006ba497b3e39f7d760660b">&#9670;&nbsp;</a></span>dispose()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void cugl::VertexBuffer::dispose </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Deletes the vertex buffer, freeing all resources.</p>
<p>You must reinitialize the vertex buffer to use it. </p>

</div>
</div>
<a id="ac07c631783f167b7df58472e60d5be7a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac07c631783f167b7df58472e60d5be7a">&#9670;&nbsp;</a></span>draw()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void cugl::VertexBuffer::draw </td>
          <td>(</td>
          <td class="paramtype">GLenum&#160;</td>
          <td class="paramname"><em>mode</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">GLsizei&#160;</td>
          <td class="paramname"><em>count</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">GLsizei&#160;</td>
          <td class="paramname"><em>offset</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Draws to the active framebuffer using this vertex buffer</p>
<p>Any call to this command will use the current texture and uniforms. If the texture and/or uniforms need to be changed, then this draw command will need to be broken up into chunks. Use the optional parameter offset to chunk up the draw calls without having to reload data.</p>
<p>The drawing mode can be any of GL_POINTS, GL_LINE_STRIP, GL_LINE_LOOP, GL_LINES, GL_TRIANGLE_STRIP, GL_TRIANGLE_FAN or GL_TRIANGLES. These are the only modes accepted by both OpenGL and OpenGLES. See the OpenGL documentation for the number of indices required for each type. In practice the <a class="el" href="classcugl_1_1_poly2.html">Poly2</a> class is designed to support GL_POINTS, GL_LINES, and GL_TRIANGLES only.</p>
<p>This method will only succeed if this buffer is actively bound.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">mode</td><td>The OpenGLES drawing mode </td></tr>
    <tr><td class="paramname">count</td><td>The number of vertices to draw </td></tr>
    <tr><td class="paramname">offset</td><td>The initial index to start with </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="af1588d3859ae49586612cf47495539c1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af1588d3859ae49586612cf47495539c1">&#9670;&nbsp;</a></span>drawInstanced()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void cugl::VertexBuffer::drawInstanced </td>
          <td>(</td>
          <td class="paramtype">GLenum&#160;</td>
          <td class="paramname"><em>mode</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">GLsizei&#160;</td>
          <td class="paramname"><em>count</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">GLsizei&#160;</td>
          <td class="paramname"><em>instances</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">GLsizei&#160;</td>
          <td class="paramname"><em>offset</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Draws to the active framebuffer using this vertex buffer</p>
<p>This version of drawing supports instancing.This allows you to draw the the same vertices multiple times, with slightly different uniforms each time. While the use of this is limited &ndash; there is an 8096 byte limit on uniforms for more shaders &ndash; it can speed up rendering in some special cases. See the documentation of glDrawElementsInstanced for how to properly leverage instancing.</p>
<p>Any call to this command will use the current texture and uniforms. If the texture and/or uniforms need to be changed, then this draw command will need to be broken up into chunks. Use the optional parameter offset to chunk up the draw calls without having to reload data.</p>
<p>The drawing mode can be any of GL_POINTS, GL_LINE_STRIP, GL_LINE_LOOP, GL_LINES, GL_TRIANGLE_STRIP, GL_TRIANGLE_FAN or GL_TRIANGLES. These are the only modes accepted by both OpenGL and OpenGLES. See the OpenGL documentation for the number of indices required for each type. In practice the <a class="el" href="classcugl_1_1_poly2.html">Poly2</a> class is designed to support GL_POINTS, GL_LINES, and GL_TRIANGLES only.</p>
<p>This method will only succeed if this buffer is actively bound.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">mode</td><td>The OpenGLES drawing mode </td></tr>
    <tr><td class="paramname">count</td><td>The number of vertices to draw </td></tr>
    <tr><td class="paramname">instances</td><td>The number of instances to draw </td></tr>
    <tr><td class="paramname">offset</td><td>The initial index to start with </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ac37e38d66290dda646ac7dd13c57e4ed"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac37e38d66290dda646ac7dd13c57e4ed">&#9670;&nbsp;</a></span>enableAttribute()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void cugl::VertexBuffer::enableAttribute </td>
          <td>(</td>
          <td class="paramtype">const std::string&#160;</td>
          <td class="paramname"><em>name</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Enables the given attribute</p>
<p>Attributes are immediately enabled once they are set-up. This method is only needed if the attribute was previously disabled. It will have no effect if the active shader does not support this attribute.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">name</td><td>The attribute to enable. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aedc8ba52efe62c007e19e9ddd1db50fa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aedc8ba52efe62c007e19e9ddd1db50fa">&#9670;&nbsp;</a></span>getShader()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::shared_ptr&lt;<a class="el" href="classcugl_1_1_shader.html">Shader</a>&gt; cugl::VertexBuffer::getShader </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns the shader currently attached to this vertex buffer.</p>
<dl class="section return"><dt>Returns</dt><dd>the shader currently attached to this vertex buffer. </dd></dl>

</div>
</div>
<a id="a526e53b4f7700c8a8b4a8c1a0d7b21df"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a526e53b4f7700c8a8b4a8c1a0d7b21df">&#9670;&nbsp;</a></span>getStride()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">GLsizei cugl::VertexBuffer::getStride </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns the stride of this vertex buffer</p>
<p>The data loaded is expected to have the size of the vertex buffer stride. If it does not, strange things will happen.</p>
<dl class="section return"><dt>Returns</dt><dd>the stride of this vertex buffer </dd></dl>

</div>
</div>
<a id="ad9325767d1ed64a85bcc810fa0dcf85e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad9325767d1ed64a85bcc810fa0dcf85e">&#9670;&nbsp;</a></span>init()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool cugl::VertexBuffer::init </td>
          <td>(</td>
          <td class="paramtype">GLsizei&#160;</td>
          <td class="paramname"><em>stride</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Initializes this vertex buffer to support the given stride.</p>
<p>The stride is the size of a single piece of vertex data. The vertex buffer needs this value to set attribute locations. Since changing this value fundamentally changes the type of data that can be sent to this vertex buffer, it is set at buffer creation and cannot be changed.</p>
<p>It is possible for the stride to be 0, but only if the shader consists of a single attribute. Using stride 0 is not recommended.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">stride</td><td>The size of a single piece of vertex data.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if initialization was successful. </dd></dl>

</div>
</div>
<a id="a453ff4c7b1871c89c43ccae3ca2f02fd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a453ff4c7b1871c89c43ccae3ca2f02fd">&#9670;&nbsp;</a></span>isBound()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool cugl::VertexBuffer::isBound </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns true if this vertex is currently bound.</p>
<dl class="section return"><dt>Returns</dt><dd>true if this vertex is currently bound. </dd></dl>

</div>
</div>
<a id="ab9086f2a7c7e545e2c0c7f07e67b4a97"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab9086f2a7c7e545e2c0c7f07e67b4a97">&#9670;&nbsp;</a></span>loadIndexData()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void cugl::VertexBuffer::loadIndexData </td>
          <td>(</td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">GLsizei&#160;</td>
          <td class="paramname"><em>size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">GLenum&#160;</td>
          <td class="paramname"><em>usage</em> = <code>GL_STREAM_DRAW</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Loads the given vertex buffer with indices.</p>
<p>The indices loaded are those that will be used at the next draw command. Frequent reloading of data and/or indices is to be discouraged (though it is faster than swapping to another vertex buffer). Instead, data and indices should be loaded once (if possible) and draw calls should make use of the offset parameter.</p>
<p>The indices loaded are expected to refer to valid vertex positions. If they do not, strange things will happen.</p>
<p>The data usage is one of GL_STATIC_DRAW, GL_STREAM_DRAW, or GL_DYNAMIC_DRAW. Static drawing should be reserved for vertices and/or indices that do not change (so all animation happens in uniforms). Given the high speed of CPU processing, this approach should only be taken for large meshes that can amortize the uniform changes. For quads and other simple meshes, you should always choose GL_STREAM_DRAW and push as much computation to the CPU as possible.</p>
<p>This method will only succeed if this buffer is actively bound.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">data</td><td>The indices to load </td></tr>
    <tr><td class="paramname">size</td><td>The number of indices to load </td></tr>
    <tr><td class="paramname">usage</td><td>The type of data load </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a88fe1c309b508cfd82968a0e16c04377"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a88fe1c309b508cfd82968a0e16c04377">&#9670;&nbsp;</a></span>loadVertexData()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void cugl::VertexBuffer::loadVertexData </td>
          <td>(</td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">GLsizei&#160;</td>
          <td class="paramname"><em>size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">GLenum&#160;</td>
          <td class="paramname"><em>usage</em> = <code>GL_STREAM_DRAW</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Loads the given vertex buffer with data.</p>
<p>The data loaded is the data that will be used at the next draw command. Frequent reloading of data and/or indices is to be discouraged (though it is faster than swapping to another vertex buffer). Instead, data and indices should be loaded once (if possible) and draw calls should make use of the offset parameter.</p>
<p>The data loaded is expected to have the size of the vertex buffer stride. If it does not, strange things will happen.</p>
<p>The data usage is one of GL_STATIC_DRAW, GL_STREAM_DRAW, or GL_DYNAMIC_DRAW. Static drawing should be reserved for vertices and/or indices that do not change (so all animation happens in uniforms). Given the high speed of CPU processing, this approach should only be taken for large meshes that can amortize the uniform changes. For quads and other simple meshes, you should always choose GL_STREAM_DRAW.</p>
<p>This method will only succeed if this buffer is actively bound.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">data</td><td>The data to load </td></tr>
    <tr><td class="paramname">size</td><td>The number of vertices to load </td></tr>
    <tr><td class="paramname">usage</td><td>The type of data load </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a09b1632f3c6116ed95d146a4ba1866fa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a09b1632f3c6116ed95d146a4ba1866fa">&#9670;&nbsp;</a></span>setupAttribute()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void cugl::VertexBuffer::setupAttribute </td>
          <td>(</td>
          <td class="paramtype">const std::string&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">GLint&#160;</td>
          <td class="paramname"><em>size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">GLenum&#160;</td>
          <td class="paramname"><em>type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">GLboolean&#160;</td>
          <td class="paramname"><em>norm</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">GLsizei&#160;</td>
          <td class="paramname"><em>offset</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Initializes an attributes, assigning is a size, type and offset.</p>
<p>This method is necessary for the vertex buffer to convey data to the shader. Without it, the shader will used default values for the attribute rather than data from the vertex buffer.</p>
<p>It is safe to call this method even when the shader is not attached. The values will be cached and will be used to link this buffer to the shader when the shader is attached. This also means that a vertex buffer can swap shaders without having to reinitialize attributes. If a shader is attached, the attribute will be enabled immediately.</p>
<p>If the attribute does not refer to one supported by the active shader, then it will be ignored (e.g. the effect is the same as disabling the attribute).</p>
<p>The attribute type can be one of GL_BYTE, GL_UNSIGNED_BYTE, GL_SHORT, GL_UNSIGNED_SHORT, GL_INT, GL_UNSIGNED_INT, GL_HALF_FLOAT, GL_FLOAT, GL_FIXED, or GL_INT_2_10_10_10_REV. Doubles are not supported by OpenGLES.</p>
<p>The attribute offset is measured in bytes from the start of the vertex data structure (for a single vertex).</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">name</td><td>The attribute name </td></tr>
    <tr><td class="paramname">size</td><td>The attribute size in byte. </td></tr>
    <tr><td class="paramname">type</td><td>The attribute type </td></tr>
    <tr><td class="paramname">norm</td><td>Whether to normalize the value (floating point only) </td></tr>
    <tr><td class="paramname">offset</td><td>The attribute offset in the vertex data structure </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a9b42f19831ade0a128b504b7459e8561"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9b42f19831ade0a128b504b7459e8561">&#9670;&nbsp;</a></span>unbind()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void cugl::VertexBuffer::unbind </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Unbinds this vertex buffer, making it no longer active.</p>
<p>A vertex buffer can be unbound without being attached to a shader. Furthermore, if it is actively attached to a shader, this method will NOT unbind the shader. This allows for fast(er) switching between buffers of the same shader.</p>
<p>Once unbound, all vertex data and uniforms will be ignored. In addition, all uniforms and samplers are potentially invalidated. These values should be set again when the vertex buffer is next bound. </p>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>include/cugl/render/<a class="el" href="_c_u_vertex_buffer_8h_source.html">CUVertexBuffer.h</a></li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.1
</small></address>
</body>
</html>
