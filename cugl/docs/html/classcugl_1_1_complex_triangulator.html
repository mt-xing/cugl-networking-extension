<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.9.1"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>CUGL 2.0: cugl::ComplexTriangulator Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">CUGL 2.0
   </div>
   <div id="projectbrief">Cornell University Game Library</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.1 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search','.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespacecugl.html">cugl</a></li><li class="navelem"><a class="el" href="classcugl_1_1_complex_triangulator.html">ComplexTriangulator</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="classcugl_1_1_complex_triangulator-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">cugl::ComplexTriangulator Class Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p><code>#include &lt;<a class="el" href="_c_u_complex_triangulator_8h_source.html">CUComplexTriangulator.h</a>&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a4bc99f41c6c1bd6c87e5eecae5f1898f"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1_complex_triangulator.html#a4bc99f41c6c1bd6c87e5eecae5f1898f">ComplexTriangulator</a> ()</td></tr>
<tr class="separator:a4bc99f41c6c1bd6c87e5eecae5f1898f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3f1b8e0e5553eddcd1c3ebca17db97d6"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1_complex_triangulator.html#a3f1b8e0e5553eddcd1c3ebca17db97d6">ComplexTriangulator</a> (const std::vector&lt; <a class="el" href="classcugl_1_1_vec2.html">Vec2</a> &gt; &amp;points)</td></tr>
<tr class="separator:a3f1b8e0e5553eddcd1c3ebca17db97d6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4e261b777fdbaeb6736847c925ddbdda"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1_complex_triangulator.html#a4e261b777fdbaeb6736847c925ddbdda">ComplexTriangulator</a> (const <a class="el" href="classcugl_1_1_poly2.html">Poly2</a> &amp;poly)</td></tr>
<tr class="separator:a4e261b777fdbaeb6736847c925ddbdda"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1fafed406b0263b83b126ca66f5efe63"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1_complex_triangulator.html#a1fafed406b0263b83b126ca66f5efe63">~ComplexTriangulator</a> ()</td></tr>
<tr class="separator:a1fafed406b0263b83b126ca66f5efe63"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a63acf573779c04bad9ff811f2cf2a340"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1_complex_triangulator.html#a63acf573779c04bad9ff811f2cf2a340">set</a> (const std::vector&lt; <a class="el" href="classcugl_1_1_vec2.html">Vec2</a> &gt; &amp;points)</td></tr>
<tr class="separator:a63acf573779c04bad9ff811f2cf2a340"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa3bb8d1e5b50ec0746e3ae3012f7d46b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1_complex_triangulator.html#aa3bb8d1e5b50ec0746e3ae3012f7d46b">set</a> (const <a class="el" href="classcugl_1_1_poly2.html">Poly2</a> &amp;poly)</td></tr>
<tr class="separator:aa3bb8d1e5b50ec0746e3ae3012f7d46b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7a35fa9ed66fac85a7146996fb468e3c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1_complex_triangulator.html#a7a35fa9ed66fac85a7146996fb468e3c">addHole</a> (const std::vector&lt; <a class="el" href="classcugl_1_1_vec2.html">Vec2</a> &gt; &amp;points)</td></tr>
<tr class="separator:a7a35fa9ed66fac85a7146996fb468e3c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a66da9017c76170f34018bd6bf6e5921d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1_complex_triangulator.html#a66da9017c76170f34018bd6bf6e5921d">addHole</a> (const <a class="el" href="classcugl_1_1_poly2.html">Poly2</a> &amp;poly)</td></tr>
<tr class="separator:a66da9017c76170f34018bd6bf6e5921d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a752fee407680c7800f752bc29138831b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1_complex_triangulator.html#a752fee407680c7800f752bc29138831b">addSteiner</a> (<a class="el" href="classcugl_1_1_vec2.html">Vec2</a> point)</td></tr>
<tr class="separator:a752fee407680c7800f752bc29138831b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a70aae5496cfcced0dd28cf27e71ef169"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1_complex_triangulator.html#a70aae5496cfcced0dd28cf27e71ef169">reset</a> ()</td></tr>
<tr class="separator:a70aae5496cfcced0dd28cf27e71ef169"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5f480cda7245b223935c49b09d3344af"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1_complex_triangulator.html#a5f480cda7245b223935c49b09d3344af">clear</a> ()</td></tr>
<tr class="separator:a5f480cda7245b223935c49b09d3344af"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab48b7e40616afd723b10e36344fe0edd"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1_complex_triangulator.html#ab48b7e40616afd723b10e36344fe0edd">calculate</a> ()</td></tr>
<tr class="separator:ab48b7e40616afd723b10e36344fe0edd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af71204ee844816d21d008f08ca8c778c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1_complex_triangulator.html#af71204ee844816d21d008f08ca8c778c">calculateDual</a> ()</td></tr>
<tr class="separator:af71204ee844816d21d008f08ca8c778c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a06bb3d9508ec02a2e8dab8243f8353f2"><td class="memItemLeft" align="right" valign="top">std::vector&lt; Uint32 &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1_complex_triangulator.html#a06bb3d9508ec02a2e8dab8243f8353f2">getTriangulation</a> () const</td></tr>
<tr class="separator:a06bb3d9508ec02a2e8dab8243f8353f2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acf713bba6a48f38a77a364f13bff08d4"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1_complex_triangulator.html#acf713bba6a48f38a77a364f13bff08d4">getTriangulation</a> (std::vector&lt; Uint32 &gt; &amp;buffer) const</td></tr>
<tr class="separator:acf713bba6a48f38a77a364f13bff08d4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4ea792bc17780d0f489eeb9520b3622e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classcugl_1_1_poly2.html">Poly2</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1_complex_triangulator.html#a4ea792bc17780d0f489eeb9520b3622e">getPolygon</a> () const</td></tr>
<tr class="separator:a4ea792bc17780d0f489eeb9520b3622e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a91acdf5cf138410f097d1c9ccf5ac98b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classcugl_1_1_poly2.html">Poly2</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1_complex_triangulator.html#a91acdf5cf138410f097d1c9ccf5ac98b">getPolygon</a> (<a class="el" href="classcugl_1_1_poly2.html">Poly2</a> *buffer) const</td></tr>
<tr class="separator:a91acdf5cf138410f097d1c9ccf5ac98b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae84ad7a439a59e5491bb30b116874825"><td class="memItemLeft" align="right" valign="top">std::vector&lt; Uint32 &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1_complex_triangulator.html#ae84ad7a439a59e5491bb30b116874825">getMap</a> () const</td></tr>
<tr class="separator:ae84ad7a439a59e5491bb30b116874825"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a02ba445a4e42a82535c0d7558fc58a9f"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1_complex_triangulator.html#a02ba445a4e42a82535c0d7558fc58a9f">getMap</a> (std::vector&lt; Uint32 &gt; &amp;buffer) const</td></tr>
<tr class="separator:a02ba445a4e42a82535c0d7558fc58a9f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2668bcf230eb2500d7b15e16a3036dad"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classcugl_1_1_poly2.html">Poly2</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1_complex_triangulator.html#a2668bcf230eb2500d7b15e16a3036dad">getMapPolygon</a> () const</td></tr>
<tr class="separator:a2668bcf230eb2500d7b15e16a3036dad"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a75c7536bca808165dd652e4c046732ca"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classcugl_1_1_poly2.html">Poly2</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1_complex_triangulator.html#a75c7536bca808165dd652e4c046732ca">getMapPolygon</a> (<a class="el" href="classcugl_1_1_poly2.html">Poly2</a> *buffer) const</td></tr>
<tr class="separator:a75c7536bca808165dd652e4c046732ca"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae34903132e320d7f88dbcac6af27f320"><td class="memItemLeft" align="right" valign="top">std::vector&lt; <a class="el" href="classcugl_1_1_poly2.html">Poly2</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1_complex_triangulator.html#ae34903132e320d7f88dbcac6af27f320">getVoronoi</a> () const</td></tr>
<tr class="separator:ae34903132e320d7f88dbcac6af27f320"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6426b021be1e06c1c002ec011886cae6"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classcugl_1_1_poly2.html">Poly2</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1_complex_triangulator.html#a6426b021be1e06c1c002ec011886cae6">getVoronoiCell</a> (size_t index) const</td></tr>
<tr class="separator:a6426b021be1e06c1c002ec011886cae6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a754469741247b28d5fccf4d803412203"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classcugl_1_1_poly2.html">Poly2</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1_complex_triangulator.html#a754469741247b28d5fccf4d803412203">getVoronoiCell</a> (size_t index, <a class="el" href="classcugl_1_1_poly2.html">Poly2</a> *buffer) const</td></tr>
<tr class="separator:a754469741247b28d5fccf4d803412203"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>This class is a factory for producing solid <a class="el" href="classcugl_1_1_poly2.html">Poly2</a> objects from a set of vertices.</p>
<p>For all but the simplist of shapes, it is important to have a triangulator that can divide up the polygon into triangles for drawing. This triangulator uses the poly2tri library to perform a Constrained Delaunay triangulation. This library supports complex polygons, namely those with interior holes (but not self-crossings). All triangles produced are guaranteed to be counter-clockwise.</p>
<p>Because the Voronoi diagram is the dual of the Delaunay triangulation, this factory can be used to extract this diagram. The Voronoi diagram can be extracted as either a single polygon (for each point) or a collection of polygons. Each polygon is a solid <a class="el" href="classcugl_1_1_poly2.html">Poly2</a> representing a region.</p>
<p>As with all factories, the methods are broken up into three phases: initialization, calculation, and materialization. To use the factory, you first set the data (in this case a set of vertices or another <a class="el" href="classcugl_1_1_poly2.html">Poly2</a>) with the initialization methods. You then call the calculation method. Finally, you use the materialization methods to access the data. Unlike the other triangulators, you cannot simply get this triangulation as a set of indices. That is because the triangulation may have added additional vertices.</p>
<p>This division allows us to support multithreaded calculation if the data generation takes too long. However, note that this factory is not thread safe in that you cannot access data while it is still in mid-calculation. </p>
</div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="a4bc99f41c6c1bd6c87e5eecae5f1898f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4bc99f41c6c1bd6c87e5eecae5f1898f">&#9670;&nbsp;</a></span>ComplexTriangulator() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">cugl::ComplexTriangulator::ComplexTriangulator </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Creates a triangulator with no vertex data. </p>

</div>
</div>
<a id="a3f1b8e0e5553eddcd1c3ebca17db97d6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3f1b8e0e5553eddcd1c3ebca17db97d6">&#9670;&nbsp;</a></span>ComplexTriangulator() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">cugl::ComplexTriangulator::ComplexTriangulator </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="classcugl_1_1_vec2.html">Vec2</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>points</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Creates a triangulator with the given vertex data.</p>
<p>The vertices are assumed to be the outer hull, and do not include any holes (which may be specified later). The vertex data is copied. The triangulator does not retain any references to the original data.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">points</td><td>The vertices to triangulate </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a4e261b777fdbaeb6736847c925ddbdda"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4e261b777fdbaeb6736847c925ddbdda">&#9670;&nbsp;</a></span>ComplexTriangulator() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">cugl::ComplexTriangulator::ComplexTriangulator </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classcugl_1_1_poly2.html">Poly2</a> &amp;&#160;</td>
          <td class="paramname"><em>poly</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Creates a triangulator with the given vertex data.</p>
<p>The triangulator assumes that the polygon represents a polyline. If the polygon represents a solid shape, it will be ignored. In addition, the polygon is assumed to be the outer hull, and that it does not contain any holes.</p>
<p>The vertex data is copied. The triangulator does not retain any references to the original data.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">poly</td><td>The vertices to triangulate </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a1fafed406b0263b83b126ca66f5efe63"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1fafed406b0263b83b126ca66f5efe63">&#9670;&nbsp;</a></span>~ComplexTriangulator()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">cugl::ComplexTriangulator::~ComplexTriangulator </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Deletes this triangulator, releasing all resources. </p>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="a66da9017c76170f34018bd6bf6e5921d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a66da9017c76170f34018bd6bf6e5921d">&#9670;&nbsp;</a></span>addHole() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void cugl::ComplexTriangulator::addHole </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classcugl_1_1_poly2.html">Poly2</a> &amp;&#160;</td>
          <td class="paramname"><em>poly</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Adds the given hole to the triangulation.</p>
<p>The triangulator assumes that the polygon represents a polyline. If the polygon represents a solid shape, it will be ignored. The hole is assumed to be a closed polygon with no self-crossings. In addition, it is assumed to be inside the polygon outer hull. If either of these is not true, the results are undefined.</p>
<p>The vertex data is copied. The triangulator does not retain any references to the original data. Hole points are added after the hull points, in order. That is, when the triangulation is computed, if the hull is size n, then the hull points are indices 0..n-1, while n is the index of a hole point.</p>
<p>Any holes added to the triangulator will be lost if the exterior polygon is changed via the <a class="el" href="classcugl_1_1_complex_triangulator.html#a63acf573779c04bad9ff811f2cf2a340">set</a> method.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">poly</td><td>The hole polyline </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a7a35fa9ed66fac85a7146996fb468e3c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7a35fa9ed66fac85a7146996fb468e3c">&#9670;&nbsp;</a></span>addHole() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void cugl::ComplexTriangulator::addHole </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="classcugl_1_1_vec2.html">Vec2</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>points</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Adds the given hole to the triangulation.</p>
<p>The hole is assumed to be a closed polygon with no self-crossings. In addition, it is assumed to be inside the polygon outer hull. If either of these is not true, the results are undefined.</p>
<p>The vertex data is copied. The triangulator does not retain any references to the original data. Hole points are added after the hull points, in order. That is, when the triangulation is computed, if the hull is size n, then the hull points are indices 0..n-1, while n is the index of a hole point.</p>
<p>Any holes added to the triangulator will be lost if the exterior polygon is changed via the <a class="el" href="classcugl_1_1_complex_triangulator.html#a63acf573779c04bad9ff811f2cf2a340">set</a> method.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">points</td><td>The hole vertices </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a752fee407680c7800f752bc29138831b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a752fee407680c7800f752bc29138831b">&#9670;&nbsp;</a></span>addSteiner()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void cugl::ComplexTriangulator::addSteiner </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classcugl_1_1_vec2.html">Vec2</a>&#160;</td>
          <td class="paramname"><em>point</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Adds the given Steiner point to the triangulation.</p>
<p>A Steiner point may be included in the triangulation results, but it does not have to be. Any Steiner points added to the triangulator will be lost if the exterior polygon is changed via the <a class="el" href="classcugl_1_1_complex_triangulator.html#a63acf573779c04bad9ff811f2cf2a340">set</a> method.</p>
<p>The vertex data is copied. The triangulator does not retain any references to the original data. Steiner points are added last. That is, when the triangulation is computed, the highest indices all refer to these points, in the order that they were provided.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">point</td><td>The Steiner point </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ab48b7e40616afd723b10e36344fe0edd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab48b7e40616afd723b10e36344fe0edd">&#9670;&nbsp;</a></span>calculate()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void cugl::ComplexTriangulator::calculate </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Performs a triangulation of the current vertex data.</p>
<p>This only calculates the triangulation. It does not compute the Voronoi dual. </p>

</div>
</div>
<a id="af71204ee844816d21d008f08ca8c778c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af71204ee844816d21d008f08ca8c778c">&#9670;&nbsp;</a></span>calculateDual()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void cugl::ComplexTriangulator::calculateDual </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Calculates the Voronoi diagram.</p>
<p>This will force a triangulation if one has not been computed already. In cases where triangles are missing to fully define the Voronoi diagram (such as on the boundary of the diagram), the missing triangles are interpolated. </p>

</div>
</div>
<a id="a5f480cda7245b223935c49b09d3344af"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5f480cda7245b223935c49b09d3344af">&#9670;&nbsp;</a></span>clear()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void cugl::ComplexTriangulator::clear </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Clears all internal data, including the initial vertex data.</p>
<p>When this method is called, you will need to set a new vertices before calling calculate. In addition, any holes or Steiner points will be lost as well. </p>

</div>
</div>
<a id="ae84ad7a439a59e5491bb30b116874825"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae84ad7a439a59e5491bb30b116874825">&#9670;&nbsp;</a></span>getMap() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;Uint32&gt; cugl::ComplexTriangulator::getMap </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns a list of indices representing the extended triangulation map.</p>
<p>The indices represent positions in the original vertex list, which included both holes and Steiner points. Positions are ordered as follows: first the exterior hull, then all holes in order, and finally the Steiner points. As these indices represent the extended triangulation, they may include triangles outside of the exterior hull.</p>
<p>The triangulator does not retain a reference to the returned list; it is safe to modify it. If the calculation is not yet performed, this method will return the empty list.</p>
<dl class="section return"><dt>Returns</dt><dd>a list of indices representing the triangulation. </dd></dl>

</div>
</div>
<a id="a02ba445a4e42a82535c0d7558fc58a9f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a02ba445a4e42a82535c0d7558fc58a9f">&#9670;&nbsp;</a></span>getMap() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t cugl::ComplexTriangulator::getMap </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; Uint32 &gt; &amp;&#160;</td>
          <td class="paramname"><em>buffer</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Stores the extended triangulation map indices in the given buffer.</p>
<p>The indices represent positions in the original vertex list, which included both holes and Steiner points. Positions are ordered as follows: first the exterior hull, then all holes in order, and finally the Steiner points. As these indices represent the extended triangulation, they may include triangles outside of the exterior hull.</p>
<p>The indices will be appended to the provided vector. You should clear the vector first if you do not want to preserve the original data. If the calculation is not yet performed, this method will do nothing.</p>
<dl class="section return"><dt>Returns</dt><dd>the number of elements added to the buffer </dd></dl>

</div>
</div>
<a id="a2668bcf230eb2500d7b15e16a3036dad"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2668bcf230eb2500d7b15e16a3036dad">&#9670;&nbsp;</a></span>getMapPolygon() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcugl_1_1_poly2.html">Poly2</a> cugl::ComplexTriangulator::getMapPolygon </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns a polygon representing the extended triangulation map.</p>
<p>This polygon is the extended triangulation, which may include triangles outside of the polygon hull. It may or many not include any Steiner points that were specified.</p>
<p>The triangulator does not maintain references to this polygon and it is safe to modify it. If the calculation is not yet performed, this method will return the empty polygon.</p>
<dl class="section return"><dt>Returns</dt><dd>a polygon representing the triangulation. </dd></dl>

</div>
</div>
<a id="a75c7536bca808165dd652e4c046732ca"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a75c7536bca808165dd652e4c046732ca">&#9670;&nbsp;</a></span>getMapPolygon() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcugl_1_1_poly2.html">Poly2</a>* cugl::ComplexTriangulator::getMapPolygon </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classcugl_1_1_poly2.html">Poly2</a> *&#160;</td>
          <td class="paramname"><em>buffer</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Stores the extended triangulation map in the given buffer.</p>
<p>This polygon is the extended triangulation, which may include triangles outside of the polygon hull. It may or many not include any Steiner points that were specified.</p>
<p>This method will append the vertices to the given polygon. If the buffer is not empty, the indices will be adjusted accordingly. You should clear the buffer first if you do not want to preserve the original data.</p>
<p>If the calculation is not yet performed, this method will do nothing.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">buffer</td><td>The buffer to store the triangulated polygon</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a reference to the buffer for chaining. </dd></dl>

</div>
</div>
<a id="a4ea792bc17780d0f489eeb9520b3622e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4ea792bc17780d0f489eeb9520b3622e">&#9670;&nbsp;</a></span>getPolygon() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcugl_1_1_poly2.html">Poly2</a> cugl::ComplexTriangulator::getPolygon </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns a polygon representing the triangulation.</p>
<p>This polygon is the proper triangulation, constrained to the interior of the polygon hull. It contains the vertices of the exterior polygon, as well as any holes. It may or many not include any Steiner points that were specified.</p>
<p>The triangulator does not maintain references to this polygon and it is safe to modify it. If the calculation is not yet performed, this method will return the empty polygon.</p>
<dl class="section return"><dt>Returns</dt><dd>a polygon representing the triangulation. </dd></dl>

</div>
</div>
<a id="a91acdf5cf138410f097d1c9ccf5ac98b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a91acdf5cf138410f097d1c9ccf5ac98b">&#9670;&nbsp;</a></span>getPolygon() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcugl_1_1_poly2.html">Poly2</a>* cugl::ComplexTriangulator::getPolygon </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classcugl_1_1_poly2.html">Poly2</a> *&#160;</td>
          <td class="paramname"><em>buffer</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Stores the triangulation in the given buffer.</p>
<p>The polygon produced is the proper triangulation, constrained to the interior of the polygon hull. It contains the vertices of the exterior polygon, as well as any holes. It may or many not include any Steiner points that were specified.</p>
<p>This method will append the vertices to the given polygon. If the buffer is not empty, the indices will be adjusted accordingly. You should clear the buffer first if you do not want to preserve the original data.</p>
<p>If the calculation is not yet performed, this method will do nothing.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">buffer</td><td>The buffer to store the triangulated polygon</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a reference to the buffer for chaining. </dd></dl>

</div>
</div>
<a id="a06bb3d9508ec02a2e8dab8243f8353f2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a06bb3d9508ec02a2e8dab8243f8353f2">&#9670;&nbsp;</a></span>getTriangulation() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;Uint32&gt; cugl::ComplexTriangulator::getTriangulation </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns a list of indices representing the triangulation.</p>
<p>The indices represent positions in the original vertex list, which included both holes and Steiner points. Positions are ordered as follows: first the exterior hull, then all holes in order, and finally the Steiner points.</p>
<p>The triangulator does not retain a reference to the returned list; it is safe to modify it. If the calculation is not yet performed, this method will return the empty list.</p>
<dl class="section return"><dt>Returns</dt><dd>a list of indices representing the triangulation. </dd></dl>

</div>
</div>
<a id="acf713bba6a48f38a77a364f13bff08d4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acf713bba6a48f38a77a364f13bff08d4">&#9670;&nbsp;</a></span>getTriangulation() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t cugl::ComplexTriangulator::getTriangulation </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; Uint32 &gt; &amp;&#160;</td>
          <td class="paramname"><em>buffer</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Stores the triangulation indices in the given buffer.</p>
<p>The indices represent positions in the original vertex list, which included both holes and Steiner points. Positions are ordered as follows: first the exterior hull, then all holes in order, and finally the Steiner points.</p>
<p>The indices will be appended to the provided vector. You should clear the vector first if you do not want to preserve the original data. If the calculation is not yet performed, this method will do nothing.</p>
<dl class="section return"><dt>Returns</dt><dd>the number of elements added to the buffer </dd></dl>

</div>
</div>
<a id="ae34903132e320d7f88dbcac6af27f320"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae34903132e320d7f88dbcac6af27f320">&#9670;&nbsp;</a></span>getVoronoi()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;<a class="el" href="classcugl_1_1_poly2.html">Poly2</a>&gt; cugl::ComplexTriangulator::getVoronoi </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns the Voronoi diagram as a list of polygons</p>
<p>Each polygon represents a single Voronoi cell. A Voronoi cell is a polygon whose vertices are the boundary of the cell. Each Voronoi cell corresponds to a vertex in the original triangulation.</p>
<p>The cells are returned in the same order as the vertices. For each cell, the <a class="el" href="classcugl_1_1_poly2.html">Poly2</a> object is triangulated as a fan with the associated vertex point at its center.</p>
<p>If the Voronoi diagram is not calculated, this method will do nothing.</p>
<dl class="section return"><dt>Returns</dt><dd>the Voronoi diagram as a list of polygons </dd></dl>

</div>
</div>
<a id="a6426b021be1e06c1c002ec011886cae6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6426b021be1e06c1c002ec011886cae6">&#9670;&nbsp;</a></span>getVoronoiCell() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcugl_1_1_poly2.html">Poly2</a> cugl::ComplexTriangulator::getVoronoiCell </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>index</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns the Voronoi cell for the given index</p>
<p>A Voronoi cell is a polygon whose vertices are the boundary of the cell. The index corresponds to the vertex in the original triangulation. The returns <a class="el" href="classcugl_1_1_poly2.html">Poly2</a> object is triangulated as a fan with the associated vertex point at its center.</p>
<p>If the Voronoi diagram is not calculated, this method will return an empty polygon</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">index</td><td>The index of the vertex generating the cell</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>he Voronoi cell for the given index </dd></dl>

</div>
</div>
<a id="a754469741247b28d5fccf4d803412203"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a754469741247b28d5fccf4d803412203">&#9670;&nbsp;</a></span>getVoronoiCell() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcugl_1_1_poly2.html">Poly2</a>* cugl::ComplexTriangulator::getVoronoiCell </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classcugl_1_1_poly2.html">Poly2</a> *&#160;</td>
          <td class="paramname"><em>buffer</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Stores the Voronoi cell in the given buffer.</p>
<p>A Voronoi cell is a polygon whose vertices are the boundary of the cell. The index corresponds to the vertex in the original triangulation. The returns <a class="el" href="classcugl_1_1_poly2.html">Poly2</a> object is triangulated as a fan with the associated vertex point at its center.</p>
<p>If the Voronoi diagram is not calculated, this method will do nothing.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">index</td><td>The index of the vertex generating the cell </td></tr>
    <tr><td class="paramname">buffer</td><td>The buffer to store the Voronoi cell</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a reference to the buffer for chaining. </dd></dl>

</div>
</div>
<a id="a70aae5496cfcced0dd28cf27e71ef169"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a70aae5496cfcced0dd28cf27e71ef169">&#9670;&nbsp;</a></span>reset()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void cugl::ComplexTriangulator::reset </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Clears all internal data, but still maintains the initial vertex data.</p>
<p>This method also retains any holes or Steiner points. It only clears the triangulation results. </p>

</div>
</div>
<a id="aa3bb8d1e5b50ec0746e3ae3012f7d46b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa3bb8d1e5b50ec0746e3ae3012f7d46b">&#9670;&nbsp;</a></span>set() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void cugl::ComplexTriangulator::set </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classcugl_1_1_poly2.html">Poly2</a> &amp;&#160;</td>
          <td class="paramname"><em>poly</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Sets the exterior vertex data for this triangulator.</p>
<p>The triangulator assumes that the polygon represents a polyline. If the polygon represents a solid shape, it will be ignored. In addition, the polygon is assumed to be the outer hull, and that it does not contain any holes.</p>
<p>The vertex data is copied. The triangulator does not retain any references to the original data. Hull points are added first. That is, when the triangulation is computed, the lowest indices all refer to these points, in the order that they were provided.</p>
<p>This method resets all interal data. The triangulation is lost, as well as any previously added holes or Steiner points. You will need to re-add any lost data and reperform the calucation.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">poly</td><td>The vertices to triangulate </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a63acf573779c04bad9ff811f2cf2a340"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a63acf573779c04bad9ff811f2cf2a340">&#9670;&nbsp;</a></span>set() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void cugl::ComplexTriangulator::set </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="classcugl_1_1_vec2.html">Vec2</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>points</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Sets the exterior vertex data for this triangulator.</p>
<p>The vertices are assumed to be the outer hull, and do not include any holes (which may be specified later).</p>
<p>The vertex data is copied. The triangulator does not retain any references to the original data. Hull points are added first. That is, when the triangulation is computed, the lowest indices all refer to these points, in the order that they were provided.</p>
<p>This method resets all interal data. The triangulation is lost, as well as any previously added holes or Steiner points. You will need to re-add any lost data and reperform the calucation.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">points</td><td>The vertices to triangulate </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>include/cugl/math/polygon/<a class="el" href="_c_u_complex_triangulator_8h_source.html">CUComplexTriangulator.h</a></li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.1
</small></address>
</body>
</html>
