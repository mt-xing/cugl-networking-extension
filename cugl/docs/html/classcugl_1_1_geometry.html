<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.9.1"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>CUGL 2.0: cugl::Geometry Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">CUGL 2.0
   </div>
   <div id="projectbrief">Cornell University Game Library</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.1 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search','.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespacecugl.html">cugl</a></li><li class="navelem"><a class="el" href="classcugl_1_1_geometry.html">Geometry</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-static-methods">Static Public Member Functions</a> &#124;
<a href="classcugl_1_1_geometry-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">cugl::Geometry Class Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p><code>#include &lt;<a class="el" href="_c_u_geometry_8h_source.html">CUGeometry.h</a>&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:a5ad34fdd33aa23ffc0c374bf6f2d11b5"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1_geometry.html#a5ad34fdd33aa23ffc0c374bf6f2d11b5">Value</a> : uint8_t { <a class="el" href="classcugl_1_1_geometry.html#a5ad34fdd33aa23ffc0c374bf6f2d11b5a4d1a449922397969e6fe464fa7cdf805">IMPLICIT</a>
, <a class="el" href="classcugl_1_1_geometry.html#a5ad34fdd33aa23ffc0c374bf6f2d11b5af04c58f416450be94b2c9ac73020cbc7">POINTS</a>
, <a class="el" href="classcugl_1_1_geometry.html#a5ad34fdd33aa23ffc0c374bf6f2d11b5ab950bc5b35fc0869f451794889838a4b">PATH</a>
, <a class="el" href="classcugl_1_1_geometry.html#a5ad34fdd33aa23ffc0c374bf6f2d11b5ac6969385269556756b005c22b71a6e44">SOLID</a>
 }</td></tr>
<tr class="separator:a5ad34fdd33aa23ffc0c374bf6f2d11b5"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a16969d168b865caa7c6b462a73b268bc"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1_geometry.html#a16969d168b865caa7c6b462a73b268bc">Geometry</a> ()=default</td></tr>
<tr class="separator:a16969d168b865caa7c6b462a73b268bc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae21148e7b8d534137992aef60393e42c"><td class="memItemLeft" align="right" valign="top">constexpr&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1_geometry.html#ae21148e7b8d534137992aef60393e42c">Geometry</a> (<a class="el" href="classcugl_1_1_geometry.html#a5ad34fdd33aa23ffc0c374bf6f2d11b5">Value</a> val)</td></tr>
<tr class="separator:ae21148e7b8d534137992aef60393e42c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a50cf846629fb850247910b4ec80c971a"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1_geometry.html#a50cf846629fb850247910b4ec80c971a">operator Value</a> () const</td></tr>
<tr class="separator:a50cf846629fb850247910b4ec80c971a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afb27a78a56144c0c8275740f2399d240"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1_geometry.html#afb27a78a56144c0c8275740f2399d240">operator bool</a> ()=delete</td></tr>
<tr class="separator:afb27a78a56144c0c8275740f2399d240"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a35fd491363025cd37eecbd618f75aee1"><td class="memItemLeft" align="right" valign="top">GLuint&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1_geometry.html#a35fd491363025cd37eecbd618f75aee1">glCommand</a> () const</td></tr>
<tr class="separator:a35fd491363025cd37eecbd618f75aee1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a706ef05b5f55354d8d6c7b7c105acc9f"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1_geometry.html#a706ef05b5f55354d8d6c7b7c105acc9f">matches</a> (const std::vector&lt; Uint32 &gt; &amp;indices) const</td></tr>
<tr class="separator:a706ef05b5f55354d8d6c7b7c105acc9f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2f2a049a82fb7a98ccf52ebb5c4e14d1"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1_geometry.html#a2f2a049a82fb7a98ccf52ebb5c4e14d1">matches</a> (const Uint32 *indices, size_t size) const</td></tr>
<tr class="separator:a2f2a049a82fb7a98ccf52ebb5c4e14d1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1bdff4af0f28beac54921325ff6da2e2"><td class="memItemLeft" align="right" valign="top">std::vector&lt; Uint32 &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1_geometry.html#a1bdff4af0f28beac54921325ff6da2e2">index</a> (const std::vector&lt; <a class="el" href="classcugl_1_1_vec2.html">Vec2</a> &gt; &amp;vertices) const</td></tr>
<tr class="separator:a1bdff4af0f28beac54921325ff6da2e2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac39c61965d0085e5aee2079c9d25159a"><td class="memItemLeft" align="right" valign="top">std::vector&lt; Uint32 &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1_geometry.html#ac39c61965d0085e5aee2079c9d25159a">index</a> (const std::vector&lt; float &gt; &amp;vertices) const</td></tr>
<tr class="separator:ac39c61965d0085e5aee2079c9d25159a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2a7d7c572e4a43a0a981d785b1159433"><td class="memItemLeft" align="right" valign="top">std::vector&lt; Uint32 &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1_geometry.html#a2a7d7c572e4a43a0a981d785b1159433">index</a> (const float *vertices, size_t size) const</td></tr>
<tr class="separator:a2a7d7c572e4a43a0a981d785b1159433"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0305e4cafad59559c1fe680cb501a340"><td class="memItemLeft" align="right" valign="top">std::unordered_set&lt; Uint32 &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1_geometry.html#a0305e4cafad59559c1fe680cb501a340">exterior</a> (const std::vector&lt; Uint32 &gt; indices) const</td></tr>
<tr class="separator:a0305e4cafad59559c1fe680cb501a340"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a340ec028ba9d7de30f0761c85b36a2ff"><td class="memItemLeft" align="right" valign="top">std::unordered_set&lt; Uint32 &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1_geometry.html#a340ec028ba9d7de30f0761c85b36a2ff">exterior</a> (const Uint32 *indices, size_t size) const</td></tr>
<tr class="separator:a340ec028ba9d7de30f0761c85b36a2ff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acd722d13b3ca748a563eb85f95a42025"><td class="memItemLeft" align="right" valign="top">std::vector&lt; std::vector&lt; Uint32 &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1_geometry.html#acd722d13b3ca748a563eb85f95a42025">boundaries</a> (const std::vector&lt; Uint32 &gt; &amp;indices) const</td></tr>
<tr class="separator:acd722d13b3ca748a563eb85f95a42025"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a662f1c5cc1f2011697f2d7ce144a8f4e"><td class="memItemLeft" align="right" valign="top">std::vector&lt; std::vector&lt; Uint32 &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1_geometry.html#a662f1c5cc1f2011697f2d7ce144a8f4e">boundaries</a> (const Uint32 *indices, size_t size) const</td></tr>
<tr class="separator:a662f1c5cc1f2011697f2d7ce144a8f4e"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-static-methods"></a>
Static Public Member Functions</h2></td></tr>
<tr class="memitem:ae8d10b1530c4b2e8707fd77ccd87bfb2"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classcugl_1_1_geometry.html">Geometry</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1_geometry.html#ae8d10b1530c4b2e8707fd77ccd87bfb2">categorize</a> (const std::vector&lt; Uint32 &gt; &amp;indices)</td></tr>
<tr class="separator:ae8d10b1530c4b2e8707fd77ccd87bfb2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6371e8214ca705dee007eb6130c07d95"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classcugl_1_1_geometry.html">Geometry</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1_geometry.html#a6371e8214ca705dee007eb6130c07d95">categorize</a> (const Uint32 *indices, size_t size)</td></tr>
<tr class="separator:a6371e8214ca705dee007eb6130c07d95"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>This class (enum) is used to provide meaning to a set of vertex indices.</p>
<p>Rendering classes should use this type as a hint for how to render a polygon. In particular, the method <a class="el" href="classcugl_1_1_geometry.html#a35fd491363025cd37eecbd618f75aee1">glCommand()</a> returns an OpenGL command corresponding the index geometry.</p>
<p>There is not a one-to-one correspondence between geometries and OpenGL drawing commands. Geometries are concerned with structure, not the optimal organization of indices. So we do not make a distinction between triangles, triangle strips, or triangle fans.</p>
<p>In fact, the geometries supported all correspond to decomposable indices. These are the OpenGL commands TRIANGLES, LINES, or POINTS. These correspond to indices that we can easily split and combine on vertex concatenation. </p>
</div><h2 class="groupheader">Member Enumeration Documentation</h2>
<a id="a5ad34fdd33aa23ffc0c374bf6f2d11b5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5ad34fdd33aa23ffc0c374bf6f2d11b5">&#9670;&nbsp;</a></span>Value</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="classcugl_1_1_geometry.html#a5ad34fdd33aa23ffc0c374bf6f2d11b5">cugl::Geometry::Value</a> : uint8_t</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>The geometry values</p>
<p>This enum provides the values for this enum class, but the code in this class allows us to "skip over" it. That is, we can write <a class="el" href="classcugl_1_1_geometry.html#a5ad34fdd33aa23ffc0c374bf6f2d11b5a4d1a449922397969e6fe464fa7cdf805">Geometry::IMPLICIT</a> in place of Geometry::Value::IMPLICIT, and so on. So we can ignore this enum. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="a5ad34fdd33aa23ffc0c374bf6f2d11b5a4d1a449922397969e6fe464fa7cdf805"></a>IMPLICIT&#160;</td><td class="fielddoc"><p>This geometry corresponds to an empty set of vertices.</p>
<p>In this case the geometry is inferred from the vertex order. Such an object is useful for pure math computations, but has no drawing mesh. </p>
</td></tr>
<tr><td class="fieldname"><a id="a5ad34fdd33aa23ffc0c374bf6f2d11b5af04c58f416450be94b2c9ac73020cbc7"></a>POINTS&#160;</td><td class="fielddoc"><p>This geometry corresponds to an unstructured set of indices..</p>
<p>In this case indices represent the vertices that are relevant. Vertices not in the index set are ignored. </p>
</td></tr>
<tr><td class="fieldname"><a id="a5ad34fdd33aa23ffc0c374bf6f2d11b5ab950bc5b35fc0869f451794889838a4b"></a>PATH&#160;</td><td class="fielddoc"><p>This geometry represents an open path outline.</p>
<p>The indices are a sequence of line segments. That is, the number of indices is divisible by two, with each pair forming a segment. These segments may or be linked to each other. </p>
</td></tr>
<tr><td class="fieldname"><a id="a5ad34fdd33aa23ffc0c374bf6f2d11b5ac6969385269556756b005c22b71a6e44"></a>SOLID&#160;</td><td class="fielddoc"><p>This geometry represents a solid shape with a triangulation.</p>
<p>The indices are a sequence of triangles. That is, the number of indices is divisible by three, with each triplet forming a triangle. </p>
</td></tr>
</table>

</div>
</div>
<h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="a16969d168b865caa7c6b462a73b268bc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a16969d168b865caa7c6b462a73b268bc">&#9670;&nbsp;</a></span>Geometry() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">cugl::Geometry::Geometry </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">default</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Disable the explicity Geomtry constructor </p>

</div>
</div>
<a id="ae21148e7b8d534137992aef60393e42c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae21148e7b8d534137992aef60393e42c">&#9670;&nbsp;</a></span>Geometry() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr cugl::Geometry::Geometry </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classcugl_1_1_geometry.html#a5ad34fdd33aa23ffc0c374bf6f2d11b5">Value</a>&#160;</td>
          <td class="paramname"><em>val</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Construct a geometry with one of the enumeration values</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">val</td><td>The enumeration value </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="acd722d13b3ca748a563eb85f95a42025"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acd722d13b3ca748a563eb85f95a42025">&#9670;&nbsp;</a></span>boundaries() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;std::vector&lt;Uint32&gt; &gt; cugl::Geometry::boundaries </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; Uint32 &gt; &amp;&#160;</td>
          <td class="paramname"><em>indices</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns the connected boundary components for this geometry.</p>
<p>This method allows us to reconstruct the exterior boundary of a solid shape, or to compose a pathwise connected curve into components.</p>
<p>For the geometry <a class="el" href="classcugl_1_1_geometry.html#a5ad34fdd33aa23ffc0c374bf6f2d11b5ab950bc5b35fc0869f451794889838a4b">PATH</a>, the elements of the outer array are connected links of line segments, with the indices listed in order of the path traversal. A closed path only has one component, so the outer array will only have one element. An open path may have several components if there are discontinuities in the path. <a class="el" href="classcugl_1_1_geometry.html#a5ad34fdd33aa23ffc0c374bf6f2d11b5a4d1a449922397969e6fe464fa7cdf805">IMPLICIT</a> geometries are treated as if they were closed a closed path.</p>
<p>For <a class="el" href="classcugl_1_1_geometry.html#a5ad34fdd33aa23ffc0c374bf6f2d11b5ac6969385269556756b005c22b71a6e44">SOLID</a>, this method detriangulates the mesh, returning the outer hull, and discarding any interior points. This hull need not be convex (as concave or convex cannot be inferred from indices alone). If the mesh represents a simple polygon, only one boundary will be returned. If the mesh is not continuous, the outer array will contain the boundary of each disjoint polygon. If the mesh has holes, each hole will be returned as a separate boundary. There is no guarantee on the order of boundaries returned.</p>
<p>For <a class="el" href="classcugl_1_1_geometry.html#a5ad34fdd33aa23ffc0c374bf6f2d11b5af04c58f416450be94b2c9ac73020cbc7">POINTS</a>, there are no connected components, so this method returns an array of single-element arrays. <a class="el" href="classcugl_1_1_geometry.html#a5ad34fdd33aa23ffc0c374bf6f2d11b5a4d1a449922397969e6fe464fa7cdf805">IMPLICIT</a> returns null, as it is impossible to infer the boundaries without the vertices.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">indices</td><td>The indices to process</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the connected boundary components for this geometry. </dd></dl>

</div>
</div>
<a id="a662f1c5cc1f2011697f2d7ce144a8f4e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a662f1c5cc1f2011697f2d7ce144a8f4e">&#9670;&nbsp;</a></span>boundaries() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;std::vector&lt;Uint32&gt; &gt; cugl::Geometry::boundaries </td>
          <td>(</td>
          <td class="paramtype">const Uint32 *&#160;</td>
          <td class="paramname"><em>indices</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns the connected boundary components for this geometry.</p>
<p>This method allows us to reconstruct the exterior boundary of a solid shape, or to compose a pathwise connected curve into components.</p>
<p>For the geometry <a class="el" href="classcugl_1_1_geometry.html#a5ad34fdd33aa23ffc0c374bf6f2d11b5ab950bc5b35fc0869f451794889838a4b">PATH</a>, the elements of the outer array are connected links of line segments, with the indices listed in order of the path traversal. A closed path only has one component, so the outer array will only have one element. An open path may have several components if there are discontinuities in the path. <a class="el" href="classcugl_1_1_geometry.html#a5ad34fdd33aa23ffc0c374bf6f2d11b5a4d1a449922397969e6fe464fa7cdf805">IMPLICIT</a> geometries are treated as if they were closed a closed path.</p>
<p>For <a class="el" href="classcugl_1_1_geometry.html#a5ad34fdd33aa23ffc0c374bf6f2d11b5ac6969385269556756b005c22b71a6e44">SOLID</a>, this method detriangulates the mesh, returning the outer hull, and discarding any interior points. This hull need not be convex (as concave or convex cannot be inferred from indices alone). If the mesh represents a simple polygon, only one boundary will be returned. If the mesh is not continuous, the outer array will contain the boundary of each disjoint polygon. If the mesh has holes, each hole will be returned as a separate boundary. There is no guarantee on the order of boundaries returned.</p>
<p>For <a class="el" href="classcugl_1_1_geometry.html#a5ad34fdd33aa23ffc0c374bf6f2d11b5af04c58f416450be94b2c9ac73020cbc7">POINTS</a>, there are no connected components, so this method returns an array of single-element arrays. <a class="el" href="classcugl_1_1_geometry.html#a5ad34fdd33aa23ffc0c374bf6f2d11b5a4d1a449922397969e6fe464fa7cdf805">IMPLICIT</a> returns null, as it is impossible to infer the boundaries without the vertices.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">indices</td><td>The indices to process </td></tr>
    <tr><td class="paramname">size</td><td>The index size</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the connected boundary components for this geometry. </dd></dl>

</div>
</div>
<a id="ae8d10b1530c4b2e8707fd77ccd87bfb2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae8d10b1530c4b2e8707fd77ccd87bfb2">&#9670;&nbsp;</a></span>categorize() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="classcugl_1_1_geometry.html">Geometry</a> cugl::Geometry::categorize </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; Uint32 &gt; &amp;&#160;</td>
          <td class="paramname"><em>indices</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns the best guess for the geometry of these indices</p>
<p>If the indices form a continuous link of pairs, then it will identify them as a <a class="el" href="classcugl_1_1_geometry.html#a5ad34fdd33aa23ffc0c374bf6f2d11b5ab950bc5b35fc0869f451794889838a4b">PATH</a>. Otherwise, this method can only guess at the geometry from the parity. If the number of indices is a multiple of 3, it assumes it is <a class="el" href="classcugl_1_1_geometry.html#a5ad34fdd33aa23ffc0c374bf6f2d11b5ac6969385269556756b005c22b71a6e44">SOLID</a>. If it is a multiple of 2, it assumes it is a <a class="el" href="classcugl_1_1_geometry.html#a5ad34fdd33aa23ffc0c374bf6f2d11b5ab950bc5b35fc0869f451794889838a4b">PATH</a>. If neither is true, it identifies these as <a class="el" href="classcugl_1_1_geometry.html#a5ad34fdd33aa23ffc0c374bf6f2d11b5af04c58f416450be94b2c9ac73020cbc7">POINTS</a>. It is only <a class="el" href="classcugl_1_1_geometry.html#a5ad34fdd33aa23ffc0c374bf6f2d11b5a4d1a449922397969e6fe464fa7cdf805">IMPLICIT</a> if indices are null or empty.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">indices</td><td>The indices to analyze</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the best guess for the geometry of these indices </dd></dl>

</div>
</div>
<a id="a6371e8214ca705dee007eb6130c07d95"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6371e8214ca705dee007eb6130c07d95">&#9670;&nbsp;</a></span>categorize() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="classcugl_1_1_geometry.html">Geometry</a> cugl::Geometry::categorize </td>
          <td>(</td>
          <td class="paramtype">const Uint32 *&#160;</td>
          <td class="paramname"><em>indices</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns the best guess for the geometry of these indices</p>
<p>If the indices form a continuous link of pairs, then it will identify them as a <a class="el" href="classcugl_1_1_geometry.html#a5ad34fdd33aa23ffc0c374bf6f2d11b5ab950bc5b35fc0869f451794889838a4b">PATH</a>. Otherwise, this method can only guess at the geometry from the parity. If the number of indices is a multiple of 3, it assumes it is <a class="el" href="classcugl_1_1_geometry.html#a5ad34fdd33aa23ffc0c374bf6f2d11b5ac6969385269556756b005c22b71a6e44">SOLID</a>. If it is a multiple of 2, it assumes it is a <a class="el" href="classcugl_1_1_geometry.html#a5ad34fdd33aa23ffc0c374bf6f2d11b5ab950bc5b35fc0869f451794889838a4b">PATH</a>. If neither is true, it identifies these as <a class="el" href="classcugl_1_1_geometry.html#a5ad34fdd33aa23ffc0c374bf6f2d11b5af04c58f416450be94b2c9ac73020cbc7">POINTS</a>. It is only <a class="el" href="classcugl_1_1_geometry.html#a5ad34fdd33aa23ffc0c374bf6f2d11b5a4d1a449922397969e6fe464fa7cdf805">IMPLICIT</a> if indices are null or empty.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">indices</td><td>The indices to analyze </td></tr>
    <tr><td class="paramname">size</td><td>The index size</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the best guess for the geometry of these indices </dd></dl>

</div>
</div>
<a id="a0305e4cafad59559c1fe680cb501a340"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0305e4cafad59559c1fe680cb501a340">&#9670;&nbsp;</a></span>exterior() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::unordered_set&lt;Uint32&gt; cugl::Geometry::exterior </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; Uint32 &gt;&#160;</td>
          <td class="paramname"><em>indices</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns the set of indices that are on a boundary of this geometry</p>
<p>This method is really only relevant for <a class="el" href="classcugl_1_1_geometry.html#a5ad34fdd33aa23ffc0c374bf6f2d11b5ac6969385269556756b005c22b71a6e44">SOLID</a> geometry. For other geometries, it simply returns a set of the indices. In the case of solid geometries, it identifies the outer hull (not necessarily convex).</p>
<p>This method can identify the outer hull using the graph properties of the triangle mesh. An internal node if the number of neighbors is the same as the number of attached triangles. An index that is not internal is external.</p>
<p>Unlike <a class="el" href="classcugl_1_1_geometry.html#acd722d13b3ca748a563eb85f95a42025">boundaries</a>, this method does not order the boundary indices or decompose them into connected components.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">indices</td><td>The indices to process</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the set of indices that are on a boundary of this geometry </dd></dl>

</div>
</div>
<a id="a340ec028ba9d7de30f0761c85b36a2ff"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a340ec028ba9d7de30f0761c85b36a2ff">&#9670;&nbsp;</a></span>exterior() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::unordered_set&lt;Uint32&gt; cugl::Geometry::exterior </td>
          <td>(</td>
          <td class="paramtype">const Uint32 *&#160;</td>
          <td class="paramname"><em>indices</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns the set of indices that are on a boundary of this geometry</p>
<p>This method is really only relevant for <a class="el" href="classcugl_1_1_geometry.html#a5ad34fdd33aa23ffc0c374bf6f2d11b5ac6969385269556756b005c22b71a6e44">SOLID</a> geometry. For other geometries, it simply returns a set of the indices. In the case of solid geometries, it identifies the outer hull (not necessarily convex).</p>
<p>This method can identify the outer hull using the graph properties of the triangle mesh. An internal node if the number of neighbors is the same as the number of attached triangles. An index that is not internal is external.</p>
<p>Unlike <a class="el" href="classcugl_1_1_geometry.html#acd722d13b3ca748a563eb85f95a42025">boundaries</a>, this method does not order the boundary indices or decompose them into connected components.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">indices</td><td>The indices to process </td></tr>
    <tr><td class="paramname">size</td><td>The index size</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the set of indices that are on a boundary of this geometry </dd></dl>

</div>
</div>
<a id="a35fd491363025cd37eecbd618f75aee1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a35fd491363025cd37eecbd618f75aee1">&#9670;&nbsp;</a></span>glCommand()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">GLuint cugl::Geometry::glCommand </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns the OpenGL drawing code for this geometry</p>
<p>If the geometry is <a class="el" href="classcugl_1_1_geometry.html#a5ad34fdd33aa23ffc0c374bf6f2d11b5a4d1a449922397969e6fe464fa7cdf805">IMPLICIT</a>, this method returns -1.</p>
<dl class="section return"><dt>Returns</dt><dd>the OpenGL drawing code for this geometry </dd></dl>

</div>
</div>
<a id="a2a7d7c572e4a43a0a981d785b1159433"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2a7d7c572e4a43a0a981d785b1159433">&#9670;&nbsp;</a></span>index() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;Uint32&gt; cugl::Geometry::index </td>
          <td>(</td>
          <td class="paramtype">const float *&#160;</td>
          <td class="paramname"><em>vertices</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns a canonical set of indices for the given vertex list</p>
<p>This takes a vertex list and generates a canonical index list that matches this geometry. For <a class="el" href="classcugl_1_1_geometry.html#a5ad34fdd33aa23ffc0c374bf6f2d11b5a4d1a449922397969e6fe464fa7cdf805">IMPLICIT</a>, this will return an empty index set. For <a class="el" href="classcugl_1_1_geometry.html#a5ad34fdd33aa23ffc0c374bf6f2d11b5af04c58f416450be94b2c9ac73020cbc7">POINTS</a> it is the index of all the vertices. For <a class="el" href="classcugl_1_1_geometry.html#a5ad34fdd33aa23ffc0c374bf6f2d11b5ab950bc5b35fc0869f451794889838a4b">PATH</a>, it is a linked set of segment indices of the vertices in order.</p>
<p>For <a class="el" href="classcugl_1_1_geometry.html#a5ad34fdd33aa23ffc0c374bf6f2d11b5ac6969385269556756b005c22b71a6e44">SOLID</a> it triangulates the vertices. For simplicity, this method does not support vertex lists with self-crossings. Such polygons will need to be decomposed first. This method always uses a <a class="el" href="classcugl_1_1_simple_triangulator.html">SimpleTriangulator</a>. If you wish to use another algorithm (such as <a class="el" href="classcugl_1_1_complex_triangulator.html">ComplexTriangulator</a>), you will need to generate the indices separately.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">vertices</td><td>The vertex list </td></tr>
    <tr><td class="paramname">size</td><td>The number of vertices</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a canonical set of indices for the given vertex list </dd></dl>

</div>
</div>
<a id="ac39c61965d0085e5aee2079c9d25159a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac39c61965d0085e5aee2079c9d25159a">&#9670;&nbsp;</a></span>index() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;Uint32&gt; cugl::Geometry::index </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; float &gt; &amp;&#160;</td>
          <td class="paramname"><em>vertices</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns a canonical set of indices for the given vertex list</p>
<p>This takes a vertex list and generates a canonical index list that matches this geometry. For <a class="el" href="classcugl_1_1_geometry.html#a5ad34fdd33aa23ffc0c374bf6f2d11b5a4d1a449922397969e6fe464fa7cdf805">IMPLICIT</a>, this will return an empty index set. For <a class="el" href="classcugl_1_1_geometry.html#a5ad34fdd33aa23ffc0c374bf6f2d11b5af04c58f416450be94b2c9ac73020cbc7">POINTS</a> it is the index of all the vertices. For <a class="el" href="classcugl_1_1_geometry.html#a5ad34fdd33aa23ffc0c374bf6f2d11b5ab950bc5b35fc0869f451794889838a4b">PATH</a>, it is a linked set of segment indices of the vertices in order.</p>
<p>For <a class="el" href="classcugl_1_1_geometry.html#a5ad34fdd33aa23ffc0c374bf6f2d11b5ac6969385269556756b005c22b71a6e44">SOLID</a> it triangulates the vertices. For simplicity, this method does not support vertex lists with self-crossings. Such polygons will need to be decomposed first. This method always uses a <a class="el" href="classcugl_1_1_simple_triangulator.html">SimpleTriangulator</a>. If you wish to use another algorithm (such as <a class="el" href="classcugl_1_1_complex_triangulator.html">ComplexTriangulator</a>), you will need to generate the indices separately.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">vertices</td><td>The vertex list</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a canonical set of indices for the given vertex list </dd></dl>

</div>
</div>
<a id="a1bdff4af0f28beac54921325ff6da2e2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1bdff4af0f28beac54921325ff6da2e2">&#9670;&nbsp;</a></span>index() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;Uint32&gt; cugl::Geometry::index </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="classcugl_1_1_vec2.html">Vec2</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>vertices</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns a canonical set of indices for the given vertex list</p>
<p>This takes a vertex list and generates a canonical index list that matches this geometry. For <a class="el" href="classcugl_1_1_geometry.html#a5ad34fdd33aa23ffc0c374bf6f2d11b5a4d1a449922397969e6fe464fa7cdf805">IMPLICIT</a>, this will return an empty index set. For <a class="el" href="classcugl_1_1_geometry.html#a5ad34fdd33aa23ffc0c374bf6f2d11b5af04c58f416450be94b2c9ac73020cbc7">POINTS</a> it is the index of all the vertices. For <a class="el" href="classcugl_1_1_geometry.html#a5ad34fdd33aa23ffc0c374bf6f2d11b5ab950bc5b35fc0869f451794889838a4b">PATH</a>, it is a linked set of segment indices of the vertices in order.</p>
<p>For <a class="el" href="classcugl_1_1_geometry.html#a5ad34fdd33aa23ffc0c374bf6f2d11b5ac6969385269556756b005c22b71a6e44">SOLID</a> it triangulates the vertices. For simplicity, this method does not support vertex lists with self-crossings. Such polygons will need to be decomposed first. This method always uses a <a class="el" href="classcugl_1_1_simple_triangulator.html">SimpleTriangulator</a>. If you wish to use another algorithm (such as <a class="el" href="classcugl_1_1_complex_triangulator.html">ComplexTriangulator</a>), you will need to generate the indices separately.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">vertices</td><td>The vertex list</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a canonical set of indices for the given vertex list </dd></dl>

</div>
</div>
<a id="a706ef05b5f55354d8d6c7b7c105acc9f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a706ef05b5f55354d8d6c7b7c105acc9f">&#9670;&nbsp;</a></span>matches() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool cugl::Geometry::matches </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; Uint32 &gt; &amp;&#160;</td>
          <td class="paramname"><em>indices</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns true if the indices match this geometry.</p>
<p>If the geometry is <a class="el" href="classcugl_1_1_geometry.html#a5ad34fdd33aa23ffc0c374bf6f2d11b5ac6969385269556756b005c22b71a6e44">SOLID</a>, this method will only detect if the number of indices is divisible by three. For <a class="el" href="classcugl_1_1_geometry.html#a5ad34fdd33aa23ffc0c374bf6f2d11b5ab950bc5b35fc0869f451794889838a4b">PATH</a>, it will detect if the number of indices is not divisible by 2. Finally, <a class="el" href="classcugl_1_1_geometry.html#a5ad34fdd33aa23ffc0c374bf6f2d11b5a4d1a449922397969e6fe464fa7cdf805">IMPLICIT</a> requires the indices be empty, but the geometry <a class="el" href="classcugl_1_1_geometry.html#a5ad34fdd33aa23ffc0c374bf6f2d11b5af04c58f416450be94b2c9ac73020cbc7">POINTS</a> matches anything.</p>
<p>This method does not validate that the indices are with in range, as that requires knowledge of the vertices.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">indices</td><td>The indices to test</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if the indices match this geometry. </dd></dl>

</div>
</div>
<a id="a2f2a049a82fb7a98ccf52ebb5c4e14d1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2f2a049a82fb7a98ccf52ebb5c4e14d1">&#9670;&nbsp;</a></span>matches() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool cugl::Geometry::matches </td>
          <td>(</td>
          <td class="paramtype">const Uint32 *&#160;</td>
          <td class="paramname"><em>indices</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns true if the indices match this geometry.</p>
<p>If the geometry is <a class="el" href="classcugl_1_1_geometry.html#a5ad34fdd33aa23ffc0c374bf6f2d11b5ac6969385269556756b005c22b71a6e44">SOLID</a>, this method will only detect if the number of indices is divisible by three. For <a class="el" href="classcugl_1_1_geometry.html#a5ad34fdd33aa23ffc0c374bf6f2d11b5ab950bc5b35fc0869f451794889838a4b">PATH</a>, it will detect if the number of indices is not divisible by 2. Finally, <a class="el" href="classcugl_1_1_geometry.html#a5ad34fdd33aa23ffc0c374bf6f2d11b5a4d1a449922397969e6fe464fa7cdf805">IMPLICIT</a> requires the indices be empty, but the geometry <a class="el" href="classcugl_1_1_geometry.html#a5ad34fdd33aa23ffc0c374bf6f2d11b5af04c58f416450be94b2c9ac73020cbc7">POINTS</a> matches anything.</p>
<p>This method does not validate that the indices are with in range, as that requires knowledge of the vertices.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">indices</td><td>The indices to test </td></tr>
    <tr><td class="paramname">size</td><td>The index size</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if the indices match this geometry. </dd></dl>

</div>
</div>
<a id="afb27a78a56144c0c8275740f2399d240"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afb27a78a56144c0c8275740f2399d240">&#9670;&nbsp;</a></span>operator bool()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">cugl::Geometry::operator bool </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">explicit</span><span class="mlabel">delete</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Prevent usage: if(geom) </p>

</div>
</div>
<a id="a50cf846629fb850247910b4ec80c971a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a50cf846629fb850247910b4ec80c971a">&#9670;&nbsp;</a></span>operator Value()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">cugl::Geometry::operator <a class="el" href="classcugl_1_1_geometry.html#a5ad34fdd33aa23ffc0c374bf6f2d11b5">Value</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns the current value of this geometry.</p>
<p>This method enables both direct comparisons and swith statements.</p>
<dl class="section return"><dt>Returns</dt><dd>the current value of this geometry. </dd></dl>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>include/cugl/math/<a class="el" href="_c_u_geometry_8h_source.html">CUGeometry.h</a></li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.1
</small></address>
</body>
</html>
