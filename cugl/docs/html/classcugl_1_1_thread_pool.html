<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.9.1"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>CUGL 2.0: cugl::ThreadPool Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">CUGL 2.0
   </div>
   <div id="projectbrief">Cornell University Game Library</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.1 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search','.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespacecugl.html">cugl</a></li><li class="navelem"><a class="el" href="classcugl_1_1_thread_pool.html">ThreadPool</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-static-methods">Static Public Member Functions</a> &#124;
<a href="classcugl_1_1_thread_pool-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">cugl::ThreadPool Class Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p><code>#include &lt;<a class="el" href="_c_u_thread_pool_8h_source.html">CUThreadPool.h</a>&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a5f8b9a4cab509fb65e455b2501ed27ab"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1_thread_pool.html#a5f8b9a4cab509fb65e455b2501ed27ab">ThreadPool</a> ()</td></tr>
<tr class="separator:a5f8b9a4cab509fb65e455b2501ed27ab"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7406308f2dd0168572132829e2ac3675"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1_thread_pool.html#a7406308f2dd0168572132829e2ac3675">~ThreadPool</a> ()</td></tr>
<tr class="separator:a7406308f2dd0168572132829e2ac3675"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad2ef932258ded872d4a4ed751e3d45c6"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1_thread_pool.html#ad2ef932258ded872d4a4ed751e3d45c6">dispose</a> ()</td></tr>
<tr class="separator:ad2ef932258ded872d4a4ed751e3d45c6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6eb1e8bf0a774f357721c01ce41b98ae"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1_thread_pool.html#a6eb1e8bf0a774f357721c01ce41b98ae">init</a> (int threads=4)</td></tr>
<tr class="separator:a6eb1e8bf0a774f357721c01ce41b98ae"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8fb5f532d56267a603fb54801993c3fc"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1_thread_pool.html#a8fb5f532d56267a603fb54801993c3fc">addTask</a> (const std::function&lt; void()&gt; &amp;task)</td></tr>
<tr class="separator:a8fb5f532d56267a603fb54801993c3fc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af746823377159352915c8955a9eff26e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1_thread_pool.html#af746823377159352915c8955a9eff26e">stop</a> ()</td></tr>
<tr class="separator:af746823377159352915c8955a9eff26e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a24201d25dd2a1e6b44099b19d97f2989"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1_thread_pool.html#a24201d25dd2a1e6b44099b19d97f2989">isStopped</a> () const</td></tr>
<tr class="separator:a24201d25dd2a1e6b44099b19d97f2989"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1ed5d6b6695114567266e1bc4f47a748"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1_thread_pool.html#a1ed5d6b6695114567266e1bc4f47a748">isShutdown</a> () const</td></tr>
<tr class="separator:a1ed5d6b6695114567266e1bc4f47a748"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-static-methods"></a>
Static Public Member Functions</h2></td></tr>
<tr class="memitem:ac164df51b5d00f9c360e4c867958035d"><td class="memItemLeft" align="right" valign="top">static std::shared_ptr&lt; <a class="el" href="classcugl_1_1_thread_pool.html">ThreadPool</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1_thread_pool.html#ac164df51b5d00f9c360e4c867958035d">alloc</a> (int threads=4)</td></tr>
<tr class="separator:ac164df51b5d00f9c360e4c867958035d"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Class to providing a collection of worker threads.</p>
<p>This is a general purpose class for performing tasks asynchronously. There is no notification process for when a task is complete. Instead, your task should either set a flag, or execute a callback when it is done.</p>
<p>There are some important safety considerations for using this class over direct thread objects. For example, stopping a thread pool does not shut it down immediately; it just marks it for shutdown. Because of mutex locks, it is not safe to delete a thread pool until it is completely shutdown.</p>
<p>More importantly, we do not allow for detached threads. This makes no sense in this application, because the threads share a resource (_taskQueue) with the main thread that will be deleted. It is therefore unsafe for the threads to ever detach.</p>
<p>See the class <a class="el" href="classcugl_1_1_asset_manager.html">AssetManager</a> for an example of how to use a thread pool. </p>
</div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="a5f8b9a4cab509fb65e455b2501ed27ab"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5f8b9a4cab509fb65e455b2501ed27ab">&#9670;&nbsp;</a></span>ThreadPool()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">cugl::ThreadPool::ThreadPool </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Creates a thread pool with no active threads.</p>
<p>You must initialize this thread pool before use.</p>
<p>NEVER USE A CONSTRUCTOR WITH NEW. If you want to allocate a thread pool on the heap, use one of the static constructors instead. </p>

</div>
</div>
<a id="a7406308f2dd0168572132829e2ac3675"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7406308f2dd0168572132829e2ac3675">&#9670;&nbsp;</a></span>~ThreadPool()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">cugl::ThreadPool::~ThreadPool </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Deletes this thread pool, destroying all resources.</p>
<p>It is a bad idea to destroy the thread pool if the pool is not yet shut down. The task queue is shared by the child threads, so we cannot delete it until all the threads complete. This destructor will block unti showndown. </p>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="a8fb5f532d56267a603fb54801993c3fc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8fb5f532d56267a603fb54801993c3fc">&#9670;&nbsp;</a></span>addTask()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void cugl::ThreadPool::addTask </td>
          <td>(</td>
          <td class="paramtype">const std::function&lt; void()&gt; &amp;&#160;</td>
          <td class="paramname"><em>task</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Adds a task to the thread pool.</p>
<p>A task is a void returning function with no parameters. If you need state in the task, you should use a method call for the state. The task will not be executed immediately, but must wait for the first available worker.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">task</td><td>the task function to add to the thread pool </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ac164df51b5d00f9c360e4c867958035d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac164df51b5d00f9c360e4c867958035d">&#9670;&nbsp;</a></span>alloc()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static std::shared_ptr&lt;<a class="el" href="classcugl_1_1_thread_pool.html">ThreadPool</a>&gt; cugl::ThreadPool::alloc </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>threads</em> = <code>4</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns a newly allocated thread pool with the given number of threads.</p>
<p>You can specify the number of simultaneous worker threads. We find that 4 is generally a good number, even if you have a lot of tasks. Much more than the number of cores on a machine is counter-productive.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">threads</td><td>the number of threads in this pool</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a newly allocated thread pool with the given number of threads. </dd></dl>

</div>
</div>
<a id="ad2ef932258ded872d4a4ed751e3d45c6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad2ef932258ded872d4a4ed751e3d45c6">&#9670;&nbsp;</a></span>dispose()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void cugl::ThreadPool::dispose </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Disposes this thread pool, releasing all memory.</p>
<p>A disposed thread pool can be safely reinitialized. However, it is a bad idea to destroy the thread pool if the pool is not yet shut down. The task queue is shared by the child threads, so we cannot delete it until all the threads complete. This destructor will block unti showndown. </p>

</div>
</div>
<a id="a6eb1e8bf0a774f357721c01ce41b98ae"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6eb1e8bf0a774f357721c01ce41b98ae">&#9670;&nbsp;</a></span>init()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool cugl::ThreadPool::init </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>threads</em> = <code>4</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Initializes a thread pool with the given number of threads.</p>
<p>You can specify the number of simultaneous worker threads. We find that 4 is generally a good number, even if you have a lot of tasks. Much more than the number of cores on a machine is counter-productive.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">threads</td><td>the number of threads in this pool</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if the threed pool is initialized properly, false otherwise. </dd></dl>

</div>
</div>
<a id="a1ed5d6b6695114567266e1bc4f47a748"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1ed5d6b6695114567266e1bc4f47a748">&#9670;&nbsp;</a></span>isShutdown()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool cugl::ThreadPool::isShutdown </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns whether the thread pool has been shut down.</p>
<p>A shut down thread pool has no active threads and is safe for deletion.</p>
<dl class="section return"><dt>Returns</dt><dd>whether the thread pool has been shut down. </dd></dl>

</div>
</div>
<a id="a24201d25dd2a1e6b44099b19d97f2989"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a24201d25dd2a1e6b44099b19d97f2989">&#9670;&nbsp;</a></span>isStopped()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool cugl::ThreadPool::isStopped </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns whether the thread pool has been stopped.</p>
<p>A stopped thread pool is marked for shutdown, but it shutdown has not necessarily completed. Shutdown will be complete when the current child threads have finished with their tasks.</p>
<dl class="section return"><dt>Returns</dt><dd>whether the thread pool has been stopped. </dd></dl>

</div>
</div>
<a id="af746823377159352915c8955a9eff26e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af746823377159352915c8955a9eff26e">&#9670;&nbsp;</a></span>stop()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void cugl::ThreadPool::stop </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Stop the thread pool, marking it for shut down.</p>
<p>A stopped thread pool is marked for shutdown, but it shutdown has not necessarily completed. Shutdown will be complete when the current child threads have finished with their tasks. </p>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>include/cugl/util/<a class="el" href="_c_u_thread_pool_8h_source.html">CUThreadPool.h</a></li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.1
</small></address>
</body>
</html>
