<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.9.1"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>CUGL 2.0: cugl::PolyFactory Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">CUGL 2.0
   </div>
   <div id="projectbrief">Cornell University Game Library</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.1 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search','.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespacecugl.html">cugl</a></li><li class="navelem"><a class="el" href="classcugl_1_1_poly_factory.html">PolyFactory</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="classcugl_1_1_poly_factory-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">cugl::PolyFactory Class Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p><code>#include &lt;<a class="el" href="_c_u_poly_factory_8h_source.html">CUPolyFactory.h</a>&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:aed8d7542ada07b78dee41820eafbaa69"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1_poly_factory.html#aed8d7542ada07b78dee41820eafbaa69">PolyFactory</a> ()</td></tr>
<tr class="separator:aed8d7542ada07b78dee41820eafbaa69"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a31eac43e47a976c914586cf24713df58"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1_poly_factory.html#a31eac43e47a976c914586cf24713df58">PolyFactory</a> (<a class="el" href="classcugl_1_1_geometry.html">Geometry</a> geom)</td></tr>
<tr class="separator:a31eac43e47a976c914586cf24713df58"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afb48c809e3197ea76068b8b4815e2553"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classcugl_1_1_geometry.html">Geometry</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1_poly_factory.html#afb48c809e3197ea76068b8b4815e2553">getGeometry</a> () const</td></tr>
<tr class="separator:afb48c809e3197ea76068b8b4815e2553"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adce374f6fcdf881d0fef05070014fd06"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1_poly_factory.html#adce374f6fcdf881d0fef05070014fd06">setGeometry</a> (<a class="el" href="classcugl_1_1_geometry.html">Geometry</a> geom)</td></tr>
<tr class="separator:adce374f6fcdf881d0fef05070014fd06"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3063d8ecc9c04f9f3085075cd515803b"><td class="memItemLeft" align="right" valign="top">Uint32&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1_poly_factory.html#a3063d8ecc9c04f9f3085075cd515803b">getSegments</a> () const</td></tr>
<tr class="separator:a3063d8ecc9c04f9f3085075cd515803b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0935480a336517a12e42b9bb67a8c470"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1_poly_factory.html#a0935480a336517a12e42b9bb67a8c470">setSegments</a> (int segments)</td></tr>
<tr class="separator:a0935480a336517a12e42b9bb67a8c470"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1da11d2787a2c47eced278cc6db95666"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classcugl_1_1_poly2.html">Poly2</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1_poly_factory.html#a1da11d2787a2c47eced278cc6db95666">makeLine</a> (const <a class="el" href="classcugl_1_1_vec2.html">Vec2</a> origin, const <a class="el" href="classcugl_1_1_vec2.html">Vec2</a> dest) const</td></tr>
<tr class="separator:a1da11d2787a2c47eced278cc6db95666"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a86b8df3ff9187e5544b30356ec6dac1d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classcugl_1_1_poly2.html">Poly2</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1_poly_factory.html#a86b8df3ff9187e5544b30356ec6dac1d">makeLine</a> (float ox, float oy, float dx, float dy) const</td></tr>
<tr class="separator:a86b8df3ff9187e5544b30356ec6dac1d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aafe66d98482e611ca305a3bae319b967"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classcugl_1_1_poly2.html">Poly2</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1_poly_factory.html#aafe66d98482e611ca305a3bae319b967">makeLine</a> (<a class="el" href="classcugl_1_1_poly2.html">Poly2</a> *poly, const <a class="el" href="classcugl_1_1_vec2.html">Vec2</a> origin, const <a class="el" href="classcugl_1_1_vec2.html">Vec2</a> dest) const</td></tr>
<tr class="separator:aafe66d98482e611ca305a3bae319b967"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6701a7cc34104b6fd225ef8c187fb6b5"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classcugl_1_1_poly2.html">Poly2</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1_poly_factory.html#a6701a7cc34104b6fd225ef8c187fb6b5">makeLine</a> (<a class="el" href="classcugl_1_1_poly2.html">Poly2</a> *poly, float ox, float oy, float dx, float dy) const</td></tr>
<tr class="separator:a6701a7cc34104b6fd225ef8c187fb6b5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a71f9a9380bbc76d025315d47fcb1a5c3"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classcugl_1_1_poly2.html">Poly2</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1_poly_factory.html#a71f9a9380bbc76d025315d47fcb1a5c3">makeTraversal</a> (const <a class="el" href="classcugl_1_1_poly2.html">Poly2</a> &amp;src, <a class="el" href="namespacecugl_1_1poly2.html#a7085f690f432be28cf5d5f74ee7a550b">poly2::Traversal</a> type) const</td></tr>
<tr class="separator:a71f9a9380bbc76d025315d47fcb1a5c3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4800f9dc339ade096a658c275e23f1fe"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classcugl_1_1_poly2.html">Poly2</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1_poly_factory.html#a4800f9dc339ade096a658c275e23f1fe">makeTraversal</a> (<a class="el" href="classcugl_1_1_poly2.html">Poly2</a> *poly, const <a class="el" href="classcugl_1_1_poly2.html">Poly2</a> &amp;src, <a class="el" href="namespacecugl_1_1poly2.html#a7085f690f432be28cf5d5f74ee7a550b">poly2::Traversal</a> type) const</td></tr>
<tr class="separator:a4800f9dc339ade096a658c275e23f1fe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae6f6c98ca325474a1f3bd3961daa6bbc"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classcugl_1_1_poly2.html">Poly2</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1_poly_factory.html#ae6f6c98ca325474a1f3bd3961daa6bbc">makeTriangle</a> (const <a class="el" href="classcugl_1_1_vec2.html">Vec2</a> a, const <a class="el" href="classcugl_1_1_vec2.html">Vec2</a> b, const <a class="el" href="classcugl_1_1_vec2.html">Vec2</a> c) const</td></tr>
<tr class="separator:ae6f6c98ca325474a1f3bd3961daa6bbc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aff01208b1234556eb6b1ca14aad00765"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classcugl_1_1_poly2.html">Poly2</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1_poly_factory.html#aff01208b1234556eb6b1ca14aad00765">makeTriangle</a> (float ax, float ay, float bx, float by, float cx, float cy) const</td></tr>
<tr class="separator:aff01208b1234556eb6b1ca14aad00765"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a74839238c139a3d1bbdc2cc1d9325b51"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classcugl_1_1_poly2.html">Poly2</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1_poly_factory.html#a74839238c139a3d1bbdc2cc1d9325b51">makeTriangle</a> (<a class="el" href="classcugl_1_1_poly2.html">Poly2</a> *poly, const <a class="el" href="classcugl_1_1_vec2.html">Vec2</a> a, const <a class="el" href="classcugl_1_1_vec2.html">Vec2</a> b, const <a class="el" href="classcugl_1_1_vec2.html">Vec2</a> c) const</td></tr>
<tr class="separator:a74839238c139a3d1bbdc2cc1d9325b51"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a930eeeedbc34af7dba06d89e93a52f00"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classcugl_1_1_poly2.html">Poly2</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1_poly_factory.html#a930eeeedbc34af7dba06d89e93a52f00">makeTriangle</a> (<a class="el" href="classcugl_1_1_poly2.html">Poly2</a> *poly, float ax, float ay, float bx, float by, float cx, float cy) const</td></tr>
<tr class="separator:a930eeeedbc34af7dba06d89e93a52f00"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac16797d2f49182326868d52a544da793"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classcugl_1_1_poly2.html">Poly2</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1_poly_factory.html#ac16797d2f49182326868d52a544da793">makeRect</a> (const <a class="el" href="classcugl_1_1_vec2.html">Vec2</a> origin, const <a class="el" href="classcugl_1_1_vec2.html">Vec2</a> size) const</td></tr>
<tr class="separator:ac16797d2f49182326868d52a544da793"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa2a9a6916795accf5e95e736c521aa24"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classcugl_1_1_poly2.html">Poly2</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1_poly_factory.html#aa2a9a6916795accf5e95e736c521aa24">makeRect</a> (const <a class="el" href="classcugl_1_1_rect.html">Rect</a> rect) const</td></tr>
<tr class="separator:aa2a9a6916795accf5e95e736c521aa24"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6034ae57f1c22bdff7eade572426c6d8"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classcugl_1_1_poly2.html">Poly2</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1_poly_factory.html#a6034ae57f1c22bdff7eade572426c6d8">makeRect</a> (float x, float y, float w, float h) const</td></tr>
<tr class="separator:a6034ae57f1c22bdff7eade572426c6d8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a954d21b9356b12af452cc28c48cfc0b3"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classcugl_1_1_poly2.html">Poly2</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1_poly_factory.html#a954d21b9356b12af452cc28c48cfc0b3">makeRect</a> (<a class="el" href="classcugl_1_1_poly2.html">Poly2</a> *poly, const <a class="el" href="classcugl_1_1_vec2.html">Vec2</a> origin, const <a class="el" href="classcugl_1_1_vec2.html">Vec2</a> size) const</td></tr>
<tr class="separator:a954d21b9356b12af452cc28c48cfc0b3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac629b3e1ca38b516d06db5922765e3fa"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classcugl_1_1_poly2.html">Poly2</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1_poly_factory.html#ac629b3e1ca38b516d06db5922765e3fa">makeRect</a> (<a class="el" href="classcugl_1_1_poly2.html">Poly2</a> *poly, const <a class="el" href="classcugl_1_1_rect.html">Rect</a> rect) const</td></tr>
<tr class="separator:ac629b3e1ca38b516d06db5922765e3fa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab2ebf8f09da1c0135580631583c1f53e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classcugl_1_1_poly2.html">Poly2</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1_poly_factory.html#ab2ebf8f09da1c0135580631583c1f53e">makeRect</a> (<a class="el" href="classcugl_1_1_poly2.html">Poly2</a> *poly, float x, float y, float w, float h) const</td></tr>
<tr class="separator:ab2ebf8f09da1c0135580631583c1f53e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8eaae575a4d94f50c83ac110c742c505"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classcugl_1_1_poly2.html">Poly2</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1_poly_factory.html#a8eaae575a4d94f50c83ac110c742c505">makeEllipse</a> (const <a class="el" href="classcugl_1_1_vec2.html">Vec2</a> center, const <a class="el" href="classcugl_1_1_vec2.html">Vec2</a> size) const</td></tr>
<tr class="separator:a8eaae575a4d94f50c83ac110c742c505"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a469d6d81c79daaca181573185f2325f8"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classcugl_1_1_poly2.html">Poly2</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1_poly_factory.html#a469d6d81c79daaca181573185f2325f8">makeEllipse</a> (float cx, float cy, float sx, float sy) const</td></tr>
<tr class="separator:a469d6d81c79daaca181573185f2325f8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac987122377b5469ac60ec9db4b221a73"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classcugl_1_1_poly2.html">Poly2</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1_poly_factory.html#ac987122377b5469ac60ec9db4b221a73">makeEllipse</a> (<a class="el" href="classcugl_1_1_poly2.html">Poly2</a> *poly, const <a class="el" href="classcugl_1_1_vec2.html">Vec2</a> center, const <a class="el" href="classcugl_1_1_vec2.html">Vec2</a> size) const</td></tr>
<tr class="separator:ac987122377b5469ac60ec9db4b221a73"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8c46739d5f89c4a96c63cc94431e1b39"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classcugl_1_1_poly2.html">Poly2</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1_poly_factory.html#a8c46739d5f89c4a96c63cc94431e1b39">makeEllipse</a> (<a class="el" href="classcugl_1_1_poly2.html">Poly2</a> *poly, float cx, float cy, float sx, float sy) const</td></tr>
<tr class="separator:a8c46739d5f89c4a96c63cc94431e1b39"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af1c537dc976993804670ea37c39172e2"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classcugl_1_1_poly2.html">Poly2</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1_poly_factory.html#af1c537dc976993804670ea37c39172e2">makeCircle</a> (const <a class="el" href="classcugl_1_1_vec2.html">Vec2</a> center, float radius) const</td></tr>
<tr class="separator:af1c537dc976993804670ea37c39172e2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2ba26b13cfd2727a416bc5a87774ae53"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classcugl_1_1_poly2.html">Poly2</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1_poly_factory.html#a2ba26b13cfd2727a416bc5a87774ae53">makeCircle</a> (float cx, float cy, float radius) const</td></tr>
<tr class="separator:a2ba26b13cfd2727a416bc5a87774ae53"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a54647c064a1bd0b29d13b21bb976f32d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classcugl_1_1_poly2.html">Poly2</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1_poly_factory.html#a54647c064a1bd0b29d13b21bb976f32d">makeCircle</a> (<a class="el" href="classcugl_1_1_poly2.html">Poly2</a> *poly, const <a class="el" href="classcugl_1_1_vec2.html">Vec2</a> center, float radius) const</td></tr>
<tr class="separator:a54647c064a1bd0b29d13b21bb976f32d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a79351ed5423aa4915292221dfd4a7012"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classcugl_1_1_poly2.html">Poly2</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1_poly_factory.html#a79351ed5423aa4915292221dfd4a7012">makeCircle</a> (<a class="el" href="classcugl_1_1_poly2.html">Poly2</a> *poly, float cx, float cy, float radius) const</td></tr>
<tr class="separator:a79351ed5423aa4915292221dfd4a7012"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae7f222a081401c48f3e92fa4a8704008"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classcugl_1_1_poly2.html">Poly2</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1_poly_factory.html#ae7f222a081401c48f3e92fa4a8704008">makeArc</a> (const <a class="el" href="classcugl_1_1_vec2.html">Vec2</a> center, float radius, float start, float degrees) const</td></tr>
<tr class="separator:ae7f222a081401c48f3e92fa4a8704008"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afc541b0820f1e278f88c2dbeed6e878b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classcugl_1_1_poly2.html">Poly2</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1_poly_factory.html#afc541b0820f1e278f88c2dbeed6e878b">makeArc</a> (float cx, float cy, float radius, float start, float degrees) const</td></tr>
<tr class="separator:afc541b0820f1e278f88c2dbeed6e878b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a64ff078598401ea0577f3448f9b61380"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classcugl_1_1_poly2.html">Poly2</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1_poly_factory.html#a64ff078598401ea0577f3448f9b61380">makeArc</a> (<a class="el" href="classcugl_1_1_poly2.html">Poly2</a> *poly, const <a class="el" href="classcugl_1_1_vec2.html">Vec2</a> center, float radius, float start, float degrees) const</td></tr>
<tr class="separator:a64ff078598401ea0577f3448f9b61380"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a793610cc257408c101d3f8a63357298b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classcugl_1_1_poly2.html">Poly2</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1_poly_factory.html#a793610cc257408c101d3f8a63357298b">makeArc</a> (<a class="el" href="classcugl_1_1_poly2.html">Poly2</a> *poly, float cx, float cy, float radius, float start, float degrees) const</td></tr>
<tr class="separator:a793610cc257408c101d3f8a63357298b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aec7cf770c905c240752d022d58961fd4"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classcugl_1_1_poly2.html">Poly2</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1_poly_factory.html#aec7cf770c905c240752d022d58961fd4">makeRoundedRect</a> (const <a class="el" href="classcugl_1_1_vec2.html">Vec2</a> origin, const <a class="el" href="classcugl_1_1_size.html">Size</a> size, float radius) const</td></tr>
<tr class="separator:aec7cf770c905c240752d022d58961fd4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8877304de54aba75b3936c61e4c72d08"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classcugl_1_1_poly2.html">Poly2</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1_poly_factory.html#a8877304de54aba75b3936c61e4c72d08">makeRoundedRect</a> (const <a class="el" href="classcugl_1_1_rect.html">Rect</a> rect, float radius) const</td></tr>
<tr class="separator:a8877304de54aba75b3936c61e4c72d08"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a00bdc6a2ba719591e74342dcb6168c5f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classcugl_1_1_poly2.html">Poly2</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1_poly_factory.html#a00bdc6a2ba719591e74342dcb6168c5f">makeRoundedRect</a> (float x, float y, float w, float h, float r) const</td></tr>
<tr class="separator:a00bdc6a2ba719591e74342dcb6168c5f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaac40ba1e18ddeb2fa5015074d09b3fb"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classcugl_1_1_poly2.html">Poly2</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1_poly_factory.html#aaac40ba1e18ddeb2fa5015074d09b3fb">makeRoundedRect</a> (<a class="el" href="classcugl_1_1_poly2.html">Poly2</a> *poly, const <a class="el" href="classcugl_1_1_vec2.html">Vec2</a> origin, const <a class="el" href="classcugl_1_1_size.html">Size</a> size, float radius) const</td></tr>
<tr class="separator:aaac40ba1e18ddeb2fa5015074d09b3fb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a11661e624b9c51bdf90bed62a622040c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classcugl_1_1_poly2.html">Poly2</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1_poly_factory.html#a11661e624b9c51bdf90bed62a622040c">makeRoundedRect</a> (<a class="el" href="classcugl_1_1_poly2.html">Poly2</a> *poly, const <a class="el" href="classcugl_1_1_rect.html">Rect</a> rect, float radius) const</td></tr>
<tr class="separator:a11661e624b9c51bdf90bed62a622040c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4d22db162443ec4e223261e3a8c83461"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classcugl_1_1_poly2.html">Poly2</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1_poly_factory.html#a4d22db162443ec4e223261e3a8c83461">makeRoundedRect</a> (<a class="el" href="classcugl_1_1_poly2.html">Poly2</a> *poly, float x, float y, float w, float h, float r) const</td></tr>
<tr class="separator:a4d22db162443ec4e223261e3a8c83461"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a154cfeccf6afd5fa4bd0de71f49d3b9a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classcugl_1_1_poly2.html">Poly2</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1_poly_factory.html#a154cfeccf6afd5fa4bd0de71f49d3b9a">makeCapsule</a> (const <a class="el" href="classcugl_1_1_vec2.html">Vec2</a> origin, const <a class="el" href="classcugl_1_1_size.html">Size</a> size) const</td></tr>
<tr class="separator:a154cfeccf6afd5fa4bd0de71f49d3b9a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adf41b08fa0ce63c6d0b0043d82bee570"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classcugl_1_1_poly2.html">Poly2</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1_poly_factory.html#adf41b08fa0ce63c6d0b0043d82bee570">makeCapsule</a> (const <a class="el" href="classcugl_1_1_rect.html">Rect</a> rect) const</td></tr>
<tr class="separator:adf41b08fa0ce63c6d0b0043d82bee570"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af21132a784497aa56d4099fad91295a3"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classcugl_1_1_poly2.html">Poly2</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1_poly_factory.html#af21132a784497aa56d4099fad91295a3">makeCapsule</a> (float x, float y, float w, float h) const</td></tr>
<tr class="separator:af21132a784497aa56d4099fad91295a3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3ef901db8ef5753a9e345ec39d039129"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classcugl_1_1_poly2.html">Poly2</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1_poly_factory.html#a3ef901db8ef5753a9e345ec39d039129">makeCapsule</a> (<a class="el" href="classcugl_1_1_poly2.html">Poly2</a> *poly, const <a class="el" href="classcugl_1_1_vec2.html">Vec2</a> origin, const <a class="el" href="classcugl_1_1_size.html">Size</a> size) const</td></tr>
<tr class="separator:a3ef901db8ef5753a9e345ec39d039129"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5ecd549028ba3cdc29d34df686975cb4"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classcugl_1_1_poly2.html">Poly2</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1_poly_factory.html#a5ecd549028ba3cdc29d34df686975cb4">makeCapsule</a> (<a class="el" href="classcugl_1_1_poly2.html">Poly2</a> *poly, const <a class="el" href="classcugl_1_1_rect.html">Rect</a> rect) const</td></tr>
<tr class="separator:a5ecd549028ba3cdc29d34df686975cb4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa8d59448b55c198ac337c4046d2ca38c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classcugl_1_1_poly2.html">Poly2</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1_poly_factory.html#aa8d59448b55c198ac337c4046d2ca38c">makeCapsule</a> (<a class="el" href="classcugl_1_1_poly2.html">Poly2</a> *poly, float x, float y, float w, float h) const</td></tr>
<tr class="separator:aa8d59448b55c198ac337c4046d2ca38c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afc0d7bf5e46d7fd530322ffc3bc2bb81"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classcugl_1_1_poly2.html">Poly2</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1_poly_factory.html#afc0d7bf5e46d7fd530322ffc3bc2bb81">makeCapsule</a> (<a class="el" href="namespacecugl_1_1poly2.html#a78fc88b110befd9afbf1d17aabdebfe3">poly2::Capsule</a> shape, const <a class="el" href="classcugl_1_1_vec2.html">Vec2</a> origin, const <a class="el" href="classcugl_1_1_size.html">Size</a> size) const</td></tr>
<tr class="separator:afc0d7bf5e46d7fd530322ffc3bc2bb81"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a315462d0bbbd7096af4f61d500681cf6"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classcugl_1_1_poly2.html">Poly2</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1_poly_factory.html#a315462d0bbbd7096af4f61d500681cf6">makeCapsule</a> (<a class="el" href="namespacecugl_1_1poly2.html#a78fc88b110befd9afbf1d17aabdebfe3">poly2::Capsule</a> shape, const <a class="el" href="classcugl_1_1_rect.html">Rect</a> rect) const</td></tr>
<tr class="separator:a315462d0bbbd7096af4f61d500681cf6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a44b7ed18c003997fa75d2ef6c62dd546"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classcugl_1_1_poly2.html">Poly2</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1_poly_factory.html#a44b7ed18c003997fa75d2ef6c62dd546">makeCapsule</a> (<a class="el" href="namespacecugl_1_1poly2.html#a78fc88b110befd9afbf1d17aabdebfe3">poly2::Capsule</a> shape, float x, float y, float w, float h) const</td></tr>
<tr class="separator:a44b7ed18c003997fa75d2ef6c62dd546"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a49ee66773fdffba432821b78cce46399"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classcugl_1_1_poly2.html">Poly2</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1_poly_factory.html#a49ee66773fdffba432821b78cce46399">makeCapsule</a> (<a class="el" href="classcugl_1_1_poly2.html">Poly2</a> *poly, <a class="el" href="namespacecugl_1_1poly2.html#a78fc88b110befd9afbf1d17aabdebfe3">poly2::Capsule</a> shape, const <a class="el" href="classcugl_1_1_vec2.html">Vec2</a> origin, const <a class="el" href="classcugl_1_1_size.html">Size</a> size) const</td></tr>
<tr class="separator:a49ee66773fdffba432821b78cce46399"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a305f6ba11ec073e93153923e2076eb45"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classcugl_1_1_poly2.html">Poly2</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1_poly_factory.html#a305f6ba11ec073e93153923e2076eb45">makeCapsule</a> (<a class="el" href="classcugl_1_1_poly2.html">Poly2</a> *poly, <a class="el" href="namespacecugl_1_1poly2.html#a78fc88b110befd9afbf1d17aabdebfe3">poly2::Capsule</a> shape, const <a class="el" href="classcugl_1_1_rect.html">Rect</a> rect) const</td></tr>
<tr class="separator:a305f6ba11ec073e93153923e2076eb45"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa85081159acaa687bec21bcf9f493ca0"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classcugl_1_1_poly2.html">Poly2</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1_poly_factory.html#aa85081159acaa687bec21bcf9f493ca0">makeCapsule</a> (<a class="el" href="classcugl_1_1_poly2.html">Poly2</a> *poly, <a class="el" href="namespacecugl_1_1poly2.html#a78fc88b110befd9afbf1d17aabdebfe3">poly2::Capsule</a> shape, float x, float y, float w, float h) const</td></tr>
<tr class="separator:aa85081159acaa687bec21bcf9f493ca0"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>This class is a factory for generating common <a class="el" href="classcugl_1_1_poly2.html">Poly2</a> objects.</p>
<p>Most of the time that we create a polygon, we are using it to approximate a common shape, like a circle, or a rounded rectangle. Instead of embedding all of this functionality into <a class="el" href="classcugl_1_1_poly2.html">Poly2</a> (which already has enough to do on its own), we have factored this out into a a separate factory class. This factory can generate new polygons or reset existing ones (conserving memory).</p>
<p>This factory is much lighter weight than the triangulation or extrusion factories. In this factory, the calculation step and the materialization step are one in the same. That is because the calculations are short and do not need to be refactored for multithread calculation. Indeed, the only reason this factory is not a collection of simple functions is because that we have have some settings (like precision and geometry) that we want to set separately. </p>
</div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="aed8d7542ada07b78dee41820eafbaa69"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aed8d7542ada07b78dee41820eafbaa69">&#9670;&nbsp;</a></span>PolyFactory() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">cugl::PolyFactory::PolyFactory </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Creates a <a class="el" href="classcugl_1_1_poly_factory.html">PolyFactory</a> for generating <a class="el" href="classcugl_1_1_geometry.html#a5ad34fdd33aa23ffc0c374bf6f2d11b5ac6969385269556756b005c22b71a6e44">Geometry#SOLID</a> shapes </p>

</div>
</div>
<a id="a31eac43e47a976c914586cf24713df58"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a31eac43e47a976c914586cf24713df58">&#9670;&nbsp;</a></span>PolyFactory() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">cugl::PolyFactory::PolyFactory </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classcugl_1_1_geometry.html">Geometry</a>&#160;</td>
          <td class="paramname"><em>geom</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Creates a <a class="el" href="classcugl_1_1_poly_factory.html">PolyFactory</a> for generating shapes of the given geometry.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">geom</td><td>The geometry to use when generating shapes </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="afb48c809e3197ea76068b8b4815e2553"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afb48c809e3197ea76068b8b4815e2553">&#9670;&nbsp;</a></span>getGeometry()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcugl_1_1_geometry.html">Geometry</a> cugl::PolyFactory::getGeometry </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns the current drawing geometry of this factory.</p>
<p>All shapes created by this factory will have the given geometry until it is set to be otherwise.</p>
<dl class="section return"><dt>Returns</dt><dd>the current drawing geometry of this factory. </dd></dl>

</div>
</div>
<a id="a3063d8ecc9c04f9f3085075cd515803b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3063d8ecc9c04f9f3085075cd515803b">&#9670;&nbsp;</a></span>getSegments()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Uint32 cugl::PolyFactory::getSegments </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns the number of segments to be used for rounded shapes.</p>
<p>Rounded shapes include <a class="el" href="classcugl_1_1_poly_factory.html#a8eaae575a4d94f50c83ac110c742c505">makeEllipse</a>, <a class="el" href="classcugl_1_1_poly_factory.html#af1c537dc976993804670ea37c39172e2">makeCircle</a>, <a class="el" href="classcugl_1_1_poly_factory.html#ae7f222a081401c48f3e92fa4a8704008">makeArc</a>, and <a class="el" href="classcugl_1_1_poly_factory.html#aec7cf770c905c240752d022d58961fd4">makeRoundedRect</a>.</p>
<dl class="section return"><dt>Returns</dt><dd>the number of segments to be used for rounded shapes. </dd></dl>

</div>
</div>
<a id="ae7f222a081401c48f3e92fa4a8704008"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae7f222a081401c48f3e92fa4a8704008">&#9670;&nbsp;</a></span>makeArc() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcugl_1_1_poly2.html">Poly2</a> cugl::PolyFactory::makeArc </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classcugl_1_1_vec2.html">Vec2</a>&#160;</td>
          <td class="paramname"><em>center</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>radius</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>start</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>degrees</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns a polygon that represents an arc of the given dimensions.</p>
<p>The polygon will be generated by the current geometry. Use <a class="el" href="classcugl_1_1_geometry.html#a5ad34fdd33aa23ffc0c374bf6f2d11b5ac6969385269556756b005c22b71a6e44">Geometry#SOLID</a> for a solid arc and <a class="el" href="classcugl_1_1_geometry.html#a5ad34fdd33aa23ffc0c374bf6f2d11b5ab950bc5b35fc0869f451794889838a4b">Geometry#PATH</a> for an outline. Other geometries are supported as well, if necessary. All arc measurements are in degrees, not radians.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">center</td><td>The arc center point (of the defining circle </td></tr>
    <tr><td class="paramname">radius</td><td>The radius from the center point </td></tr>
    <tr><td class="paramname">start</td><td>The starting angle in degrees </td></tr>
    <tr><td class="paramname">degrees</td><td>The number of degrees to generate</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a polygon that represents an arc of the given dimensions. </dd></dl>

</div>
</div>
<a id="afc541b0820f1e278f88c2dbeed6e878b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afc541b0820f1e278f88c2dbeed6e878b">&#9670;&nbsp;</a></span>makeArc() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcugl_1_1_poly2.html">Poly2</a> cugl::PolyFactory::makeArc </td>
          <td>(</td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>cx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>cy</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>radius</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>start</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>degrees</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns a polygon that represents an arc of the given dimensions.</p>
<p>The polygon will be generated by the current geometry. Use <a class="el" href="classcugl_1_1_geometry.html#a5ad34fdd33aa23ffc0c374bf6f2d11b5ac6969385269556756b005c22b71a6e44">Geometry#SOLID</a> for a solid arc and <a class="el" href="classcugl_1_1_geometry.html#a5ad34fdd33aa23ffc0c374bf6f2d11b5ab950bc5b35fc0869f451794889838a4b">Geometry#PATH</a> for an outline. Other geometries are supported as well, if necessary. All arc measurements are in degrees, not radians.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">cx</td><td>The x-coordinate of the center point </td></tr>
    <tr><td class="paramname">cy</td><td>The y-coordinate of the center point </td></tr>
    <tr><td class="paramname">radius</td><td>The radius from the center point </td></tr>
    <tr><td class="paramname">start</td><td>The starting angle in degrees </td></tr>
    <tr><td class="paramname">degrees</td><td>The number of degrees to generate</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a polygon that represents an arc of the given dimensions. </dd></dl>

</div>
</div>
<a id="a64ff078598401ea0577f3448f9b61380"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a64ff078598401ea0577f3448f9b61380">&#9670;&nbsp;</a></span>makeArc() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcugl_1_1_poly2.html">Poly2</a>* cugl::PolyFactory::makeArc </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classcugl_1_1_poly2.html">Poly2</a> *&#160;</td>
          <td class="paramname"><em>poly</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classcugl_1_1_vec2.html">Vec2</a>&#160;</td>
          <td class="paramname"><em>center</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>radius</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>start</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>degrees</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Stores an arc in the provided buffer.</p>
<p>The polygon will be generated by the current geometry. Use <a class="el" href="classcugl_1_1_geometry.html#a5ad34fdd33aa23ffc0c374bf6f2d11b5ac6969385269556756b005c22b71a6e44">Geometry#SOLID</a> for a solid arc and <a class="el" href="classcugl_1_1_geometry.html#a5ad34fdd33aa23ffc0c374bf6f2d11b5ab950bc5b35fc0869f451794889838a4b">Geometry#PATH</a> for an outline. Other geometries are supported as well, if necessary. All arc measurements are in degrees, not radians.</p>
<p>The arc will be appended to the buffer. You should clear the buffer first if you do not want to preserve the original data.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">poly</td><td>The polygon to store the result </td></tr>
    <tr><td class="paramname">center</td><td>The arc center point (of the defining circle </td></tr>
    <tr><td class="paramname">radius</td><td>The radius from the center point </td></tr>
    <tr><td class="paramname">start</td><td>The starting angle in degrees </td></tr>
    <tr><td class="paramname">degrees</td><td>The number of degrees to generate</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a reference to the buffer for chaining. </dd></dl>

</div>
</div>
<a id="a793610cc257408c101d3f8a63357298b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a793610cc257408c101d3f8a63357298b">&#9670;&nbsp;</a></span>makeArc() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcugl_1_1_poly2.html">Poly2</a>* cugl::PolyFactory::makeArc </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classcugl_1_1_poly2.html">Poly2</a> *&#160;</td>
          <td class="paramname"><em>poly</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>cx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>cy</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>radius</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>start</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>degrees</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Stores an arc in the provided buffer.</p>
<p>The polygon will be generated by the current geometry. Use <a class="el" href="classcugl_1_1_geometry.html#a5ad34fdd33aa23ffc0c374bf6f2d11b5ac6969385269556756b005c22b71a6e44">Geometry#SOLID</a> for a solid arc and <a class="el" href="classcugl_1_1_geometry.html#a5ad34fdd33aa23ffc0c374bf6f2d11b5ab950bc5b35fc0869f451794889838a4b">Geometry#PATH</a> for an outline. Other geometries are supported as well, if necessary. All arc measurements are in degrees, not radians.</p>
<p>The arc will be appended to the buffer. You should clear the buffer first if you do not want to preserve the original data.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">poly</td><td>The polygon to store the result </td></tr>
    <tr><td class="paramname">cx</td><td>The x-coordinate of the center point </td></tr>
    <tr><td class="paramname">cy</td><td>The y-coordinate of the center point </td></tr>
    <tr><td class="paramname">radius</td><td>The radius from the center point </td></tr>
    <tr><td class="paramname">start</td><td>The starting angle in degrees </td></tr>
    <tr><td class="paramname">degrees</td><td>The number of degrees to generate</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a reference to the buffer for chaining. </dd></dl>

</div>
</div>
<a id="adf41b08fa0ce63c6d0b0043d82bee570"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adf41b08fa0ce63c6d0b0043d82bee570">&#9670;&nbsp;</a></span>makeCapsule() <span class="overload">[1/12]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcugl_1_1_poly2.html">Poly2</a> cugl::PolyFactory::makeCapsule </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classcugl_1_1_rect.html">Rect</a>&#160;</td>
          <td class="paramname"><em>rect</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns a polygon that represents a (full) capsule of the given dimensions.</p>
<p>A capsule is a pill-like shape that fits inside of given rectangle. If width &lt; height, the capsule will be oriented vertically with the rounded portions at the top and bottom. Otherwise it will be oriented horizontally.</p>
<p>The polygon will be generated by the current geometry. Use <a class="el" href="classcugl_1_1_geometry.html#a5ad34fdd33aa23ffc0c374bf6f2d11b5ac6969385269556756b005c22b71a6e44">Geometry#SOLID</a> for a solid arc and <a class="el" href="classcugl_1_1_geometry.html#a5ad34fdd33aa23ffc0c374bf6f2d11b5ab950bc5b35fc0869f451794889838a4b">Geometry#PATH</a> for an outline. Other geometries are supported as well, if necessary.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">rect</td><td>The enclosing rectangle</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a polygon that represents a (full) capsule of the given dimensions. </dd></dl>

</div>
</div>
<a id="a154cfeccf6afd5fa4bd0de71f49d3b9a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a154cfeccf6afd5fa4bd0de71f49d3b9a">&#9670;&nbsp;</a></span>makeCapsule() <span class="overload">[2/12]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcugl_1_1_poly2.html">Poly2</a> cugl::PolyFactory::makeCapsule </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classcugl_1_1_vec2.html">Vec2</a>&#160;</td>
          <td class="paramname"><em>origin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classcugl_1_1_size.html">Size</a>&#160;</td>
          <td class="paramname"><em>size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns a polygon that represents a (full) capsule of the given dimensions.</p>
<p>A capsule is a pill-like shape that fits inside of given rectangle. If width &lt; height, the capsule will be oriented vertically with the rounded portions at the top and bottom. Otherwise it will be oriented horizontally.</p>
<p>The polygon will be generated by the current geometry. Use <a class="el" href="classcugl_1_1_geometry.html#a5ad34fdd33aa23ffc0c374bf6f2d11b5ac6969385269556756b005c22b71a6e44">Geometry#SOLID</a> for a solid arc and <a class="el" href="classcugl_1_1_geometry.html#a5ad34fdd33aa23ffc0c374bf6f2d11b5ab950bc5b35fc0869f451794889838a4b">Geometry#PATH</a> for an outline. Other geometries are supported as well, if necessary.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">origin</td><td>The enclosing rectangle origin </td></tr>
    <tr><td class="paramname">size</td><td>The enclosing rectangle size</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a polygon that represents a (full) capsule of the given dimensions. </dd></dl>

</div>
</div>
<a id="af21132a784497aa56d4099fad91295a3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af21132a784497aa56d4099fad91295a3">&#9670;&nbsp;</a></span>makeCapsule() <span class="overload">[3/12]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcugl_1_1_poly2.html">Poly2</a> cugl::PolyFactory::makeCapsule </td>
          <td>(</td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>w</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>h</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns a polygon that represents a (full) capsule of the given dimensions.</p>
<p>A capsule is a pill-like shape that fits inside of given rectangle. If width &lt; height, the capsule will be oriented vertically with the rounded portions at the top and bottom. Otherwise it will be oriented horizontally.</p>
<p>The polygon will be generated by the current geometry. Use <a class="el" href="classcugl_1_1_geometry.html#a5ad34fdd33aa23ffc0c374bf6f2d11b5ac6969385269556756b005c22b71a6e44">Geometry#SOLID</a> for a solid arc and <a class="el" href="classcugl_1_1_geometry.html#a5ad34fdd33aa23ffc0c374bf6f2d11b5ab950bc5b35fc0869f451794889838a4b">Geometry#PATH</a> for an outline. Other geometries are supported as well, if necessary.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>The x-coordinate of the bottom left corner of the bounding box </td></tr>
    <tr><td class="paramname">y</td><td>The y-coordinate of the bottom left corner of the bounding box </td></tr>
    <tr><td class="paramname">w</td><td>The capsule width </td></tr>
    <tr><td class="paramname">h</td><td>The capsule height</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a polygon that represents a (full) capsule of the given dimensions. </dd></dl>

</div>
</div>
<a id="a5ecd549028ba3cdc29d34df686975cb4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5ecd549028ba3cdc29d34df686975cb4">&#9670;&nbsp;</a></span>makeCapsule() <span class="overload">[4/12]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcugl_1_1_poly2.html">Poly2</a>* cugl::PolyFactory::makeCapsule </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classcugl_1_1_poly2.html">Poly2</a> *&#160;</td>
          <td class="paramname"><em>poly</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classcugl_1_1_rect.html">Rect</a>&#160;</td>
          <td class="paramname"><em>rect</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Stores a (full) capsule in the provided buffer.</p>
<p>A capsule is a pill-like shape that fits inside of given rectangle. If width &lt; height, the capsule will be oriented vertically with the rounded portions at the top and bottom. Otherwise it will be oriented horizontally.</p>
<p>The polygon will be generated by the current geometry. Use <a class="el" href="classcugl_1_1_geometry.html#a5ad34fdd33aa23ffc0c374bf6f2d11b5ac6969385269556756b005c22b71a6e44">Geometry#SOLID</a> for a solid arc and <a class="el" href="classcugl_1_1_geometry.html#a5ad34fdd33aa23ffc0c374bf6f2d11b5ab950bc5b35fc0869f451794889838a4b">Geometry#PATH</a> for an outline. Other geometries are supported as well, if necessary.</p>
<p>The capsule will be appended to the buffer. You should clear the buffer first if you do not want to preserve the original data.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">poly</td><td>The polygon to store the result </td></tr>
    <tr><td class="paramname">rect</td><td>The enclosing rectangle</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a reference to the buffer for chaining. </dd></dl>

</div>
</div>
<a id="a3ef901db8ef5753a9e345ec39d039129"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3ef901db8ef5753a9e345ec39d039129">&#9670;&nbsp;</a></span>makeCapsule() <span class="overload">[5/12]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcugl_1_1_poly2.html">Poly2</a>* cugl::PolyFactory::makeCapsule </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classcugl_1_1_poly2.html">Poly2</a> *&#160;</td>
          <td class="paramname"><em>poly</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classcugl_1_1_vec2.html">Vec2</a>&#160;</td>
          <td class="paramname"><em>origin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classcugl_1_1_size.html">Size</a>&#160;</td>
          <td class="paramname"><em>size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Stores a (full) capsule in the provided buffer.</p>
<p>A capsule is a pill-like shape that fits inside of given rectangle. If width &lt; height, the capsule will be oriented vertically with the rounded portions at the top and bottom. Otherwise it will be oriented horizontally.</p>
<p>The polygon will be generated by the current geometry. Use <a class="el" href="classcugl_1_1_geometry.html#a5ad34fdd33aa23ffc0c374bf6f2d11b5ac6969385269556756b005c22b71a6e44">Geometry#SOLID</a> for a solid arc and <a class="el" href="classcugl_1_1_geometry.html#a5ad34fdd33aa23ffc0c374bf6f2d11b5ab950bc5b35fc0869f451794889838a4b">Geometry#PATH</a> for an outline. Other geometries are supported as well, if necessary.</p>
<p>The capsule will be appended to the buffer. You should clear the buffer first if you do not want to preserve the original data.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">poly</td><td>The polygon to store the result </td></tr>
    <tr><td class="paramname">origin</td><td>The enclosing rectangle origin </td></tr>
    <tr><td class="paramname">size</td><td>The enclosing rectangle size</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a reference to the buffer for chaining. </dd></dl>

</div>
</div>
<a id="aa8d59448b55c198ac337c4046d2ca38c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa8d59448b55c198ac337c4046d2ca38c">&#9670;&nbsp;</a></span>makeCapsule() <span class="overload">[6/12]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcugl_1_1_poly2.html">Poly2</a>* cugl::PolyFactory::makeCapsule </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classcugl_1_1_poly2.html">Poly2</a> *&#160;</td>
          <td class="paramname"><em>poly</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>w</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>h</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Stores a (full) capsule in the provided buffer.</p>
<p>A capsule is a pill-like shape that fits inside of given rectangle. If width &lt; height, the capsule will be oriented vertically with the rounded portions at the top and bottom.Otherwise it will be oriented horizontally.</p>
<p>The polygon will be generated by the current geometry. Use <a class="el" href="classcugl_1_1_geometry.html#a5ad34fdd33aa23ffc0c374bf6f2d11b5ac6969385269556756b005c22b71a6e44">Geometry#SOLID</a> for a solid arc and <a class="el" href="classcugl_1_1_geometry.html#a5ad34fdd33aa23ffc0c374bf6f2d11b5ab950bc5b35fc0869f451794889838a4b">Geometry#PATH</a> for an outline. Other geometries are supported as well, if necessary.</p>
<p>The capsule will be appended to the buffer. You should clear the buffer first if you do not want to preserve the original data.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">poly</td><td>The polygon to store the result </td></tr>
    <tr><td class="paramname">x</td><td>The x-coordinate of the bottom left corner of the bounding box </td></tr>
    <tr><td class="paramname">y</td><td>The y-coordinate of the bottom left corner of the bounding box </td></tr>
    <tr><td class="paramname">w</td><td>The capsule width </td></tr>
    <tr><td class="paramname">h</td><td>The capsule height</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a reference to the buffer for chaining. </dd></dl>

</div>
</div>
<a id="a305f6ba11ec073e93153923e2076eb45"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a305f6ba11ec073e93153923e2076eb45">&#9670;&nbsp;</a></span>makeCapsule() <span class="overload">[7/12]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcugl_1_1_poly2.html">Poly2</a>* cugl::PolyFactory::makeCapsule </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classcugl_1_1_poly2.html">Poly2</a> *&#160;</td>
          <td class="paramname"><em>poly</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacecugl_1_1poly2.html#a78fc88b110befd9afbf1d17aabdebfe3">poly2::Capsule</a>&#160;</td>
          <td class="paramname"><em>shape</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classcugl_1_1_rect.html">Rect</a>&#160;</td>
          <td class="paramname"><em>rect</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Stores a capsule in the provided buffer.</p>
<p>A capsule typically is a pill-like shape that fits inside of given rectangle. If width &lt; height, the capsule will be oriented vertically with the rounded portions at the top and bottom. Otherwise it will be oriented horizontally.</p>
<p>This method allows for the creation of half-capsules, simply by using the enumeration <a class="el" href="namespacecugl_1_1poly2.html#a78fc88b110befd9afbf1d17aabdebfe3">poly2::Capsule</a>. The enumeration specifies which side should be rounded in case of a half-capsule. Half-capsules are sized so that the corresponding full capsule would fit in the bounding box.</p>
<p>The polygon will be generated by the current geometry. Use <a class="el" href="classcugl_1_1_geometry.html#a5ad34fdd33aa23ffc0c374bf6f2d11b5ac6969385269556756b005c22b71a6e44">Geometry#SOLID</a> for a solid arc and <a class="el" href="classcugl_1_1_geometry.html#a5ad34fdd33aa23ffc0c374bf6f2d11b5ab950bc5b35fc0869f451794889838a4b">Geometry#PATH</a> for an outline. Other geometries are supported as well, if necessary.</p>
<p>The capsule will be appended to the buffer. You should clear the buffer first if you do not want to preserve the original data.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">poly</td><td>The polygon to store the result </td></tr>
    <tr><td class="paramname">shape</td><td>The capsule shape </td></tr>
    <tr><td class="paramname">rect</td><td>The enclosing rectangle</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a reference to the buffer for chaining. </dd></dl>

</div>
</div>
<a id="a49ee66773fdffba432821b78cce46399"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a49ee66773fdffba432821b78cce46399">&#9670;&nbsp;</a></span>makeCapsule() <span class="overload">[8/12]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcugl_1_1_poly2.html">Poly2</a>* cugl::PolyFactory::makeCapsule </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classcugl_1_1_poly2.html">Poly2</a> *&#160;</td>
          <td class="paramname"><em>poly</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacecugl_1_1poly2.html#a78fc88b110befd9afbf1d17aabdebfe3">poly2::Capsule</a>&#160;</td>
          <td class="paramname"><em>shape</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classcugl_1_1_vec2.html">Vec2</a>&#160;</td>
          <td class="paramname"><em>origin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classcugl_1_1_size.html">Size</a>&#160;</td>
          <td class="paramname"><em>size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Stores a capsule in the provided buffer.</p>
<p>A capsule typically is a pill-like shape that fits inside of given rectangle. If width &lt; height, the capsule will be oriented vertically with the rounded portions at the top and bottom. Otherwise it will be oriented horizontally.</p>
<p>This method allows for the creation of half-capsules, simply by using the enumeration <a class="el" href="namespacecugl_1_1poly2.html#a78fc88b110befd9afbf1d17aabdebfe3">poly2::Capsule</a>. The enumeration specifies which side should be rounded in case of a half-capsule. Half-capsules are sized so that the corresponding full capsule would fit in the bounding box.</p>
<p>The polygon will be generated by the current geometry. Use <a class="el" href="classcugl_1_1_geometry.html#a5ad34fdd33aa23ffc0c374bf6f2d11b5ac6969385269556756b005c22b71a6e44">Geometry#SOLID</a> for a solid arc and <a class="el" href="classcugl_1_1_geometry.html#a5ad34fdd33aa23ffc0c374bf6f2d11b5ab950bc5b35fc0869f451794889838a4b">Geometry#PATH</a> for an outline. Other geometries are supported as well, if necessary.</p>
<p>The capsule will be appended to the buffer. You should clear the buffer first if you do not want to preserve the original data.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">poly</td><td>The polygon to store the result </td></tr>
    <tr><td class="paramname">shape</td><td>The capsule shape </td></tr>
    <tr><td class="paramname">origin</td><td>The enclosing rectangle origin </td></tr>
    <tr><td class="paramname">size</td><td>The enclosing rectangle size</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a reference to the buffer for chaining. </dd></dl>

</div>
</div>
<a id="aa85081159acaa687bec21bcf9f493ca0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa85081159acaa687bec21bcf9f493ca0">&#9670;&nbsp;</a></span>makeCapsule() <span class="overload">[9/12]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcugl_1_1_poly2.html">Poly2</a>* cugl::PolyFactory::makeCapsule </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classcugl_1_1_poly2.html">Poly2</a> *&#160;</td>
          <td class="paramname"><em>poly</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacecugl_1_1poly2.html#a78fc88b110befd9afbf1d17aabdebfe3">poly2::Capsule</a>&#160;</td>
          <td class="paramname"><em>shape</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>w</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>h</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Stores a capsule in the provided buffer.</p>
<p>A capsule typically is a pill-like shape that fits inside of given rectangle. If width &lt; height, the capsule will be oriented vertically with the rounded portions at the top and bottom. Otherwise it will be oriented horizontally.</p>
<p>This method allows for the creation of half-capsules, simply by using the enumeration <a class="el" href="namespacecugl_1_1poly2.html#a78fc88b110befd9afbf1d17aabdebfe3">poly2::Capsule</a>. The enumeration specifies which side should be rounded in case of a half-capsule. Half-capsules are sized so that the corresponding full capsule would fit in the bounding box.</p>
<p>The polygon will be generated by the current geometry. Use <a class="el" href="classcugl_1_1_geometry.html#a5ad34fdd33aa23ffc0c374bf6f2d11b5ac6969385269556756b005c22b71a6e44">Geometry#SOLID</a> for a solid arc and <a class="el" href="classcugl_1_1_geometry.html#a5ad34fdd33aa23ffc0c374bf6f2d11b5ab950bc5b35fc0869f451794889838a4b">Geometry#PATH</a> for an outline. Other geometries are supported as well, if necessary.</p>
<p>The capsule will be appended to the buffer. You should clear the buffer first if you do not want to preserve the original data.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">poly</td><td>The polygon to store the result </td></tr>
    <tr><td class="paramname">shape</td><td>The capsule shape </td></tr>
    <tr><td class="paramname">x</td><td>The x-coordinate of the bottom left corner of the bounding box </td></tr>
    <tr><td class="paramname">y</td><td>The y-coordinate of the bottom left corner of the bounding box </td></tr>
    <tr><td class="paramname">w</td><td>The capsule width </td></tr>
    <tr><td class="paramname">h</td><td>The capsule height</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a reference to the buffer for chaining. </dd></dl>

</div>
</div>
<a id="a315462d0bbbd7096af4f61d500681cf6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a315462d0bbbd7096af4f61d500681cf6">&#9670;&nbsp;</a></span>makeCapsule() <span class="overload">[10/12]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcugl_1_1_poly2.html">Poly2</a> cugl::PolyFactory::makeCapsule </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacecugl_1_1poly2.html#a78fc88b110befd9afbf1d17aabdebfe3">poly2::Capsule</a>&#160;</td>
          <td class="paramname"><em>shape</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classcugl_1_1_rect.html">Rect</a>&#160;</td>
          <td class="paramname"><em>rect</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns a polygon that represents a capsule of the given dimensions.</p>
<p>A capsule typically is a pill-like shape that fits inside of given rectangle. If width &lt; height, the capsule will be oriented vertically with the rounded portions at the top and bottom. Otherwise it will be oriented horizontally.</p>
<p>This method allows for the creation of half-capsules, simply by using the enumeration <a class="el" href="namespacecugl_1_1poly2.html#a78fc88b110befd9afbf1d17aabdebfe3">poly2::Capsule</a>. The enumeration specifies which side should be rounded in case of a half-capsule. Half-capsules are sized so that the corresponding full capsule would fit in the bounding box.</p>
<p>The polygon will be generated by the current geometry. Use <a class="el" href="classcugl_1_1_geometry.html#a5ad34fdd33aa23ffc0c374bf6f2d11b5ac6969385269556756b005c22b71a6e44">Geometry#SOLID</a> for a solid arc and <a class="el" href="classcugl_1_1_geometry.html#a5ad34fdd33aa23ffc0c374bf6f2d11b5ab950bc5b35fc0869f451794889838a4b">Geometry#PATH</a> for an outline. Other geometries are supported as well, if necessary.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">shape</td><td>The capsule shape </td></tr>
    <tr><td class="paramname">rect</td><td>The enclosing rectangle</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a polygon that represents a capsule of the given dimensions. </dd></dl>

</div>
</div>
<a id="afc0d7bf5e46d7fd530322ffc3bc2bb81"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afc0d7bf5e46d7fd530322ffc3bc2bb81">&#9670;&nbsp;</a></span>makeCapsule() <span class="overload">[11/12]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcugl_1_1_poly2.html">Poly2</a> cugl::PolyFactory::makeCapsule </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacecugl_1_1poly2.html#a78fc88b110befd9afbf1d17aabdebfe3">poly2::Capsule</a>&#160;</td>
          <td class="paramname"><em>shape</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classcugl_1_1_vec2.html">Vec2</a>&#160;</td>
          <td class="paramname"><em>origin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classcugl_1_1_size.html">Size</a>&#160;</td>
          <td class="paramname"><em>size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns a polygon that represents a capsule of the given dimensions.</p>
<p>A capsule typically is a pill-like shape that fits inside of given rectangle. If width &lt; height, the capsule will be oriented vertically with the rounded portions at the top and bottom. Otherwise it will be oriented horizontally.</p>
<p>This method allows for the creation of half-capsules, simply by using the enumeration <a class="el" href="namespacecugl_1_1poly2.html#a78fc88b110befd9afbf1d17aabdebfe3">poly2::Capsule</a>. The enumeration specifies which side should be rounded in case of a half-capsule. Half-capsules are sized so that the corresponding full capsule would fit in the bounding box.</p>
<p>The polygon will be generated by the current geometry. Use <a class="el" href="classcugl_1_1_geometry.html#a5ad34fdd33aa23ffc0c374bf6f2d11b5ac6969385269556756b005c22b71a6e44">Geometry#SOLID</a> for a solid arc and <a class="el" href="classcugl_1_1_geometry.html#a5ad34fdd33aa23ffc0c374bf6f2d11b5ab950bc5b35fc0869f451794889838a4b">Geometry#PATH</a> for an outline. Other geometries are supported as well, if necessary.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">shape</td><td>The capsule shape </td></tr>
    <tr><td class="paramname">origin</td><td>The enclosing rectangle origin </td></tr>
    <tr><td class="paramname">size</td><td>The enclosing rectangle size</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a polygon that represents a capsule of the given dimensions. </dd></dl>

</div>
</div>
<a id="a44b7ed18c003997fa75d2ef6c62dd546"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a44b7ed18c003997fa75d2ef6c62dd546">&#9670;&nbsp;</a></span>makeCapsule() <span class="overload">[12/12]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcugl_1_1_poly2.html">Poly2</a> cugl::PolyFactory::makeCapsule </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacecugl_1_1poly2.html#a78fc88b110befd9afbf1d17aabdebfe3">poly2::Capsule</a>&#160;</td>
          <td class="paramname"><em>shape</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>w</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>h</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns a polygon that represents a (full) capsule of the given dimensions.</p>
<p>A capsule typically is a pill-like shape that fits inside of given rectangle. If width &lt; height, the capsule will be oriented vertically with the rounded portions at the top and bottom. Otherwise it will be oriented horizontally.</p>
<p>This method allows for the creation of half-capsules, simply by using the enumeration <a class="el" href="namespacecugl_1_1poly2.html#a78fc88b110befd9afbf1d17aabdebfe3">poly2::Capsule</a>. The enumeration specifies which side should be rounded in case of a half-capsule. Half-capsules are sized so that the corresponding full capsule would fit in the bounding box.</p>
<p>The polygon will be generated by the current geometry. Use <a class="el" href="classcugl_1_1_geometry.html#a5ad34fdd33aa23ffc0c374bf6f2d11b5ac6969385269556756b005c22b71a6e44">Geometry#SOLID</a> for a solid arc and <a class="el" href="classcugl_1_1_geometry.html#a5ad34fdd33aa23ffc0c374bf6f2d11b5ab950bc5b35fc0869f451794889838a4b">Geometry#PATH</a> for an outline. Other geometries are supported as well, if necessary.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">shape</td><td>The capsule shape </td></tr>
    <tr><td class="paramname">x</td><td>The x-coordinate of the bottom left corner of the bounding box </td></tr>
    <tr><td class="paramname">y</td><td>The y-coordinate of the bottom left corner of the bounding box </td></tr>
    <tr><td class="paramname">w</td><td>The capsule width </td></tr>
    <tr><td class="paramname">h</td><td>The capsule height</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a polygon that represents a capsule of the given dimensions. </dd></dl>

</div>
</div>
<a id="af1c537dc976993804670ea37c39172e2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af1c537dc976993804670ea37c39172e2">&#9670;&nbsp;</a></span>makeCircle() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcugl_1_1_poly2.html">Poly2</a> cugl::PolyFactory::makeCircle </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classcugl_1_1_vec2.html">Vec2</a>&#160;</td>
          <td class="paramname"><em>center</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>radius</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns a polygon that represents a circle of the given dimensions.</p>
<p>The polygon will be generated by the current geometry. Use <a class="el" href="classcugl_1_1_geometry.html#a5ad34fdd33aa23ffc0c374bf6f2d11b5ac6969385269556756b005c22b71a6e44">Geometry#SOLID</a> for a solid ellipse and <a class="el" href="classcugl_1_1_geometry.html#a5ad34fdd33aa23ffc0c374bf6f2d11b5ab950bc5b35fc0869f451794889838a4b">Geometry#PATH</a> for an outline. Other geometries are supported as well, if necessary. This method can be used to generate regular, many-sided polygons by varying the value of <a class="el" href="classcugl_1_1_poly_factory.html#a0935480a336517a12e42b9bb67a8c470">setSegments</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">center</td><td>The circle center point </td></tr>
    <tr><td class="paramname">radius</td><td>The circle radius</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a polygon that represents an circle of the given dimensions. </dd></dl>

</div>
</div>
<a id="a2ba26b13cfd2727a416bc5a87774ae53"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2ba26b13cfd2727a416bc5a87774ae53">&#9670;&nbsp;</a></span>makeCircle() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcugl_1_1_poly2.html">Poly2</a> cugl::PolyFactory::makeCircle </td>
          <td>(</td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>cx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>cy</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>radius</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns a polygon that represents a circle of the given dimensions.</p>
<p>The polygon will be generated by the current geometry. Use <a class="el" href="classcugl_1_1_geometry.html#a5ad34fdd33aa23ffc0c374bf6f2d11b5ac6969385269556756b005c22b71a6e44">Geometry#SOLID</a> for a solid ellipse and <a class="el" href="classcugl_1_1_geometry.html#a5ad34fdd33aa23ffc0c374bf6f2d11b5ab950bc5b35fc0869f451794889838a4b">Geometry#PATH</a> for an outline. Other geometries are supported as well, if necessary. This method can be used to generate regular, many-sided polygons by varying the value of <a class="el" href="classcugl_1_1_poly_factory.html#a0935480a336517a12e42b9bb67a8c470">setSegments</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">cx</td><td>The x-coordinate of the center point </td></tr>
    <tr><td class="paramname">cy</td><td>The y-coordinate of the center point </td></tr>
    <tr><td class="paramname">radius</td><td>The circle radius</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a polygon that represents an circle of the given dimensions. </dd></dl>

</div>
</div>
<a id="a54647c064a1bd0b29d13b21bb976f32d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a54647c064a1bd0b29d13b21bb976f32d">&#9670;&nbsp;</a></span>makeCircle() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcugl_1_1_poly2.html">Poly2</a>* cugl::PolyFactory::makeCircle </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classcugl_1_1_poly2.html">Poly2</a> *&#160;</td>
          <td class="paramname"><em>poly</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classcugl_1_1_vec2.html">Vec2</a>&#160;</td>
          <td class="paramname"><em>center</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>radius</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Stores a circle in the provided buffer.</p>
<p>The polygon will be generated by the current geometry. Use <a class="el" href="classcugl_1_1_geometry.html#a5ad34fdd33aa23ffc0c374bf6f2d11b5ac6969385269556756b005c22b71a6e44">Geometry#SOLID</a> for a solid ellipse and <a class="el" href="classcugl_1_1_geometry.html#a5ad34fdd33aa23ffc0c374bf6f2d11b5ab950bc5b35fc0869f451794889838a4b">Geometry#PATH</a> for an outline. Other geometries are supported as well, if necessary. This method can be used to generate regular, many-sided polygons by varying the value of <a class="el" href="classcugl_1_1_poly_factory.html#a0935480a336517a12e42b9bb67a8c470">setSegments</a>.</p>
<p>The circle will be appended to the buffer. You should clear the buffer first if you do not want to preserve the original data.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">poly</td><td>The polygon to store the result </td></tr>
    <tr><td class="paramname">center</td><td>The circle center point </td></tr>
    <tr><td class="paramname">radius</td><td>The circle radius</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a reference to the buffer for chaining. </dd></dl>

</div>
</div>
<a id="a79351ed5423aa4915292221dfd4a7012"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a79351ed5423aa4915292221dfd4a7012">&#9670;&nbsp;</a></span>makeCircle() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcugl_1_1_poly2.html">Poly2</a>* cugl::PolyFactory::makeCircle </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classcugl_1_1_poly2.html">Poly2</a> *&#160;</td>
          <td class="paramname"><em>poly</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>cx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>cy</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>radius</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Stores a circle in the provided buffer.</p>
<p>The polygon will be generated by the current geometry. Use <a class="el" href="classcugl_1_1_geometry.html#a5ad34fdd33aa23ffc0c374bf6f2d11b5ac6969385269556756b005c22b71a6e44">Geometry#SOLID</a> for a solid ellipse and <a class="el" href="classcugl_1_1_geometry.html#a5ad34fdd33aa23ffc0c374bf6f2d11b5ab950bc5b35fc0869f451794889838a4b">Geometry#PATH</a> for an outline. Other geometries are supported as well, if necessary. This method can be used to generate regular, many-sided polygons by varying the value of <a class="el" href="classcugl_1_1_poly_factory.html#a0935480a336517a12e42b9bb67a8c470">setSegments</a>.</p>
<p>The circle will be appended to the buffer. You should clear the buffer first if you do not want to preserve the original data.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">poly</td><td>The polygon to store the result </td></tr>
    <tr><td class="paramname">cx</td><td>The x-coordinate of the center point </td></tr>
    <tr><td class="paramname">cy</td><td>The y-coordinate of the center point </td></tr>
    <tr><td class="paramname">radius</td><td>The circle radius</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a reference to the buffer for chaining. </dd></dl>

</div>
</div>
<a id="a8eaae575a4d94f50c83ac110c742c505"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8eaae575a4d94f50c83ac110c742c505">&#9670;&nbsp;</a></span>makeEllipse() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcugl_1_1_poly2.html">Poly2</a> cugl::PolyFactory::makeEllipse </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classcugl_1_1_vec2.html">Vec2</a>&#160;</td>
          <td class="paramname"><em>center</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classcugl_1_1_vec2.html">Vec2</a>&#160;</td>
          <td class="paramname"><em>size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns a polygon that represents an ellipse of the given dimensions.</p>
<p>The polygon will be generated by the current geometry. Use <a class="el" href="classcugl_1_1_geometry.html#a5ad34fdd33aa23ffc0c374bf6f2d11b5ac6969385269556756b005c22b71a6e44">Geometry#SOLID</a> for a solid ellipse and <a class="el" href="classcugl_1_1_geometry.html#a5ad34fdd33aa23ffc0c374bf6f2d11b5ab950bc5b35fc0869f451794889838a4b">Geometry#PATH</a> for an outline. Other geometries are supported as well, if necessary.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">center</td><td>The ellipse center point </td></tr>
    <tr><td class="paramname">size</td><td>The size of the ellipse</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a polygon that represents an ellipse of the given dimensions. </dd></dl>

</div>
</div>
<a id="a469d6d81c79daaca181573185f2325f8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a469d6d81c79daaca181573185f2325f8">&#9670;&nbsp;</a></span>makeEllipse() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcugl_1_1_poly2.html">Poly2</a> cugl::PolyFactory::makeEllipse </td>
          <td>(</td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>cx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>cy</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>sx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>sy</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns a polygon that represents an ellipse of the given dimensions.</p>
<p>The polygon will be generated by the current geometry. Use <a class="el" href="classcugl_1_1_geometry.html#a5ad34fdd33aa23ffc0c374bf6f2d11b5ac6969385269556756b005c22b71a6e44">Geometry#SOLID</a> for a solid ellipse and <a class="el" href="classcugl_1_1_geometry.html#a5ad34fdd33aa23ffc0c374bf6f2d11b5ab950bc5b35fc0869f451794889838a4b">Geometry#PATH</a> for an outline. Other geometries are supported as well, if necessary.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">cx</td><td>The x-coordinate of the center point </td></tr>
    <tr><td class="paramname">cy</td><td>The y-coordinate of the center point </td></tr>
    <tr><td class="paramname">sx</td><td>The size (diameter) along the x-axis </td></tr>
    <tr><td class="paramname">sy</td><td>The size (diameter) along the y-axis</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a polygon that represents an ellipse of the given dimensions. </dd></dl>

</div>
</div>
<a id="ac987122377b5469ac60ec9db4b221a73"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac987122377b5469ac60ec9db4b221a73">&#9670;&nbsp;</a></span>makeEllipse() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcugl_1_1_poly2.html">Poly2</a>* cugl::PolyFactory::makeEllipse </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classcugl_1_1_poly2.html">Poly2</a> *&#160;</td>
          <td class="paramname"><em>poly</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classcugl_1_1_vec2.html">Vec2</a>&#160;</td>
          <td class="paramname"><em>center</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classcugl_1_1_vec2.html">Vec2</a>&#160;</td>
          <td class="paramname"><em>size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Stores an ellipse in the provided buffer.</p>
<p>The polygon will be generated by the current geometry. Use <a class="el" href="classcugl_1_1_geometry.html#a5ad34fdd33aa23ffc0c374bf6f2d11b5ac6969385269556756b005c22b71a6e44">Geometry#SOLID</a> for a solid ellipse and <a class="el" href="classcugl_1_1_geometry.html#a5ad34fdd33aa23ffc0c374bf6f2d11b5ab950bc5b35fc0869f451794889838a4b">Geometry#PATH</a> for an outline. Other geometries are supported as well, if necessary.</p>
<p>The ellipse will be appended to the buffer. You should clear the buffer first if you do not want to preserve the original data.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">poly</td><td>The polygon to store the result </td></tr>
    <tr><td class="paramname">center</td><td>The ellipse center point </td></tr>
    <tr><td class="paramname">size</td><td>The size of the ellipse</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a reference to the buffer for chaining. </dd></dl>

</div>
</div>
<a id="a8c46739d5f89c4a96c63cc94431e1b39"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8c46739d5f89c4a96c63cc94431e1b39">&#9670;&nbsp;</a></span>makeEllipse() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcugl_1_1_poly2.html">Poly2</a>* cugl::PolyFactory::makeEllipse </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classcugl_1_1_poly2.html">Poly2</a> *&#160;</td>
          <td class="paramname"><em>poly</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>cx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>cy</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>sx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>sy</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Stores an ellipse in the provided buffer.</p>
<p>The polygon will be generated by the current geometry. Use <a class="el" href="classcugl_1_1_geometry.html#a5ad34fdd33aa23ffc0c374bf6f2d11b5ac6969385269556756b005c22b71a6e44">Geometry#SOLID</a> for a solid ellipse and <a class="el" href="classcugl_1_1_geometry.html#a5ad34fdd33aa23ffc0c374bf6f2d11b5ab950bc5b35fc0869f451794889838a4b">Geometry#PATH</a> for an outline. Other geometries are supported as well, if necessary.</p>
<p>The ellipse will be appended to the buffer. You should clear the buffer first if you do not want to preserve the original data.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">poly</td><td>The polygon to store the result </td></tr>
    <tr><td class="paramname">cx</td><td>The x-coordinate of the center point </td></tr>
    <tr><td class="paramname">cy</td><td>The y-coordinate of the center point </td></tr>
    <tr><td class="paramname">sx</td><td>The size (diameter) along the x-axis </td></tr>
    <tr><td class="paramname">sy</td><td>The size (diameter) along the y-axis</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a reference to the buffer for chaining. </dd></dl>

</div>
</div>
<a id="a1da11d2787a2c47eced278cc6db95666"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1da11d2787a2c47eced278cc6db95666">&#9670;&nbsp;</a></span>makeLine() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcugl_1_1_poly2.html">Poly2</a> cugl::PolyFactory::makeLine </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classcugl_1_1_vec2.html">Vec2</a>&#160;</td>
          <td class="paramname"><em>origin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classcugl_1_1_vec2.html">Vec2</a>&#160;</td>
          <td class="paramname"><em>dest</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns a polygon that represents a line segment from origin to dest.</p>
<p>This method will do nothing if the geometry is <a class="el" href="classcugl_1_1_geometry.html#a5ad34fdd33aa23ffc0c374bf6f2d11b5ac6969385269556756b005c22b71a6e44">Geometry#SOLID</a>. However, it does support all other geometry types, including <code>POINTS</code> and <code>IMPLICIT</code>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">origin</td><td>The line origin </td></tr>
    <tr><td class="paramname">dest</td><td>The line destination</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a polygon that represents a line segment from origin to dest. </dd></dl>

</div>
</div>
<a id="a86b8df3ff9187e5544b30356ec6dac1d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a86b8df3ff9187e5544b30356ec6dac1d">&#9670;&nbsp;</a></span>makeLine() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcugl_1_1_poly2.html">Poly2</a> cugl::PolyFactory::makeLine </td>
          <td>(</td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>ox</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>oy</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>dx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>dy</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns a polygon that represents a line segment from origin to dest.</p>
<p>This method will do nothing if the geometry is <a class="el" href="classcugl_1_1_geometry.html#a5ad34fdd33aa23ffc0c374bf6f2d11b5ac6969385269556756b005c22b71a6e44">Geometry#SOLID</a>. However, it does support all other geometry types, including <code>POINTS</code> and <code>IMPLICIT</code>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ox</td><td>The x-coordinate of the origin </td></tr>
    <tr><td class="paramname">oy</td><td>The y-coordinate of the origin </td></tr>
    <tr><td class="paramname">dx</td><td>The x-coordinate of the destination </td></tr>
    <tr><td class="paramname">dy</td><td>The y-coordinate of the destination</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a polygon that represents a line segment from origin to dest. </dd></dl>

</div>
</div>
<a id="aafe66d98482e611ca305a3bae319b967"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aafe66d98482e611ca305a3bae319b967">&#9670;&nbsp;</a></span>makeLine() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcugl_1_1_poly2.html">Poly2</a>* cugl::PolyFactory::makeLine </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classcugl_1_1_poly2.html">Poly2</a> *&#160;</td>
          <td class="paramname"><em>poly</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classcugl_1_1_vec2.html">Vec2</a>&#160;</td>
          <td class="paramname"><em>origin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classcugl_1_1_vec2.html">Vec2</a>&#160;</td>
          <td class="paramname"><em>dest</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Stores a line segment from origin to dest in the provided buffer.</p>
<p>The line will be appended to the buffer. You should clear the buffer first if you do not want to preserve the original data. This method will do nothing if the current geometry is <a class="el" href="classcugl_1_1_geometry.html#a5ad34fdd33aa23ffc0c374bf6f2d11b5ac6969385269556756b005c22b71a6e44">Geometry#SOLID</a>. However, it does support all other geometry types, including <code>POINTS</code> and <code>IMPLICIT</code>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">poly</td><td>The polygon to store the result </td></tr>
    <tr><td class="paramname">origin</td><td>The line origin </td></tr>
    <tr><td class="paramname">dest</td><td>The line destination</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a reference to the buffer for chaining. </dd></dl>

</div>
</div>
<a id="a6701a7cc34104b6fd225ef8c187fb6b5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6701a7cc34104b6fd225ef8c187fb6b5">&#9670;&nbsp;</a></span>makeLine() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcugl_1_1_poly2.html">Poly2</a>* cugl::PolyFactory::makeLine </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classcugl_1_1_poly2.html">Poly2</a> *&#160;</td>
          <td class="paramname"><em>poly</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>ox</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>oy</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>dx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>dy</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Stores a line segment from origin to dest in the provided buffer.</p>
<p>The line will be appended to the buffer. You should clear the buffer first if you do not want to preserve the original data. This method will do nothing if the current geometry is <a class="el" href="classcugl_1_1_geometry.html#a5ad34fdd33aa23ffc0c374bf6f2d11b5ac6969385269556756b005c22b71a6e44">Geometry#SOLID</a>. However, it does support all other geometry types, including <code>POINTS</code> and <code>IMPLICIT</code>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">poly</td><td>The polygon to store the result </td></tr>
    <tr><td class="paramname">ox</td><td>The x-coordinate of the origin </td></tr>
    <tr><td class="paramname">oy</td><td>The y-coordinate of the origin </td></tr>
    <tr><td class="paramname">dx</td><td>The x-coordinate of the destination </td></tr>
    <tr><td class="paramname">dy</td><td>The y-coordinate of the destination</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a reference to the buffer for chaining. </dd></dl>

</div>
</div>
<a id="aa2a9a6916795accf5e95e736c521aa24"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa2a9a6916795accf5e95e736c521aa24">&#9670;&nbsp;</a></span>makeRect() <span class="overload">[1/6]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcugl_1_1_poly2.html">Poly2</a> cugl::PolyFactory::makeRect </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classcugl_1_1_rect.html">Rect</a>&#160;</td>
          <td class="paramname"><em>rect</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns a polygon that represents a rectangle</p>
<p>The polygon will be generated by the current geometry. Use <a class="el" href="classcugl_1_1_geometry.html#a5ad34fdd33aa23ffc0c374bf6f2d11b5ac6969385269556756b005c22b71a6e44">Geometry#SOLID</a> for a solid rectangle and <a class="el" href="classcugl_1_1_geometry.html#a5ad34fdd33aa23ffc0c374bf6f2d11b5ab950bc5b35fc0869f451794889838a4b">Geometry#PATH</a> for an outline. Other geometries are supported as well, if necessary.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">rect</td><td>The rectangle</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a polygon that represents a rectangle </dd></dl>

</div>
</div>
<a id="ac16797d2f49182326868d52a544da793"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac16797d2f49182326868d52a544da793">&#9670;&nbsp;</a></span>makeRect() <span class="overload">[2/6]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcugl_1_1_poly2.html">Poly2</a> cugl::PolyFactory::makeRect </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classcugl_1_1_vec2.html">Vec2</a>&#160;</td>
          <td class="paramname"><em>origin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classcugl_1_1_vec2.html">Vec2</a>&#160;</td>
          <td class="paramname"><em>size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns a polygon that represents a rectangle</p>
<p>The polygon will be generated by the current geometry. Use <a class="el" href="classcugl_1_1_geometry.html#a5ad34fdd33aa23ffc0c374bf6f2d11b5ac6969385269556756b005c22b71a6e44">Geometry#SOLID</a> for a solid rectangle and <a class="el" href="classcugl_1_1_geometry.html#a5ad34fdd33aa23ffc0c374bf6f2d11b5ab950bc5b35fc0869f451794889838a4b">Geometry#PATH</a> for an outline. Other geometries are supported as well, if necessary.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">origin</td><td>The rectangle origin </td></tr>
    <tr><td class="paramname">size</td><td>The rectangle size</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a polygon that represents a rectangle </dd></dl>

</div>
</div>
<a id="a6034ae57f1c22bdff7eade572426c6d8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6034ae57f1c22bdff7eade572426c6d8">&#9670;&nbsp;</a></span>makeRect() <span class="overload">[3/6]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcugl_1_1_poly2.html">Poly2</a> cugl::PolyFactory::makeRect </td>
          <td>(</td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>w</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>h</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns a polygon that represents a rectangle</p>
<p>The polygon will be generated by the current geometry. Use <a class="el" href="classcugl_1_1_geometry.html#a5ad34fdd33aa23ffc0c374bf6f2d11b5ac6969385269556756b005c22b71a6e44">Geometry#SOLID</a> for a solid rectangle and <a class="el" href="classcugl_1_1_geometry.html#a5ad34fdd33aa23ffc0c374bf6f2d11b5ab950bc5b35fc0869f451794889838a4b">Geometry#PATH</a> for an outline. Other geometries are supported as well, if necessary.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>The x-coordinate of the bottom left corner </td></tr>
    <tr><td class="paramname">y</td><td>The y-coordinate of the bottom left corner </td></tr>
    <tr><td class="paramname">w</td><td>The rectangle width </td></tr>
    <tr><td class="paramname">h</td><td>The rectangle height</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a polygon that represents a rectangle </dd></dl>

</div>
</div>
<a id="ac629b3e1ca38b516d06db5922765e3fa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac629b3e1ca38b516d06db5922765e3fa">&#9670;&nbsp;</a></span>makeRect() <span class="overload">[4/6]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcugl_1_1_poly2.html">Poly2</a>* cugl::PolyFactory::makeRect </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classcugl_1_1_poly2.html">Poly2</a> *&#160;</td>
          <td class="paramname"><em>poly</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classcugl_1_1_rect.html">Rect</a>&#160;</td>
          <td class="paramname"><em>rect</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Stores a rectangle in the provided buffer.</p>
<p>The polygon will be generated by the current geometry. Use <a class="el" href="classcugl_1_1_geometry.html#a5ad34fdd33aa23ffc0c374bf6f2d11b5ac6969385269556756b005c22b71a6e44">Geometry#SOLID</a> for a solid rectangle and <a class="el" href="classcugl_1_1_geometry.html#a5ad34fdd33aa23ffc0c374bf6f2d11b5ab950bc5b35fc0869f451794889838a4b">Geometry#PATH</a> for an outline. Other geometries are supported as well, if necessary.</p>
<p>The rectangle will be appended to the buffer. You should clear the buffer first if you do not want to preserve the original data.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">poly</td><td>The polygon to store the result </td></tr>
    <tr><td class="paramname">rect</td><td>The rectangle to create</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a reference to the buffer for chaining. </dd></dl>

</div>
</div>
<a id="a954d21b9356b12af452cc28c48cfc0b3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a954d21b9356b12af452cc28c48cfc0b3">&#9670;&nbsp;</a></span>makeRect() <span class="overload">[5/6]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcugl_1_1_poly2.html">Poly2</a>* cugl::PolyFactory::makeRect </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classcugl_1_1_poly2.html">Poly2</a> *&#160;</td>
          <td class="paramname"><em>poly</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classcugl_1_1_vec2.html">Vec2</a>&#160;</td>
          <td class="paramname"><em>origin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classcugl_1_1_vec2.html">Vec2</a>&#160;</td>
          <td class="paramname"><em>size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Stores a rectangle in the provided buffer.</p>
<p>The polygon will be generated by the current geometry. Use <a class="el" href="classcugl_1_1_geometry.html#a5ad34fdd33aa23ffc0c374bf6f2d11b5ac6969385269556756b005c22b71a6e44">Geometry#SOLID</a> for a solid rectangle and <a class="el" href="classcugl_1_1_geometry.html#a5ad34fdd33aa23ffc0c374bf6f2d11b5ab950bc5b35fc0869f451794889838a4b">Geometry#PATH</a> for an outline. Other geometries are supported as well, if necessary.</p>
<p>The rectangle will be appended to the buffer. You should clear the buffer first if you do not want to preserve the original data.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">poly</td><td>The polygon to store the result </td></tr>
    <tr><td class="paramname">origin</td><td>The rectangle origin </td></tr>
    <tr><td class="paramname">size</td><td>The rectangle size</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a reference to the buffer for chaining. </dd></dl>

</div>
</div>
<a id="ab2ebf8f09da1c0135580631583c1f53e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab2ebf8f09da1c0135580631583c1f53e">&#9670;&nbsp;</a></span>makeRect() <span class="overload">[6/6]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcugl_1_1_poly2.html">Poly2</a>* cugl::PolyFactory::makeRect </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classcugl_1_1_poly2.html">Poly2</a> *&#160;</td>
          <td class="paramname"><em>poly</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>w</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>h</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Stores a rectangle in the provided buffer.</p>
<p>The polygon will be generated by the current geometry. Use <a class="el" href="classcugl_1_1_geometry.html#a5ad34fdd33aa23ffc0c374bf6f2d11b5ac6969385269556756b005c22b71a6e44">Geometry#SOLID</a> for a solid rectangle and <a class="el" href="classcugl_1_1_geometry.html#a5ad34fdd33aa23ffc0c374bf6f2d11b5ab950bc5b35fc0869f451794889838a4b">Geometry#PATH</a> for an outline. Other geometries are supported as well, if necessary.</p>
<p>The rectangle will be appended to the buffer. You should clear the buffer first if you do not want to preserve the original data.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">poly</td><td>The polygon to store the result </td></tr>
    <tr><td class="paramname">x</td><td>The x-coordinate of the bottom left corner </td></tr>
    <tr><td class="paramname">y</td><td>The y-coordinate of the bottom left corner </td></tr>
    <tr><td class="paramname">w</td><td>The rectangle width </td></tr>
    <tr><td class="paramname">h</td><td>The rectangle height</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a reference to the buffer for chaining. </dd></dl>

</div>
</div>
<a id="a8877304de54aba75b3936c61e4c72d08"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8877304de54aba75b3936c61e4c72d08">&#9670;&nbsp;</a></span>makeRoundedRect() <span class="overload">[1/6]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcugl_1_1_poly2.html">Poly2</a> cugl::PolyFactory::makeRoundedRect </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classcugl_1_1_rect.html">Rect</a>&#160;</td>
          <td class="paramname"><em>rect</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>radius</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns a polygon that represents a rounded rectangle of the given dimensions.</p>
<p>The polygon will be generated by the current geometry. Use <a class="el" href="classcugl_1_1_geometry.html#a5ad34fdd33aa23ffc0c374bf6f2d11b5ac6969385269556756b005c22b71a6e44">Geometry#SOLID</a> for a solid arc and <a class="el" href="classcugl_1_1_geometry.html#a5ad34fdd33aa23ffc0c374bf6f2d11b5ab950bc5b35fc0869f451794889838a4b">Geometry#PATH</a> for an outline. Other geometries are supported as well, if necessary. The radius should not exceed either half the width or half the height.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">rect</td><td>The enclosing rectangle </td></tr>
    <tr><td class="paramname">radius</td><td>The radius of each corner</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a polygon that represents a rounded rectangle of the given dimensions. </dd></dl>

</div>
</div>
<a id="aec7cf770c905c240752d022d58961fd4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aec7cf770c905c240752d022d58961fd4">&#9670;&nbsp;</a></span>makeRoundedRect() <span class="overload">[2/6]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcugl_1_1_poly2.html">Poly2</a> cugl::PolyFactory::makeRoundedRect </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classcugl_1_1_vec2.html">Vec2</a>&#160;</td>
          <td class="paramname"><em>origin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classcugl_1_1_size.html">Size</a>&#160;</td>
          <td class="paramname"><em>size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>radius</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns a polygon that represents a rounded rectangle of the given dimensions.</p>
<p>The polygon will be generated by the current geometry. Use <a class="el" href="classcugl_1_1_geometry.html#a5ad34fdd33aa23ffc0c374bf6f2d11b5ac6969385269556756b005c22b71a6e44">Geometry#SOLID</a> for a solid arc and <a class="el" href="classcugl_1_1_geometry.html#a5ad34fdd33aa23ffc0c374bf6f2d11b5ab950bc5b35fc0869f451794889838a4b">Geometry#PATH</a> for an outline. Other geometries are supported as well, if necessary. The radius should not exceed either half the width or half the height.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">origin</td><td>The enclosing rectangle origin </td></tr>
    <tr><td class="paramname">size</td><td>The enclosing rectangle size </td></tr>
    <tr><td class="paramname">radius</td><td>The radius of each corner</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a polygon that represents a rounded rectangle of the given dimensions. </dd></dl>

</div>
</div>
<a id="a00bdc6a2ba719591e74342dcb6168c5f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a00bdc6a2ba719591e74342dcb6168c5f">&#9670;&nbsp;</a></span>makeRoundedRect() <span class="overload">[3/6]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcugl_1_1_poly2.html">Poly2</a> cugl::PolyFactory::makeRoundedRect </td>
          <td>(</td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>w</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>h</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>r</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns a polygon that represents a rounded rectangle of the given dimensions.</p>
<p>The polygon will be generated by the current geometry. Use <a class="el" href="classcugl_1_1_geometry.html#a5ad34fdd33aa23ffc0c374bf6f2d11b5ac6969385269556756b005c22b71a6e44">Geometry#SOLID</a> for a solid arc and <a class="el" href="classcugl_1_1_geometry.html#a5ad34fdd33aa23ffc0c374bf6f2d11b5ab950bc5b35fc0869f451794889838a4b">Geometry#PATH</a> for an outline. Other geometries are supported as well, if necessary. The radius should not exceed either half the width or half the height.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>The x-coordinate of the bottom left corner of the bounding box </td></tr>
    <tr><td class="paramname">y</td><td>The y-coordinate of the bottom left corner of the bounding box </td></tr>
    <tr><td class="paramname">w</td><td>The rectangle width </td></tr>
    <tr><td class="paramname">h</td><td>The rectangle height </td></tr>
    <tr><td class="paramname">r</td><td>The radius of each corner</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a polygon that represents a rounded rectangle of the given dimensions. </dd></dl>

</div>
</div>
<a id="a11661e624b9c51bdf90bed62a622040c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a11661e624b9c51bdf90bed62a622040c">&#9670;&nbsp;</a></span>makeRoundedRect() <span class="overload">[4/6]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcugl_1_1_poly2.html">Poly2</a>* cugl::PolyFactory::makeRoundedRect </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classcugl_1_1_poly2.html">Poly2</a> *&#160;</td>
          <td class="paramname"><em>poly</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classcugl_1_1_rect.html">Rect</a>&#160;</td>
          <td class="paramname"><em>rect</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>radius</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Stores a rounded rectangle in the provided buffer.</p>
<p>The polygon will be generated by the current geometry. Use <a class="el" href="classcugl_1_1_geometry.html#a5ad34fdd33aa23ffc0c374bf6f2d11b5ac6969385269556756b005c22b71a6e44">Geometry#SOLID</a> for a solid arc and <a class="el" href="classcugl_1_1_geometry.html#a5ad34fdd33aa23ffc0c374bf6f2d11b5ab950bc5b35fc0869f451794889838a4b">Geometry#PATH</a> for an outline. Other geometries are supported as well, if necessary. The radius should not exceed either half the width or half the height.</p>
<p>The rounded rectangle will be appended to the buffer. You should clear the buffer first if you do not want to preserve the original data.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">poly</td><td>The polygon to store the result </td></tr>
    <tr><td class="paramname">rect</td><td>The enclosing rectangle </td></tr>
    <tr><td class="paramname">radius</td><td>The radius of each corner</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a reference to the buffer for chaining. </dd></dl>

</div>
</div>
<a id="aaac40ba1e18ddeb2fa5015074d09b3fb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaac40ba1e18ddeb2fa5015074d09b3fb">&#9670;&nbsp;</a></span>makeRoundedRect() <span class="overload">[5/6]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcugl_1_1_poly2.html">Poly2</a>* cugl::PolyFactory::makeRoundedRect </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classcugl_1_1_poly2.html">Poly2</a> *&#160;</td>
          <td class="paramname"><em>poly</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classcugl_1_1_vec2.html">Vec2</a>&#160;</td>
          <td class="paramname"><em>origin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classcugl_1_1_size.html">Size</a>&#160;</td>
          <td class="paramname"><em>size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>radius</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Stores a rounded rectangle in the provided buffer.</p>
<p>The polygon will be generated by the current geometry. Use <a class="el" href="classcugl_1_1_geometry.html#a5ad34fdd33aa23ffc0c374bf6f2d11b5ac6969385269556756b005c22b71a6e44">Geometry#SOLID</a> for a solid arc and <a class="el" href="classcugl_1_1_geometry.html#a5ad34fdd33aa23ffc0c374bf6f2d11b5ab950bc5b35fc0869f451794889838a4b">Geometry#PATH</a> for an outline. Other geometries are supported as well, if necessary. The radius should not exceed either half the width or half the height.</p>
<p>The rounded rectangle will be appended to the buffer. You should clear the buffer first if you do not want to preserve the original data.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">poly</td><td>The polygon to store the result </td></tr>
    <tr><td class="paramname">origin</td><td>The enclosing rectangle origin </td></tr>
    <tr><td class="paramname">size</td><td>The enclosing rectangle size </td></tr>
    <tr><td class="paramname">radius</td><td>The radius of each corner</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a reference to the buffer for chaining. </dd></dl>

</div>
</div>
<a id="a4d22db162443ec4e223261e3a8c83461"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4d22db162443ec4e223261e3a8c83461">&#9670;&nbsp;</a></span>makeRoundedRect() <span class="overload">[6/6]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcugl_1_1_poly2.html">Poly2</a>* cugl::PolyFactory::makeRoundedRect </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classcugl_1_1_poly2.html">Poly2</a> *&#160;</td>
          <td class="paramname"><em>poly</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>w</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>h</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>r</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Stores a rounded rectangle in the provided buffer.</p>
<p>The polygon will be generated by the current geometry. Use <a class="el" href="classcugl_1_1_geometry.html#a5ad34fdd33aa23ffc0c374bf6f2d11b5ac6969385269556756b005c22b71a6e44">Geometry#SOLID</a> for a solid arc and <a class="el" href="classcugl_1_1_geometry.html#a5ad34fdd33aa23ffc0c374bf6f2d11b5ab950bc5b35fc0869f451794889838a4b">Geometry#PATH</a> for an outline. Other geometries are supported as well, if necessary. The radius should not exceed either half the width or half the height.</p>
<p>The rounded rectangle will be appended to the buffer. You should clear the buffer first if you do not want to preserve the original data.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">poly</td><td>The polygon to store the result </td></tr>
    <tr><td class="paramname">x</td><td>The x-coordinate of the bottom left corner of the bounding box </td></tr>
    <tr><td class="paramname">y</td><td>The y-coordinate of the bottom left corner of the bounding box </td></tr>
    <tr><td class="paramname">w</td><td>The rectangle width </td></tr>
    <tr><td class="paramname">h</td><td>The rectangle height </td></tr>
    <tr><td class="paramname">r</td><td>The radius of each corner</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a reference to the buffer for chaining. </dd></dl>

</div>
</div>
<a id="a71f9a9380bbc76d025315d47fcb1a5c3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a71f9a9380bbc76d025315d47fcb1a5c3">&#9670;&nbsp;</a></span>makeTraversal() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcugl_1_1_poly2.html">Poly2</a> cugl::PolyFactory::makeTraversal </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classcugl_1_1_poly2.html">Poly2</a> &amp;&#160;</td>
          <td class="paramname"><em>src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacecugl_1_1poly2.html#a7085f690f432be28cf5d5f74ee7a550b">poly2::Traversal</a>&#160;</td>
          <td class="paramname"><em>type</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns a polygon representing a wire frame of an existing polygon.</p>
<p>This method provides four types of traversals: <code>NONE</code>, <code>OPEN</code>, <code>CLOSED</code> and <code>INTERIOR</code>. No traversal simply copies the given polygon. The open and closed traversals apply to the boundary of the polygon (as determined by <a class="el" href="classcugl_1_1_geometry.html#acd722d13b3ca748a563eb85f95a42025">Geometry#boundaries</a>. If there is more than one boundary, then the closed traversal connects the boundaries together in a single loop.</p>
<p>Finally, the interior traversal creates a wire frame a polygon triangulation. This means that it can only be applied to a <code>SOLID</code> polygon. An interior traversal is meaningless unless the polygon has an existing triangulation.</p>
<p>This method does nothing if the geometry is <a class="el" href="classcugl_1_1_geometry.html#a5ad34fdd33aa23ffc0c374bf6f2d11b5ac6969385269556756b005c22b71a6e44">Geometry#SOLID</a>. However, it does support all other geometry types, including <code>POINTS</code> and <code>IMPLICIT</code>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">src</td><td>The source polygon to traverse </td></tr>
    <tr><td class="paramname">type</td><td>The traversal type</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a polygon representing a wire frame of an existing polygon. </dd></dl>

</div>
</div>
<a id="a4800f9dc339ade096a658c275e23f1fe"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4800f9dc339ade096a658c275e23f1fe">&#9670;&nbsp;</a></span>makeTraversal() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcugl_1_1_poly2.html">Poly2</a>* cugl::PolyFactory::makeTraversal </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classcugl_1_1_poly2.html">Poly2</a> *&#160;</td>
          <td class="paramname"><em>poly</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classcugl_1_1_poly2.html">Poly2</a> &amp;&#160;</td>
          <td class="paramname"><em>src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacecugl_1_1poly2.html#a7085f690f432be28cf5d5f74ee7a550b">poly2::Traversal</a>&#160;</td>
          <td class="paramname"><em>type</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Stores a wire frame of an existing polygon in the provided buffer.</p>
<p>This method provides four types of traversals: <code>NONE</code>, <code>OPEN</code>, <code>CLOSED</code> and <code>INTERIOR</code>. No traversal simply copies the given polygon. The open and closed traversals apply to the boundary of the polygon (as determined by <a class="el" href="classcugl_1_1_geometry.html#acd722d13b3ca748a563eb85f95a42025">Geometry#boundaries</a>. If there is more than one boundary, then the closed traversal connects the boundaries together in a single loop.</p>
<p>Finally, the interior traversal creates a wire frame a polygon triangulation. This means that it can only be applied to a <code>SOLID</code> polygon. An interior traversal is meaningless unless the polygon has an existing triangulation.</p>
<p>This method does nothing if the geometry is <a class="el" href="classcugl_1_1_geometry.html#a5ad34fdd33aa23ffc0c374bf6f2d11b5ac6969385269556756b005c22b71a6e44">Geometry#SOLID</a>. However, it does support all other geometry types, including <code>POINTS</code> and <code>IMPLICIT</code>.</p>
<p>The traversal will be appended to the buffer. You should clear the buffer first if you do not want to preserve the original data.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">poly</td><td>The polygon to store the result </td></tr>
    <tr><td class="paramname">src</td><td>The source polygon to traverse </td></tr>
    <tr><td class="paramname">type</td><td>The traversal type</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a reference to the buffer for chaining. </dd></dl>

</div>
</div>
<a id="ae6f6c98ca325474a1f3bd3961daa6bbc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae6f6c98ca325474a1f3bd3961daa6bbc">&#9670;&nbsp;</a></span>makeTriangle() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcugl_1_1_poly2.html">Poly2</a> cugl::PolyFactory::makeTriangle </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classcugl_1_1_vec2.html">Vec2</a>&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classcugl_1_1_vec2.html">Vec2</a>&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classcugl_1_1_vec2.html">Vec2</a>&#160;</td>
          <td class="paramname"><em>c</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns a polygon that represents a simple triangle.</p>
<p>The polygon will be generated by the current geometry. Use <a class="el" href="classcugl_1_1_geometry.html#a5ad34fdd33aa23ffc0c374bf6f2d11b5ac6969385269556756b005c22b71a6e44">Geometry#SOLID</a> for a solid triangle and <a class="el" href="classcugl_1_1_geometry.html#a5ad34fdd33aa23ffc0c374bf6f2d11b5ab950bc5b35fc0869f451794889838a4b">Geometry#PATH</a> for an outline. Other geometries are supported as well, if necessary.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">a</td><td>The first vertex. </td></tr>
    <tr><td class="paramname">b</td><td>The second vertex. </td></tr>
    <tr><td class="paramname">c</td><td>The third vertex.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a polygon that represents a simple triangle. </dd></dl>

</div>
</div>
<a id="aff01208b1234556eb6b1ca14aad00765"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aff01208b1234556eb6b1ca14aad00765">&#9670;&nbsp;</a></span>makeTriangle() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcugl_1_1_poly2.html">Poly2</a> cugl::PolyFactory::makeTriangle </td>
          <td>(</td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>ax</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>ay</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>bx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>by</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>cx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>cy</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns a polygon that represents a simple triangle.</p>
<p>The polygon will be generated by the current geometry. Use <a class="el" href="classcugl_1_1_geometry.html#a5ad34fdd33aa23ffc0c374bf6f2d11b5ac6969385269556756b005c22b71a6e44">Geometry#SOLID</a> for a solid triangle and <a class="el" href="classcugl_1_1_geometry.html#a5ad34fdd33aa23ffc0c374bf6f2d11b5ab950bc5b35fc0869f451794889838a4b">Geometry#PATH</a> for an outline. Other geometries are supported as well, if necessary.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ax</td><td>The x-coordinate of the first vertex. </td></tr>
    <tr><td class="paramname">ay</td><td>The y-coordinate of the first vertex. </td></tr>
    <tr><td class="paramname">bx</td><td>The x-coordinate of the second vertex. </td></tr>
    <tr><td class="paramname">by</td><td>The y-coordinate of the second vertex. </td></tr>
    <tr><td class="paramname">cx</td><td>The x-coordinate of the third vertex. </td></tr>
    <tr><td class="paramname">cy</td><td>The y-coordinate of the third vertex.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a polygon that represents a simple triangle. </dd></dl>

</div>
</div>
<a id="a74839238c139a3d1bbdc2cc1d9325b51"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a74839238c139a3d1bbdc2cc1d9325b51">&#9670;&nbsp;</a></span>makeTriangle() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcugl_1_1_poly2.html">Poly2</a>* cugl::PolyFactory::makeTriangle </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classcugl_1_1_poly2.html">Poly2</a> *&#160;</td>
          <td class="paramname"><em>poly</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classcugl_1_1_vec2.html">Vec2</a>&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classcugl_1_1_vec2.html">Vec2</a>&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classcugl_1_1_vec2.html">Vec2</a>&#160;</td>
          <td class="paramname"><em>c</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Stores a simple triangle in the provided buffer.</p>
<p>The polygon will be generated by the current geometry. Use <a class="el" href="classcugl_1_1_geometry.html#a5ad34fdd33aa23ffc0c374bf6f2d11b5ac6969385269556756b005c22b71a6e44">Geometry#SOLID</a> for a solid triangle and <a class="el" href="classcugl_1_1_geometry.html#a5ad34fdd33aa23ffc0c374bf6f2d11b5ab950bc5b35fc0869f451794889838a4b">Geometry#PATH</a> for an outline. Other geometries are supported as well, if necessary.</p>
<p>The triangle will be appended to the buffer. You should clear the buffer first if you do not want to preserve the original data.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">poly</td><td>The polygon to store the result </td></tr>
    <tr><td class="paramname">a</td><td>The first vertex </td></tr>
    <tr><td class="paramname">b</td><td>The second vertex </td></tr>
    <tr><td class="paramname">c</td><td>The third vertex</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a reference to the buffer for chaining. </dd></dl>

</div>
</div>
<a id="a930eeeedbc34af7dba06d89e93a52f00"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a930eeeedbc34af7dba06d89e93a52f00">&#9670;&nbsp;</a></span>makeTriangle() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcugl_1_1_poly2.html">Poly2</a>* cugl::PolyFactory::makeTriangle </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classcugl_1_1_poly2.html">Poly2</a> *&#160;</td>
          <td class="paramname"><em>poly</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>ax</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>ay</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>bx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>by</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>cx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>cy</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Stores a simple triangle in the provided buffer.</p>
<p>The polygon will be generated by the current geometry. Use <a class="el" href="classcugl_1_1_geometry.html#a5ad34fdd33aa23ffc0c374bf6f2d11b5ac6969385269556756b005c22b71a6e44">Geometry#SOLID</a> for a solid triangle and <a class="el" href="classcugl_1_1_geometry.html#a5ad34fdd33aa23ffc0c374bf6f2d11b5ab950bc5b35fc0869f451794889838a4b">Geometry#PATH</a> for an outline. Other geometries are supported as well, if necessary.</p>
<p>The triangle will be appended to the buffer. You should clear the buffer first if you do not want to preserve the original data.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">poly</td><td>The polygon to store the result </td></tr>
    <tr><td class="paramname">ax</td><td>The x-coordinate of the first vertex </td></tr>
    <tr><td class="paramname">ay</td><td>The y-coordinate of the first vertex </td></tr>
    <tr><td class="paramname">bx</td><td>The x-coordinate of the second vertex </td></tr>
    <tr><td class="paramname">by</td><td>The y-coordinate of the second vertex </td></tr>
    <tr><td class="paramname">cx</td><td>The x-coordinate of the third vertex </td></tr>
    <tr><td class="paramname">cy</td><td>The y-coordinate of the third vertex</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a reference to the buffer for chaining. </dd></dl>

</div>
</div>
<a id="adce374f6fcdf881d0fef05070014fd06"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adce374f6fcdf881d0fef05070014fd06">&#9670;&nbsp;</a></span>setGeometry()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void cugl::PolyFactory::setGeometry </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classcugl_1_1_geometry.html">Geometry</a>&#160;</td>
          <td class="paramname"><em>geom</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Sets the current drawing geometry of this factory.</p>
<p>Changing this value will alter the geometry to be used in all future shapes created by this factory.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">geom</td><td>The current drawing geometry of this factory. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a0935480a336517a12e42b9bb67a8c470"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0935480a336517a12e42b9bb67a8c470">&#9670;&nbsp;</a></span>setSegments()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void cugl::PolyFactory::setSegments </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>segments</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Sets the number of segments to be used for rounded shapes.</p>
<p>Rounded shapes include <a class="el" href="classcugl_1_1_poly_factory.html#a8eaae575a4d94f50c83ac110c742c505">makeEllipse</a>, <a class="el" href="classcugl_1_1_poly_factory.html#af1c537dc976993804670ea37c39172e2">makeCircle</a>, <a class="el" href="classcugl_1_1_poly_factory.html#ae7f222a081401c48f3e92fa4a8704008">makeArc</a>, and <a class="el" href="classcugl_1_1_poly_factory.html#aec7cf770c905c240752d022d58961fd4">makeRoundedRect</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">segments</td><td>The number of segments to be used for rounded shapes. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>include/cugl/math/polygon/<a class="el" href="_c_u_poly_factory_8h_source.html">CUPolyFactory.h</a></li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.1
</small></address>
</body>
</html>
