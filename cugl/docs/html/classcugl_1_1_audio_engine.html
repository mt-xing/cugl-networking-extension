<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.9.1"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>CUGL 2.0: cugl::AudioEngine Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">CUGL 2.0
   </div>
   <div id="projectbrief">Cornell University Game Library</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.1 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search','.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespacecugl.html">cugl</a></li><li class="navelem"><a class="el" href="classcugl_1_1_audio_engine.html">AudioEngine</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-static-methods">Static Public Member Functions</a> &#124;
<a href="classcugl_1_1_audio_engine-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">cugl::AudioEngine Class Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p><code>#include &lt;<a class="el" href="_c_u_audio_engine_8h_source.html">CUAudioEngine.h</a>&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:ab7a0bed96dcdd48556aec331e4cb33dd"><td class="memItemLeft" align="right" valign="top">enum class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1_audio_engine.html#ab7a0bed96dcdd48556aec331e4cb33dd">State</a> { <a class="el" href="classcugl_1_1_audio_engine.html#ab7a0bed96dcdd48556aec331e4cb33dda6b273343c454f9c53dcfc9c4ccf171d2">INACTIVE</a>
, <a class="el" href="classcugl_1_1_audio_engine.html#ab7a0bed96dcdd48556aec331e4cb33dda50366a49630a416ab3ccaa004196027e">PLAYING</a>
, <a class="el" href="classcugl_1_1_audio_engine.html#ab7a0bed96dcdd48556aec331e4cb33dda99b2439e63f73ad515f7ab2447a80673">PAUSED</a>
 }</td></tr>
<tr class="separator:ab7a0bed96dcdd48556aec331e4cb33dd"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a91d5d4e571237cb0dacc93f4bd0c110e"><td class="memItemLeft" align="right" valign="top">std::shared_ptr&lt; <a class="el" href="classcugl_1_1_audio_queue.html">AudioQueue</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1_audio_engine.html#a91d5d4e571237cb0dacc93f4bd0c110e">getMusicQueue</a> () const</td></tr>
<tr class="separator:a91d5d4e571237cb0dacc93f4bd0c110e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa43c73557ad3b3dfb6007c5b8ad3b2be"><td class="memItemLeft" align="right" valign="top">std::shared_ptr&lt; <a class="el" href="classcugl_1_1_audio_queue.html">AudioQueue</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1_audio_engine.html#aa43c73557ad3b3dfb6007c5b8ad3b2be">allocQueue</a> ()</td></tr>
<tr class="separator:aa43c73557ad3b3dfb6007c5b8ad3b2be"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afa1c1c126dc47c6c359c9bae12fa11b1"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1_audio_engine.html#afa1c1c126dc47c6c359c9bae12fa11b1">freeQueue</a> (const std::shared_ptr&lt; <a class="el" href="classcugl_1_1_audio_queue.html">AudioQueue</a> &gt; &amp;queue)</td></tr>
<tr class="separator:afa1c1c126dc47c6c359c9bae12fa11b1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adde1c688da091af4d17ca67ff3b01384"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1_audio_engine.html#adde1c688da091af4d17ca67ff3b01384">play</a> (const std::string key, const std::shared_ptr&lt; <a class="el" href="classcugl_1_1_sound.html">Sound</a> &gt; &amp;sound, bool loop=false, float volume=1.0f, bool force=false)</td></tr>
<tr class="separator:adde1c688da091af4d17ca67ff3b01384"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a61ac0adb62b0718902428d314586ccee"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1_audio_engine.html#a61ac0adb62b0718902428d314586ccee">play</a> (const std::string key, const std::shared_ptr&lt; <a class="el" href="classcugl_1_1audio_1_1_audio_node.html">audio::AudioNode</a> &gt; &amp;graph, bool loop=false, float volume=1.0f, bool force=false)</td></tr>
<tr class="separator:a61ac0adb62b0718902428d314586ccee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2e1e9e5ce24c21ffad31b2e2dac70d3b"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1_audio_engine.html#a2e1e9e5ce24c21ffad31b2e2dac70d3b">getAvailableSlots</a> () const</td></tr>
<tr class="separator:a2e1e9e5ce24c21ffad31b2e2dac70d3b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9e8cdff642e8944c24294e028e0ab63f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classcugl_1_1_audio_engine.html#ab7a0bed96dcdd48556aec331e4cb33dd">State</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1_audio_engine.html#a9e8cdff642e8944c24294e028e0ab63f">getState</a> (const std::string key) const</td></tr>
<tr class="separator:a9e8cdff642e8944c24294e028e0ab63f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a365d2750a89bb2f947f44c38622a0b69"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1_audio_engine.html#a365d2750a89bb2f947f44c38622a0b69">isActive</a> (const std::string key) const</td></tr>
<tr class="separator:a365d2750a89bb2f947f44c38622a0b69"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab950c92a82d17d2bd2da046e0ef8a06e"><td class="memItemLeft" align="right" valign="top">const std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1_audio_engine.html#ab950c92a82d17d2bd2da046e0ef8a06e">getSource</a> (const std::string key) const</td></tr>
<tr class="separator:ab950c92a82d17d2bd2da046e0ef8a06e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa87b9d31bec935e59314f2734afde379"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1_audio_engine.html#aa87b9d31bec935e59314f2734afde379">isLoop</a> (const std::string key) const</td></tr>
<tr class="separator:aa87b9d31bec935e59314f2734afde379"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac1650efa536ff899e9a9cb8dc5d6f82c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1_audio_engine.html#ac1650efa536ff899e9a9cb8dc5d6f82c">setLoop</a> (const std::string key, bool loop)</td></tr>
<tr class="separator:ac1650efa536ff899e9a9cb8dc5d6f82c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a27fdc1f8a88c3f33f443081f92bdb2c6"><td class="memItemLeft" align="right" valign="top">float&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1_audio_engine.html#a27fdc1f8a88c3f33f443081f92bdb2c6">getVolume</a> (const std::string key) const</td></tr>
<tr class="separator:a27fdc1f8a88c3f33f443081f92bdb2c6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a96469a42752f486c845dacd0c5a23bde"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1_audio_engine.html#a96469a42752f486c845dacd0c5a23bde">setVolume</a> (const std::string key, float volume)</td></tr>
<tr class="separator:a96469a42752f486c845dacd0c5a23bde"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1545f9e8a111d6efa3fcbdb43a190dd6"><td class="memItemLeft" align="right" valign="top">float&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1_audio_engine.html#a1545f9e8a111d6efa3fcbdb43a190dd6">getPanFactor</a> (const std::string &amp;key) const</td></tr>
<tr class="separator:a1545f9e8a111d6efa3fcbdb43a190dd6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae7cd080b05843ba66fa515d7c1486fb2"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1_audio_engine.html#ae7cd080b05843ba66fa515d7c1486fb2">setPanFactor</a> (const std::string key, float pan)</td></tr>
<tr class="separator:ae7cd080b05843ba66fa515d7c1486fb2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afaca9724f1866f9dc03bd452b7555418"><td class="memItemLeft" align="right" valign="top">float&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1_audio_engine.html#afaca9724f1866f9dc03bd452b7555418">getDuration</a> (const std::string key) const</td></tr>
<tr class="separator:afaca9724f1866f9dc03bd452b7555418"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afd5cab21e8df62a29da09628ca3485f6"><td class="memItemLeft" align="right" valign="top">float&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1_audio_engine.html#afd5cab21e8df62a29da09628ca3485f6">getTimeElapsed</a> (const std::string key) const</td></tr>
<tr class="separator:afd5cab21e8df62a29da09628ca3485f6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4eafc8139cbf07cfd80949d4118beace"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1_audio_engine.html#a4eafc8139cbf07cfd80949d4118beace">setTimeElapsed</a> (const std::string key, float time)</td></tr>
<tr class="separator:a4eafc8139cbf07cfd80949d4118beace"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad01a913bd3bf2dccd93a5d4be2e817ac"><td class="memItemLeft" align="right" valign="top">float&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1_audio_engine.html#ad01a913bd3bf2dccd93a5d4be2e817ac">geTimeRemaining</a> (const std::string key) const</td></tr>
<tr class="separator:ad01a913bd3bf2dccd93a5d4be2e817ac"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa8873aa8e84b0ab91d1050e4a8499024"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1_audio_engine.html#aa8873aa8e84b0ab91d1050e4a8499024">setTimeRemaining</a> (const std::string key, float time)</td></tr>
<tr class="separator:aa8873aa8e84b0ab91d1050e4a8499024"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaeac6f738a7429447250b7d2bdebcb2e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1_audio_engine.html#aaeac6f738a7429447250b7d2bdebcb2e">clear</a> (const std::string key, float fade=0.015)</td></tr>
<tr class="separator:aaeac6f738a7429447250b7d2bdebcb2e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adb5c25b2d33bb6397a67aec53bfcff88"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1_audio_engine.html#adb5c25b2d33bb6397a67aec53bfcff88">pause</a> (const std::string key, float fade=0.015)</td></tr>
<tr class="separator:adb5c25b2d33bb6397a67aec53bfcff88"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af998ebc92da1da5c8c635209ad5fdcae"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1_audio_engine.html#af998ebc92da1da5c8c635209ad5fdcae">resume</a> (std::string key)</td></tr>
<tr class="separator:af998ebc92da1da5c8c635209ad5fdcae"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a87729f8bed783c3f028f7ec694f1b774"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1_audio_engine.html#a87729f8bed783c3f028f7ec694f1b774">setListener</a> (std::function&lt; void(const std::string key, bool)&gt; callback)</td></tr>
<tr class="separator:a87729f8bed783c3f028f7ec694f1b774"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a42bf3c774c64801d4456df207df24ddd"><td class="memItemLeft" align="right" valign="top">std::function&lt; void(const std::string key, bool)&gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1_audio_engine.html#a42bf3c774c64801d4456df207df24ddd">getListener</a> () const</td></tr>
<tr class="separator:a42bf3c774c64801d4456df207df24ddd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afc4b91419ff2dac08c5a82f587c1a657"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1_audio_engine.html#afc4b91419ff2dac08c5a82f587c1a657">clearEffects</a> (float fade=0.015)</td></tr>
<tr class="separator:afc4b91419ff2dac08c5a82f587c1a657"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a128195aecd284107347f9f300329d0a4"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1_audio_engine.html#a128195aecd284107347f9f300329d0a4">pauseEffects</a> (float fade=0.015)</td></tr>
<tr class="separator:a128195aecd284107347f9f300329d0a4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a511c306c574df889844e684b19b7d85a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1_audio_engine.html#a511c306c574df889844e684b19b7d85a">resumeEffects</a> ()</td></tr>
<tr class="separator:a511c306c574df889844e684b19b7d85a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af567c4bf4ce97f1ff1e06a8e46b435d9"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1_audio_engine.html#af567c4bf4ce97f1ff1e06a8e46b435d9">clear</a> (float fade=0.015)</td></tr>
<tr class="separator:af567c4bf4ce97f1ff1e06a8e46b435d9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac14e863854681ff614391274a5128852"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1_audio_engine.html#ac14e863854681ff614391274a5128852">pause</a> (float fade=0.015)</td></tr>
<tr class="separator:ac14e863854681ff614391274a5128852"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a909a8cf42ec6faf174030dd3658ce70c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1_audio_engine.html#a909a8cf42ec6faf174030dd3658ce70c">resume</a> ()</td></tr>
<tr class="separator:a909a8cf42ec6faf174030dd3658ce70c"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-static-methods"></a>
Static Public Member Functions</h2></td></tr>
<tr class="memitem:ad5bc2042539cec90fde2bd0be7908497"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classcugl_1_1_audio_engine.html">AudioEngine</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1_audio_engine.html#ad5bc2042539cec90fde2bd0be7908497">get</a> ()</td></tr>
<tr class="separator:ad5bc2042539cec90fde2bd0be7908497"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afe0fee037845391b028e30360c03e625"><td class="memItemLeft" align="right" valign="top">static bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1_audio_engine.html#afe0fee037845391b028e30360c03e625">start</a> (Uint32 slots=16)</td></tr>
<tr class="separator:afe0fee037845391b028e30360c03e625"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab90cf28e600755733b1972a41323a676"><td class="memItemLeft" align="right" valign="top">static bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1_audio_engine.html#ab90cf28e600755733b1972a41323a676">start</a> (const std::shared_ptr&lt; <a class="el" href="classcugl_1_1audio_1_1_audio_output.html">audio::AudioOutput</a> &gt; &amp;device, Uint32 slots=16)</td></tr>
<tr class="separator:ab90cf28e600755733b1972a41323a676"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a90aae31c746312abed902de2f1d5d8b7"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1_audio_engine.html#a90aae31c746312abed902de2f1d5d8b7">stop</a> ()</td></tr>
<tr class="separator:a90aae31c746312abed902de2f1d5d8b7"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Class provides a singleton audio engine</p>
<p>This module is an attempt to combine the power of a modern DSP mixer graph with a simple 2000-era interface. Like the legacy engines, it provides a a flat slot-based structure for playing sounds, and controlling the fade and pan of each slot. However, you are not limited to playing samples in the slots. You can also add arbitrary audio nodes as well.</p>
<p>This class is primarily designed for the playing of sound effects. These are short sound effects that are often happening in parallel. The engine has a fixed number of slots for these sounds (historically 24) and it can only play as many sounds simultaneously as it has slots. Slots are assigned automatically by the engine. However, when you play an effect, you must assign it a unique key so that you can access it later (for volume changes, panning, early termination, etc.). This key eliminates any need for tracking the slot assigned to an effect.</p>
<p>Music is treated separately because seamless playback requires the ability to queue up audio assets in order. As a result, this is supported through the <a class="el" href="classcugl_1_1_audio_queue.html">AudioQueue</a> interface. However, queues are owned by and acquired from this engine. There is always one music queue available, though you do have the ability to acquire more.</p>
<p>You cannot create new instances of this class. Instead, you should access the singleton through the three static methods: <a class="el" href="classcugl_1_1_audio_engine.html#afe0fee037845391b028e30360c03e625">start()</a>, <a class="el" href="classcugl_1_1_audio_engine.html#a90aae31c746312abed902de2f1d5d8b7">stop()</a>, and <a class="el" href="classcugl_1_1_audio_engine.html#ad5bc2042539cec90fde2bd0be7908497">get()</a>. Calling these methods will initialize the <a class="el" href="classcugl_1_1_audio_devices.html">AudioDevices</a> singleton, if it is not already initialized.</p>
<p>IMPORTANT: Like the OpenGL context, this class is not thread-safe. It is only safe to access this class in the main application thread. This means it should never be called in a call-back function as those are typically executed in the host thread. If you need to access the <a class="el" href="classcugl_1_1_audio_engine.html">AudioEngine</a> in a callback function, you should use the <a class="el" href="classcugl_1_1_application.html#a3b277c28091afb74571dee5723fa78d8">Application#schedule</a> method to delay until the main thread is next available. </p>
</div><h2 class="groupheader">Member Enumeration Documentation</h2>
<a id="ab7a0bed96dcdd48556aec331e4cb33dd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab7a0bed96dcdd48556aec331e4cb33dd">&#9670;&nbsp;</a></span>State</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="classcugl_1_1_audio_engine.html#ab7a0bed96dcdd48556aec331e4cb33dd">cugl::AudioEngine::State</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">strong</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>This enumeration provides a way to determine the state of a slot </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="ab7a0bed96dcdd48556aec331e4cb33dda6b273343c454f9c53dcfc9c4ccf171d2"></a>INACTIVE&#160;</td><td class="fielddoc"><p>This sound channel is not actually active </p>
</td></tr>
<tr><td class="fieldname"><a id="ab7a0bed96dcdd48556aec331e4cb33dda50366a49630a416ab3ccaa004196027e"></a>PLAYING&#160;</td><td class="fielddoc"><p>This sound is active and currently playing </p>
</td></tr>
<tr><td class="fieldname"><a id="ab7a0bed96dcdd48556aec331e4cb33dda99b2439e63f73ad515f7ab2447a80673"></a>PAUSED&#160;</td><td class="fielddoc"><p>This sound is active but is currently paused </p>
</td></tr>
</table>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="aa43c73557ad3b3dfb6007c5b8ad3b2be"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa43c73557ad3b3dfb6007c5b8ad3b2be">&#9670;&nbsp;</a></span>allocQueue()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::shared_ptr&lt;<a class="el" href="classcugl_1_1_audio_queue.html">AudioQueue</a>&gt; cugl::AudioEngine::allocQueue </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Allocates a new queue for managing audio.</p>
<p>Music is handled differently from sound effects. You can only play one music asset at a time. However, it is possible to queue music assets for immediate playback once the active asset is finished. Proper queue management is the keep for smooth, uninterrupted playback that responds to the user's actions.</p>
<p>This method allocates a secondary music queue that can be played in tandem with the primary music queue. This allows for slightly more complex music mixing. However, for true vertical layering, you should use <a class="el" href="classcugl_1_1audio_1_1_audio_mixer.html">audio::AudioMixer</a>.</p>
<p>It is the programmer's responsibility to free all secondary music queues with <a class="el" href="classcugl_1_1_audio_engine.html#afa1c1c126dc47c6c359c9bae12fa11b1">freeQueue</a>. However, all queues are automatically freed when this audio engine is stopped.</p>
<p>Calling this method will briefly pause the audio engine, if it is actively playing.</p>
<dl class="section return"><dt>Returns</dt><dd>a newly allocated audio queue </dd></dl>

</div>
</div>
<a id="aaeac6f738a7429447250b7d2bdebcb2e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaeac6f738a7429447250b7d2bdebcb2e">&#9670;&nbsp;</a></span>clear() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void cugl::AudioEngine::clear </td>
          <td>(</td>
          <td class="paramtype">const std::string&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>fade</em> = <code>0.015</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Removes the sound effect for the given key, stopping it immediately</p>
<p>The effect will be removed from the audio engine entirely. You will need to add it again if you wish to replay it.</p>
<p>Before the effect is stopped, this method gives the user an option to fade out the effect. If the argument is 0, it will halt the sound immediately. Otherwise it will fade to completion over the given number of seconds (or until the end of the effect). Only by fading can you guarantee no audible clicks.</p>
<p>If the key does not correspond to an active sound effect, this method does nothing.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">key</td><td>the reference key for the sound effect </td></tr>
    <tr><td class="paramname">fade</td><td>the number of seconds to fade out </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="af567c4bf4ce97f1ff1e06a8e46b435d9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af567c4bf4ce97f1ff1e06a8e46b435d9">&#9670;&nbsp;</a></span>clear() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void cugl::AudioEngine::clear </td>
          <td>(</td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>fade</em> = <code>0.015</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Clears all active playing sounds, both music and sound effects.</p>
<p>Before the sounds are stopped, this method gives the user an option to fade out the effect. If the argument is 0, it will halt all sounds immediately. Otherwise it will fade the to completion over the given number of seconds (or until the end of the effect). Only by fading can you guarantee no audible clicks.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">fade</td><td>the number of seconds to fade out </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="afc4b91419ff2dac08c5a82f587c1a657"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afc4b91419ff2dac08c5a82f587c1a657">&#9670;&nbsp;</a></span>clearEffects()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void cugl::AudioEngine::clearEffects </td>
          <td>(</td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>fade</em> = <code>0.015</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Removes all sound effects from the engine, stopping them immediately.</p>
<p>Before the effects are stopped, this method gives the user an option to fade out the effect. If the argument is 0, it will halt all effects immediately. Otherwise it will fade the to completion over the given number of seconds (or until the end of the effect). Only by fading can you guarantee no audible clicks.</p>
<p>You will need to add the effects again if you wish to replay them. This method has no effect on the music queues.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">fade</td><td>the number of seconds to fade out </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="afa1c1c126dc47c6c359c9bae12fa11b1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afa1c1c126dc47c6c359c9bae12fa11b1">&#9670;&nbsp;</a></span>freeQueue()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void cugl::AudioEngine::freeQueue </td>
          <td>(</td>
          <td class="paramtype">const std::shared_ptr&lt; <a class="el" href="classcugl_1_1_audio_queue.html">AudioQueue</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>queue</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Frees a previously allocated audio queue.</p>
<p>This method should be called to free any audio queue created by <a class="el" href="classcugl_1_1_audio_engine.html#aa43c73557ad3b3dfb6007c5b8ad3b2be">allocQueue</a>. It is the programmer's responsibility to free all secondary music queues. However, all queues are automatically freed when this audio engine is stopped.</p>
<p>This method cannot be used to free the default music queue.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">queue</td><td>The audio queue to free </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ad5bc2042539cec90fde2bd0be7908497"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad5bc2042539cec90fde2bd0be7908497">&#9670;&nbsp;</a></span>get()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="classcugl_1_1_audio_engine.html">AudioEngine</a>* cugl::AudioEngine::get </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns the singleton instance of the audio engine.</p>
<p>If the audio engine has not been started, then this method will return nullptr.</p>
<dl class="section return"><dt>Returns</dt><dd>the singleton instance of the audio engine. </dd></dl>

</div>
</div>
<a id="a2e1e9e5ce24c21ffad31b2e2dac70d3b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2e1e9e5ce24c21ffad31b2e2dac70d3b">&#9670;&nbsp;</a></span>getAvailableSlots()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_t cugl::AudioEngine::getAvailableSlots </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns the number of slots available for sound effects.</p>
<p>There are a limited number of slots available for sound effects. If all slots are in use, this method will return 0. If you go over the number available, you cannot play another sound unless you force it. In that case, it will grab the slot from the longest playing sound effect.</p>
<dl class="section return"><dt>Returns</dt><dd>the number of slots available for sound effects. </dd></dl>

</div>
</div>
<a id="afaca9724f1866f9dc03bd452b7555418"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afaca9724f1866f9dc03bd452b7555418">&#9670;&nbsp;</a></span>getDuration()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">float cugl::AudioEngine::getDuration </td>
          <td>(</td>
          <td class="paramtype">const std::string&#160;</td>
          <td class="paramname"><em>key</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns the duration of the sound effect, in seconds.</p>
<p>Because most sound effects are fully decompressed at load time, the result of this method is reasonably accurate.</p>
<p>If the key does not correspond to an active sound effect, this method returns -1.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">key</td><td>the reference key for the sound effect</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the duration of the sound effect, in seconds. </dd></dl>

</div>
</div>
<a id="ad01a913bd3bf2dccd93a5d4be2e817ac"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad01a913bd3bf2dccd93a5d4be2e817ac">&#9670;&nbsp;</a></span>geTimeRemaining()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">float cugl::AudioEngine::geTimeRemaining </td>
          <td>(</td>
          <td class="paramtype">const std::string&#160;</td>
          <td class="paramname"><em>key</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns the time remaining for the sound effect, in seconds</p>
<p>The time remaining is just duration-elapsed. This method does not take into account whether the sound is on a loop. Because most sound effects are fully decompressed at load time, the result of this method is reasonably accurate, though it is affected by device latency.</p>
<p>If the key does not correspond to an active sound effect, or if the sound effect is an audio node with undefined duration, this method method returns -1.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">key</td><td>the reference key for the sound effect</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the time remaining for the sound effect, in seconds </dd></dl>

</div>
</div>
<a id="a42bf3c774c64801d4456df207df24ddd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a42bf3c774c64801d4456df207df24ddd">&#9670;&nbsp;</a></span>getListener()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::function&lt;void(const std::string key,bool)&gt; cugl::AudioEngine::getListener </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns the callback for sound effects</p>
<p>This callback function is called whenever a sound effect completes. It is called whether or not the sound completed normally or if it was terminated manually. However, the second parameter can be used to distinguish the two cases.</p>
<dl class="section return"><dt>Returns</dt><dd>the callback for sound effects </dd></dl>

</div>
</div>
<a id="a91d5d4e571237cb0dacc93f4bd0c110e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a91d5d4e571237cb0dacc93f4bd0c110e">&#9670;&nbsp;</a></span>getMusicQueue()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::shared_ptr&lt;<a class="el" href="classcugl_1_1_audio_queue.html">AudioQueue</a>&gt; cugl::AudioEngine::getMusicQueue </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns the default music queue for this audio engine</p>
<p>Music is managed through audio queues.The audio engine has one by default, though you can allocate more with <a class="el" href="classcugl_1_1_audio_engine.html#aa43c73557ad3b3dfb6007c5b8ad3b2be">allocQueue</a>.</p>
<p>Music is handled differently from sound effects. You can only play one music asset at a time. However, it is possible to queue music assets for immediate playback once the active asset is finished. Proper queue management is the keep for smooth, uninterrupted playback that responds to the user's actions. </p>

</div>
</div>
<a id="a1545f9e8a111d6efa3fcbdb43a190dd6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1545f9e8a111d6efa3fcbdb43a190dd6">&#9670;&nbsp;</a></span>getPanFactor()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">float cugl::AudioEngine::getPanFactor </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>key</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns the stereo pan of the sound effect.</p>
<p>This audio engine provides limited (e.g. not full 3D) stereo panning for simple effects. The pan value is a float from -1 to 1. A value of 0 (default) plays to both channels (regardless of whether the current effect is mono or stereo). A value of -1 will play to the left channel only, while the right will play to the right channel only. Channels beyond the first two are unaffected.</p>
<p>In the case of stereo assets, panning to the left or right will mix the audio feed; this process will never lose audio.</p>
<p>If the key does not correspond to an active sound effect, this method returns 0.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">key</td><td>the reference key for the sound effect</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the stereo pan of the sound effect </dd></dl>

</div>
</div>
<a id="ab950c92a82d17d2bd2da046e0ef8a06e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab950c92a82d17d2bd2da046e0ef8a06e">&#9670;&nbsp;</a></span>getSource()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const std::string cugl::AudioEngine::getSource </td>
          <td>(</td>
          <td class="paramtype">const std::string&#160;</td>
          <td class="paramname"><em>key</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns the identifier for the asset attached to the given key.</p>
<p>If the current playing track is an <a class="el" href="classcugl_1_1_sound.html">Sound</a> asset, then the identifier is the file name. Otherwise, it is the name of the root of the audio graph. See <a class="el" href="classcugl_1_1audio_1_1_audio_node.html#aeba6f7fbd240123159850cbb499df941">audio::AudioNode#getName</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">key</td><td>the reference key for the sound effect</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the identifier for the asset attached to the given key. </dd></dl>

</div>
</div>
<a id="a9e8cdff642e8944c24294e028e0ab63f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9e8cdff642e8944c24294e028e0ab63f">&#9670;&nbsp;</a></span>getState()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcugl_1_1_audio_engine.html#ab7a0bed96dcdd48556aec331e4cb33dd">State</a> cugl::AudioEngine::getState </td>
          <td>(</td>
          <td class="paramtype">const std::string&#160;</td>
          <td class="paramname"><em>key</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns the current state of the sound effect for the given key.</p>
<p>If there is no sound effect for the given key, it returns <a class="el" href="classcugl_1_1_audio_engine.html#ab7a0bed96dcdd48556aec331e4cb33dda6b273343c454f9c53dcfc9c4ccf171d2">State::INACTIVE</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">key</td><td>the reference key for the sound effect</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the current state of the sound effect for the given key. </dd></dl>

</div>
</div>
<a id="afd5cab21e8df62a29da09628ca3485f6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afd5cab21e8df62a29da09628ca3485f6">&#9670;&nbsp;</a></span>getTimeElapsed()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">float cugl::AudioEngine::getTimeElapsed </td>
          <td>(</td>
          <td class="paramtype">const std::string&#160;</td>
          <td class="paramname"><em>key</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns the elapsed time of the sound effect, in seconds</p>
<p>The elapsed time is the current position of the sound from the beginning. It does not include any time spent on a continuous loop. Because most sound effects are fully decompressed at load time, the result of this method is reasonably accurate, though it is affected by device latency.</p>
<p>If the key does not correspond to an active sound effect, or if the sound effect is an audio node with undefined duration, this method returns -1.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">key</td><td>the reference key for the sound effect</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the elapsed time of the sound effect, in seconds </dd></dl>

</div>
</div>
<a id="a27fdc1f8a88c3f33f443081f92bdb2c6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a27fdc1f8a88c3f33f443081f92bdb2c6">&#9670;&nbsp;</a></span>getVolume()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">float cugl::AudioEngine::getVolume </td>
          <td>(</td>
          <td class="paramtype">const std::string&#160;</td>
          <td class="paramname"><em>key</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns the current volume of the sound effect.</p>
<p>The volume is a value 0 to 1, where 1 is maximum volume and 0 is complete silence. If the key does not correspond to an active sound effect, this method returns 0.</p>
<p>Note that this is the playback volume. If the asset or audio graph had its own initial volume setting, this is independent of this setting. Indeed, this value can be though of as the percentage of the default volume.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">key</td><td>the reference key for the sound effect</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the current volume of the sound effect </dd></dl>

</div>
</div>
<a id="a365d2750a89bb2f947f44c38622a0b69"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a365d2750a89bb2f947f44c38622a0b69">&#9670;&nbsp;</a></span>isActive()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool cugl::AudioEngine::isActive </td>
          <td>(</td>
          <td class="paramtype">const std::string&#160;</td>
          <td class="paramname"><em>key</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns true if the key is associated with an active sound.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">key</td><td>the reference key for the sound effect</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if the key is associated with an active sound. </dd></dl>

</div>
</div>
<a id="aa87b9d31bec935e59314f2734afde379"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa87b9d31bec935e59314f2734afde379">&#9670;&nbsp;</a></span>isLoop()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool cugl::AudioEngine::isLoop </td>
          <td>(</td>
          <td class="paramtype">const std::string&#160;</td>
          <td class="paramname"><em>key</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns true if the sound effect is in a continuous loop.</p>
<p>If the key does not correspond to an active sound effect, this method returns false.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">key</td><td>the reference key for the sound effect</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if the sound effect is in a continuous loop. </dd></dl>

</div>
</div>
<a id="adb5c25b2d33bb6397a67aec53bfcff88"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adb5c25b2d33bb6397a67aec53bfcff88">&#9670;&nbsp;</a></span>pause() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void cugl::AudioEngine::pause </td>
          <td>(</td>
          <td class="paramtype">const std::string&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>fade</em> = <code>0.015</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Pauses the sound effect for the given key.</p>
<p>Before the effect is paused, this method gives the user an option to fade out the effect. If the argument is 0, it will pause the sound immediately. Otherwise it will fade to completion over the given number of seconds (or until the end of the effect). Only by fading can you guarantee no audible clicks.</p>
<p>If the key does not correspond to an active sound effect, this method does nothing.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">key</td><td>the reference key for the sound effect </td></tr>
    <tr><td class="paramname">fade</td><td>the number of seconds to fade out </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ac14e863854681ff614391274a5128852"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac14e863854681ff614391274a5128852">&#9670;&nbsp;</a></span>pause() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void cugl::AudioEngine::pause </td>
          <td>(</td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>fade</em> = <code>0.015</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Pauses all sounds, both music and sound effects.</p>
<p>Before the sounds are paused, this method gives the user an option to fade out everything. If the argument is 0, it will pause the sounds immediately. Otherwise it will fade everythign to completion over the given number of seconds (or until the end of each sound). Only by fading can you guarantee no audible clicks.</p>
<p>This method allows them to be resumed later. You should generally call this method just before the app pages to the background.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">fade</td><td>the number of seconds to fade out </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a128195aecd284107347f9f300329d0a4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a128195aecd284107347f9f300329d0a4">&#9670;&nbsp;</a></span>pauseEffects()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void cugl::AudioEngine::pauseEffects </td>
          <td>(</td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>fade</em> = <code>0.015</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Pauses all sound effects, allowing them to be resumed later.</p>
<p>Before the effects are paused, this method gives the user an option to fade out the effect. If the argument is 0, it will pause all effects immediately. Otherwise it will fade the to completion over the given number of seconds (or until the end of the effect). Only by fading can you guarantee no audible clicks.</p>
<p><a class="el" href="classcugl_1_1_sound.html">Sound</a> effects already paused will remain paused. This method has no effect on the music queues.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">fade</td><td>the number of seconds to fade out </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a61ac0adb62b0718902428d314586ccee"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a61ac0adb62b0718902428d314586ccee">&#9670;&nbsp;</a></span>play() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool cugl::AudioEngine::play </td>
          <td>(</td>
          <td class="paramtype">const std::string&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::shared_ptr&lt; <a class="el" href="classcugl_1_1audio_1_1_audio_node.html">audio::AudioNode</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>graph</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>loop</em> = <code>false</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>volume</em> = <code>1.0f</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>force</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Plays the given audio node, and associates it with the specified key.</p>
<p>This alternate version of play allows the programmer to construct custom composite audio graphs and play them as sound effects. Looping behavior is supported if the audio node has a finite duration.</p>
<p>As with traditional sounds, the audio node is assigned a key to allow the application to easily reference the sound state without having to internally manage pointers to the audio channel. In particular, if the audio node provided does not have a fixed duration, and can be played indefinitely, then the key must be used to stop the sound.</p>
<p>If the key is already associated with an active sound effect, this method will stop the existing sound and replace it with this one. It is the responsibility of the application layer to manage key usage.</p>
<p>There are a limited number of slots available for sounds. If you go over the number available, the sound will not play unless <code>force</code> is true. In that case, it will grab the channel from the longest playing sound effect.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">key</td><td>The reference key for the sound effect </td></tr>
    <tr><td class="paramname">graph</td><td>The audio graph to play </td></tr>
    <tr><td class="paramname">loop</td><td>Whether to loop the sound effect continuously </td></tr>
    <tr><td class="paramname">volume</td><td>The music volume (relative to the default instance volume) </td></tr>
    <tr><td class="paramname">force</td><td>Whether to force another sound to stop.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if there was an available channel for the sound </dd></dl>

</div>
</div>
<a id="adde1c688da091af4d17ca67ff3b01384"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adde1c688da091af4d17ca67ff3b01384">&#9670;&nbsp;</a></span>play() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool cugl::AudioEngine::play </td>
          <td>(</td>
          <td class="paramtype">const std::string&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::shared_ptr&lt; <a class="el" href="classcugl_1_1_sound.html">Sound</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>sound</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>loop</em> = <code>false</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>volume</em> = <code>1.0f</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>force</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Plays the given sound, and associates it with the specified key.</p>
<p>Sounds are associated with a reference key. This allows the application to easily reference the sound state without having to internally manage pointers to the audio channel.</p>
<p>If the key is already associated with an active sound effect, this method will stop the existing sound and replace it with this one. It is the responsibility of the application layer to manage key usage.</p>
<p>There are a limited number of slots available for sounds. If you go over the number available, the sound will not play unless <code>force</code> is true. In that case, it will grab the channel from the longest playing sound effect.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">key</td><td>The reference key for the sound effect </td></tr>
    <tr><td class="paramname">sound</td><td>The sound effect to play </td></tr>
    <tr><td class="paramname">loop</td><td>Whether to loop the sound effect continuously </td></tr>
    <tr><td class="paramname">volume</td><td>The music volume (relative to the default asset volume) </td></tr>
    <tr><td class="paramname">force</td><td>Whether to force another sound to stop.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if there was an available channel for the sound </dd></dl>

</div>
</div>
<a id="a909a8cf42ec6faf174030dd3658ce70c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a909a8cf42ec6faf174030dd3658ce70c">&#9670;&nbsp;</a></span>resume() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void cugl::AudioEngine::resume </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Resumes all paused sounds, both music and sound effects.</p>
<p>You should generally call this method right after the app returns from the background. </p>

</div>
</div>
<a id="af998ebc92da1da5c8c635209ad5fdcae"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af998ebc92da1da5c8c635209ad5fdcae">&#9670;&nbsp;</a></span>resume() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void cugl::AudioEngine::resume </td>
          <td>(</td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>key</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Resumes the sound effect for the given key.</p>
<p>If the key does not correspond to a channel, this method does nothing.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">key</td><td>the reference key for the sound effect </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a511c306c574df889844e684b19b7d85a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a511c306c574df889844e684b19b7d85a">&#9670;&nbsp;</a></span>resumeEffects()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void cugl::AudioEngine::resumeEffects </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Resumes all paused sound effects.</p>
<p>This method has no effect on the music queues. </p>

</div>
</div>
<a id="a87729f8bed783c3f028f7ec694f1b774"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a87729f8bed783c3f028f7ec694f1b774">&#9670;&nbsp;</a></span>setListener()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void cugl::AudioEngine::setListener </td>
          <td>(</td>
          <td class="paramtype">std::function&lt; void(const std::string key, bool)&gt;&#160;</td>
          <td class="paramname"><em>callback</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Sets the callback for sound effects</p>
<p>This callback function is called whenever a sound effect completes. It is called whether or not the sound completed normally or if it was terminated manually. However, the second parameter can be used to distinguish the two cases.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">callback</td><td>The callback for sound effects </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ac1650efa536ff899e9a9cb8dc5d6f82c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac1650efa536ff899e9a9cb8dc5d6f82c">&#9670;&nbsp;</a></span>setLoop()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void cugl::AudioEngine::setLoop </td>
          <td>(</td>
          <td class="paramtype">const std::string&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>loop</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Sets whether the sound effect is in a continuous loop.</p>
<p>If the key does not correspond to an active sound effect, this method does nothing.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">key</td><td>the reference key for the sound effect </td></tr>
    <tr><td class="paramname">loop</td><td>whether the sound effect is in a continuous loop </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ae7cd080b05843ba66fa515d7c1486fb2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae7cd080b05843ba66fa515d7c1486fb2">&#9670;&nbsp;</a></span>setPanFactor()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void cugl::AudioEngine::setPanFactor </td>
          <td>(</td>
          <td class="paramtype">const std::string&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>pan</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns the stereo pan of the sound effect.</p>
<p>This audio engine provides limited (e.g. not full 3D) stereo panning for simple effects. The pan value is a float from -1 to 1. A value of 0 (default) plays to both channels (regardless of whether the current effect is mono or stereo). A value of -1 will play to the left channel only, while the right will play to the right channel only. Channels beyond the first two are unaffected.</p>
<p>In the case of stereo assets, panning to the left or right will mix the audio feed; this process will never lose audio.</p>
<p>If the key does not correspond to an active sound effect, this method does nothing.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">key</td><td>the reference key for the sound effect </td></tr>
    <tr><td class="paramname">pan</td><td>the stereo pan of the sound effect </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a4eafc8139cbf07cfd80949d4118beace"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4eafc8139cbf07cfd80949d4118beace">&#9670;&nbsp;</a></span>setTimeElapsed()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void cugl::AudioEngine::setTimeElapsed </td>
          <td>(</td>
          <td class="paramtype">const std::string&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>time</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Sets the elapsed time of the sound effect, in seconds</p>
<p>The elapsed time is the current position of the sound from the beginning. It does not include any time spent on a continuous loop. Because most sound effects are fully decompressed at load time, the result of this method is reasonably accurate, though it is affected by device latency.</p>
<p>If the key does not correspond to an active sound effect, or if the sound effect is an audio node with undefined duration, this method does nothing.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">key</td><td>the reference key for the sound effect </td></tr>
    <tr><td class="paramname">time</td><td>the new position of the sound effect </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aa8873aa8e84b0ab91d1050e4a8499024"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa8873aa8e84b0ab91d1050e4a8499024">&#9670;&nbsp;</a></span>setTimeRemaining()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void cugl::AudioEngine::setTimeRemaining </td>
          <td>(</td>
          <td class="paramtype">const std::string&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>time</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Sets the time remaining for the sound effect, in seconds</p>
<p>The time remaining is just duration-elapsed. This method does not take into account whether the sound is on a loop. Because most sound effects are fully decompressed at load time, the result of this method is reasonably accurate, though it is affected by device latency.</p>
<p>If the key does not correspond to an active sound effect, or if the sound effect is an audio node with undefined duration, this method does nothing.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">key</td><td>the reference key for the sound effect </td></tr>
    <tr><td class="paramname">time</td><td>the new time remaining for the sound effect </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a96469a42752f486c845dacd0c5a23bde"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a96469a42752f486c845dacd0c5a23bde">&#9670;&nbsp;</a></span>setVolume()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void cugl::AudioEngine::setVolume </td>
          <td>(</td>
          <td class="paramtype">const std::string&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>volume</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Sets the current volume of the sound effect.</p>
<p>The volume is a value 0 to 1, where 1 is maximum volume and 0 is complete silence. If the key does not correspond to an active sound effect, this method does nothing.</p>
<p>Note that this is the playback volume. If the asset or audio graph had its own initial volume setting, this is independent of this setting. Indeed, this value can be though of as the percentage of the default volume.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">key</td><td>the reference key for the sound effect </td></tr>
    <tr><td class="paramname">volume</td><td>the current volume of the sound effect </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ab90cf28e600755733b1972a41323a676"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab90cf28e600755733b1972a41323a676">&#9670;&nbsp;</a></span>start() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static bool cugl::AudioEngine::start </td>
          <td>(</td>
          <td class="paramtype">const std::shared_ptr&lt; <a class="el" href="classcugl_1_1audio_1_1_audio_output.html">audio::AudioOutput</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>device</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Uint32&#160;</td>
          <td class="paramname"><em>slots</em> = <code>16</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Starts the singleton audio engine on the given audio device.</p>
<p>Once this method is called, the method <a class="el" href="classcugl_1_1_audio_engine.html#ad5bc2042539cec90fde2bd0be7908497">get()</a> will no longer return nullptr. Calling the method multiple times (without calling stop) will have no effect.</p>
<p>This version of the method assumes that the programmer has already started the <a class="el" href="classcugl_1_1_audio_devices.html">AudioDevices</a> manager. It will not restart the manager, nor will it shutdown the audio manager when done. This version of the initializer is only for programmers that need lower-level control over buffer size and sampling rate.</p>
<p>The parameter <code>slots</code> indicates the number of simultaneously supported sounds. Attempting to play more than this number of sounds may fail, it may eject a previously playing sound, depending on the settings. The default number of slots is 16.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">device</td><td>The audio device to use for this engine </td></tr>
    <tr><td class="paramname">slots</td><td>The maximum number of sound slots to support</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if the engine was successfully initialized </dd></dl>

</div>
</div>
<a id="afe0fee037845391b028e30360c03e625"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afe0fee037845391b028e30360c03e625">&#9670;&nbsp;</a></span>start() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static bool cugl::AudioEngine::start </td>
          <td>(</td>
          <td class="paramtype">Uint32&#160;</td>
          <td class="paramname"><em>slots</em> = <code>16</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Starts the singleton audio engine on the default audio device.</p>
<p>Once this method is called, the method <a class="el" href="classcugl_1_1_audio_engine.html#ad5bc2042539cec90fde2bd0be7908497">get()</a> will no longer return nullptr. Calling the method multiple times (without calling stop) will have no effect.</p>
<p>This convenience method will start up the <a class="el" href="classcugl_1_1_audio_devices.html">AudioDevices</a> manager, and take responsibility for shutting it down when done. As a result, it will fail if the audio device manager is already active or cannot be initialized. If you need more control of the audio devices (such as to change the audio sampling rate or the buffer size), you should use start the engine with a specific output device.</p>
<p>The engine initialized by this method has a uniform sampling rate of 48000 Hz. This is the standard rate for phone games. However, keep in mind that CD audio is typically sampled at 44100 Hz.</p>
<p>The parameter <code>slots</code> indicates the number of simultaneously supported sounds. Attempting to play more than this number of sounds may fail, it may eject a previously playing sound, depending on the settings. The default number of slots is 16.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">slots</td><td>The maximum number of sound slots to support</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if the engine was successfully initialized </dd></dl>

</div>
</div>
<a id="a90aae31c746312abed902de2f1d5d8b7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a90aae31c746312abed902de2f1d5d8b7">&#9670;&nbsp;</a></span>stop()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void cugl::AudioEngine::stop </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Shutsdown the singleton audio engine, releasing all resources.</p>
<p>Once this method is called, the method <a class="el" href="classcugl_1_1_audio_engine.html#ad5bc2042539cec90fde2bd0be7908497">get()</a> will return nullptr. Calling the method multiple times (without calling stop) will have no effect.</p>
<p>If the engine was started with the convenience method <a class="el" href="classcugl_1_1_audio_engine.html#afe0fee037845391b028e30360c03e625">start(Uint32)</a>, then this method will also stop the <a class="el" href="classcugl_1_1_audio_devices.html">AudioDevices</a> manager. Otherwise, it is the responsibility of the programmer to shutdown the device manager. </p>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>include/cugl/audio/<a class="el" href="_c_u_audio_engine_8h_source.html">CUAudioEngine.h</a></li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.1
</small></address>
</body>
</html>
