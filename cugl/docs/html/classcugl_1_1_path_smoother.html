<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.9.1"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>CUGL 2.0: cugl::PathSmoother Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">CUGL 2.0
   </div>
   <div id="projectbrief">Cornell University Game Library</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.1 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search','.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespacecugl.html">cugl</a></li><li class="navelem"><a class="el" href="classcugl_1_1_path_smoother.html">PathSmoother</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="classcugl_1_1_path_smoother-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">cugl::PathSmoother Class Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p><code>#include &lt;<a class="el" href="_c_u_path_smoother_8h_source.html">CUPathSmoother.h</a>&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:af4632cc8d422428c145f7c4d35bf5a14"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1_path_smoother.html#af4632cc8d422428c145f7c4d35bf5a14">PathSmoother</a> ()</td></tr>
<tr class="separator:af4632cc8d422428c145f7c4d35bf5a14"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a59e14a5f14aeed0dfdd31c024463a75a"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1_path_smoother.html#a59e14a5f14aeed0dfdd31c024463a75a">PathSmoother</a> (const std::vector&lt; <a class="el" href="classcugl_1_1_vec2.html">Vec2</a> &gt; &amp;points)</td></tr>
<tr class="separator:a59e14a5f14aeed0dfdd31c024463a75a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a02c8d1e3adf4357d08d01e9657101bcc"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1_path_smoother.html#a02c8d1e3adf4357d08d01e9657101bcc">~PathSmoother</a> ()</td></tr>
<tr class="separator:a02c8d1e3adf4357d08d01e9657101bcc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa213afdd902707f2f3543fe84a6ad8f0"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1_path_smoother.html#aa213afdd902707f2f3543fe84a6ad8f0">set</a> (const std::vector&lt; <a class="el" href="classcugl_1_1_vec2.html">Vec2</a> &gt; &amp;points)</td></tr>
<tr class="separator:aa213afdd902707f2f3543fe84a6ad8f0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a85cc50acc9a53b3efb3b863009f8f1e3"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1_path_smoother.html#a85cc50acc9a53b3efb3b863009f8f1e3">setEpsilon</a> (float epsilon)</td></tr>
<tr class="separator:a85cc50acc9a53b3efb3b863009f8f1e3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ada29cf411cec2430ab4ac0bd09a31f4d"><td class="memItemLeft" align="right" valign="top">float&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1_path_smoother.html#ada29cf411cec2430ab4ac0bd09a31f4d">getEpsilon</a> () const</td></tr>
<tr class="separator:ada29cf411cec2430ab4ac0bd09a31f4d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8995f4b9e8a601304f1e8c1b4726d42f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1_path_smoother.html#a8995f4b9e8a601304f1e8c1b4726d42f">reset</a> ()</td></tr>
<tr class="separator:a8995f4b9e8a601304f1e8c1b4726d42f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac744e8c122164646ea8670e0ae04d7d5"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1_path_smoother.html#ac744e8c122164646ea8670e0ae04d7d5">clear</a> ()</td></tr>
<tr class="separator:ac744e8c122164646ea8670e0ae04d7d5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2563377098c03937869dbf142ad9bba7"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1_path_smoother.html#a2563377098c03937869dbf142ad9bba7">calculate</a> ()</td></tr>
<tr class="separator:a2563377098c03937869dbf142ad9bba7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7c48f29777de1d4abdd1f39e104b81d3"><td class="memItemLeft" align="right" valign="top">std::vector&lt; <a class="el" href="classcugl_1_1_vec2.html">Vec2</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1_path_smoother.html#a7c48f29777de1d4abdd1f39e104b81d3">getPath</a> () const</td></tr>
<tr class="separator:a7c48f29777de1d4abdd1f39e104b81d3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7df13cd169816e80adbc9235ef641df6"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1_path_smoother.html#a7df13cd169816e80adbc9235ef641df6">getPath</a> (std::vector&lt; <a class="el" href="classcugl_1_1_vec2.html">Vec2</a> &gt; &amp;buffer) const</td></tr>
<tr class="separator:a7df13cd169816e80adbc9235ef641df6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af745544bb897b7b522fb0176076b56a8"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classcugl_1_1_poly2.html">Poly2</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1_path_smoother.html#af745544bb897b7b522fb0176076b56a8">getPolygon</a> () const</td></tr>
<tr class="separator:af745544bb897b7b522fb0176076b56a8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7359392cbe12adb3ddbd88574a879b3f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classcugl_1_1_poly2.html">Poly2</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1_path_smoother.html#a7359392cbe12adb3ddbd88574a879b3f">getPolygon</a> (<a class="el" href="classcugl_1_1_poly2.html">Poly2</a> *buffer) const</td></tr>
<tr class="separator:a7359392cbe12adb3ddbd88574a879b3f"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>This class smooths a continuous path of points, reducing the number needed.</p>
<p>A common temptation with mobile games is to track the player's finger gesture by recording all of the finger positions over time. Except that this is a lot of points (and attempting to draw all these points exposed some serious flaws in earlier versions of <a class="el" href="classcugl_1_1_sprite_batch.html">SpriteBatch</a>). If points are too close together, then some of them can be safely removed without altering the shape of the path.</p>
<p>This class uses the Douglas-Peuker algorithm, as described here: </p><pre class="fragment"> https://en.wikipedia.org/wiki/Ramer–Douglas–Peucker_algorithm
</pre><p> The correct epsilon value to use should be found with experimentation. In particular, it depends on the scale of the path being smoothed.</p>
<p>As with all factories, the methods are broken up into three phases: initialization, calculation, and materialization. To use the factory, you first set the data (in this case a set of vertices or another <a class="el" href="classcugl_1_1_poly2.html">Poly2</a>) with the initialization methods. You then call the calculation method. Finally, you use the materialization methods to access the data in several different ways.</p>
<p>This division allows us to support multithreaded calculation if the data generation takes too long. However, note that this factory is not thread safe in that you cannot access data while it is still in mid-calculation. </p>
</div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="af4632cc8d422428c145f7c4d35bf5a14"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af4632cc8d422428c145f7c4d35bf5a14">&#9670;&nbsp;</a></span>PathSmoother() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">cugl::PathSmoother::PathSmoother </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Creates a path smoother with no vertex data. </p>

</div>
</div>
<a id="a59e14a5f14aeed0dfdd31c024463a75a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a59e14a5f14aeed0dfdd31c024463a75a">&#9670;&nbsp;</a></span>PathSmoother() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">cugl::PathSmoother::PathSmoother </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="classcugl_1_1_vec2.html">Vec2</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>points</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Creates a path smoother with the given vertex data.</p>
<p>The vertex data is copied. The smother does not retain any references to the original data.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">points</td><td>The vertices to triangulate </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a02c8d1e3adf4357d08d01e9657101bcc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a02c8d1e3adf4357d08d01e9657101bcc">&#9670;&nbsp;</a></span>~PathSmoother()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">cugl::PathSmoother::~PathSmoother </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Deletes this path smoother, releasing all resources. </p>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="a2563377098c03937869dbf142ad9bba7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2563377098c03937869dbf142ad9bba7">&#9670;&nbsp;</a></span>calculate()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void cugl::PathSmoother::calculate </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Performs a triangulation of the current vertex data. </p>

</div>
</div>
<a id="ac744e8c122164646ea8670e0ae04d7d5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac744e8c122164646ea8670e0ae04d7d5">&#9670;&nbsp;</a></span>clear()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void cugl::PathSmoother::clear </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Clears all internal data, the initial vertex data.</p>
<p>When this method is called, you will need to set a new vertices before calling calculate. </p>

</div>
</div>
<a id="ada29cf411cec2430ab4ac0bd09a31f4d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ada29cf411cec2430ab4ac0bd09a31f4d">&#9670;&nbsp;</a></span>getEpsilon()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">float cugl::PathSmoother::getEpsilon </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns the epsilon value for the smoothing algorithm.</p>
<p>The epsilon value specifies the tolerance for the algorithm. At each step, any point that is with epsilon of a line segment is considered to be part of that line segment.</p>
<p>Typically this value is found by experimentation. However, because this is typically used to smooth touch paths (which have integer coordinates), the value should be at least 1 (which is the default).</p>
<dl class="section return"><dt>Returns</dt><dd>the epsilon value for the smoothing algorithm. </dd></dl>

</div>
</div>
<a id="a7c48f29777de1d4abdd1f39e104b81d3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7c48f29777de1d4abdd1f39e104b81d3">&#9670;&nbsp;</a></span>getPath() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;<a class="el" href="classcugl_1_1_vec2.html">Vec2</a>&gt; cugl::PathSmoother::getPath </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns a list of points representing the smoothed path.</p>
<p>The result is guaranteed to be a subset of the original vertex path, order preserved. The smoother does not retain a reference to the returned list; it is safe to modify it.</p>
<p>If the calculation is not yet performed, this method will return the empty list.</p>
<dl class="section return"><dt>Returns</dt><dd>a list of indices representing the triangulation. </dd></dl>

</div>
</div>
<a id="a7df13cd169816e80adbc9235ef641df6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7df13cd169816e80adbc9235ef641df6">&#9670;&nbsp;</a></span>getPath() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t cugl::PathSmoother::getPath </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; <a class="el" href="classcugl_1_1_vec2.html">Vec2</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>buffer</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Stores the triangulation indices in the given buffer.</p>
<p>The result is guaranteed to be a subset of the original vertex path, order preserved. The points will be appended to the provided vector. You should clear the vector first if you do not want to preserve the original data.</p>
<p>If the calculation is not yet performed, this method will do nothing.</p>
<dl class="section return"><dt>Returns</dt><dd>the number of elements added to the buffer </dd></dl>

</div>
</div>
<a id="af745544bb897b7b522fb0176076b56a8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af745544bb897b7b522fb0176076b56a8">&#9670;&nbsp;</a></span>getPolygon() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcugl_1_1_poly2.html">Poly2</a> cugl::PathSmoother::getPolygon </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns a polygon representing the smoothed path.</p>
<p>The polygon contains the path vertices together with the new indices defining an open path. To close the path, simply add two more indices connected the last vertex with the first. The smoother does not maintain references to this polygon and it is safe to modify it.</p>
<p>If the calculation is not yet performed, this method will return the empty polygon.</p>
<dl class="section return"><dt>Returns</dt><dd>a polygon representing the triangulation. </dd></dl>

</div>
</div>
<a id="a7359392cbe12adb3ddbd88574a879b3f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7359392cbe12adb3ddbd88574a879b3f">&#9670;&nbsp;</a></span>getPolygon() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcugl_1_1_poly2.html">Poly2</a>* cugl::PathSmoother::getPolygon </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classcugl_1_1_poly2.html">Poly2</a> *&#160;</td>
          <td class="paramname"><em>buffer</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Stores the triangulation in the given buffer.</p>
<p>The polygon contains the path vertices together with the new indices defining an open path. This method will add both the original vertices, and the corresponding indices to the new buffer. If the buffer is not empty, the indices will be adjusted accordingly. You should clear the buffer first if you do not want to preserve the original data.</p>
<p>If the calculation is not yet performed, this method will do nothing.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">buffer</td><td>The buffer to store the triangulated polygon</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a reference to the buffer for chaining. </dd></dl>

</div>
</div>
<a id="a8995f4b9e8a601304f1e8c1b4726d42f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8995f4b9e8a601304f1e8c1b4726d42f">&#9670;&nbsp;</a></span>reset()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void cugl::PathSmoother::reset </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Clears all internal data, but still maintains the initial vertex data. </p>

</div>
</div>
<a id="aa213afdd902707f2f3543fe84a6ad8f0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa213afdd902707f2f3543fe84a6ad8f0">&#9670;&nbsp;</a></span>set()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void cugl::PathSmoother::set </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="classcugl_1_1_vec2.html">Vec2</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>points</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Sets the vertex data for this path smoother.</p>
<p>The vertex data is copied. The smother does not retain any references to the original data.</p>
<p>This method resets all interal data. You will need to reperform the calculation before accessing data.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">points</td><td>The vertices to triangulate </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a85cc50acc9a53b3efb3b863009f8f1e3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a85cc50acc9a53b3efb3b863009f8f1e3">&#9670;&nbsp;</a></span>setEpsilon()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void cugl::PathSmoother::setEpsilon </td>
          <td>(</td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>epsilon</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Sets the epsilon value for the smoothing algorithm.</p>
<p>The epsilon value specifies the tolerance for the algorithm. At each step, any point that is with epsilon of a line segment is considered to be part of that line segment.</p>
<p>Typically this value is found by experimentation. However, because this is typically used to smooth touch paths (which have integer coordinates), the value should be at least 1 (which is the default).</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">epsilon</td><td>The epsilon value for the smoothing algorithm. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>include/cugl/math/polygon/<a class="el" href="_c_u_path_smoother_8h_source.html">CUPathSmoother.h</a></li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.1
</small></address>
</body>
</html>
