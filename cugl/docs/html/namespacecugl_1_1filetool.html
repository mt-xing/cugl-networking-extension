<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.9.1"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>CUGL 2.0: cugl::filetool Namespace Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">CUGL 2.0
   </div>
   <div id="projectbrief">Cornell University Game Library</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.1 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search','.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespacecugl.html">cugl</a></li><li class="navelem"><a class="el" href="namespacecugl_1_1filetool.html">filetool</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#func-members">Functions</a> &#124;
<a href="#var-members">Variables</a>  </div>
  <div class="headertitle">
<div class="title">cugl::filetool Namespace Reference</div>  </div>
</div><!--header-->
<div class="contents">
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:a9432498a5f59eba21c4a9fed0129a26f"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecugl_1_1filetool.html#a9432498a5f59eba21c4a9fed0129a26f">is_file</a> (const std::string path)</td></tr>
<tr class="separator:a9432498a5f59eba21c4a9fed0129a26f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3204bb8c5b567a54c14784f0d061712b"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecugl_1_1filetool.html#a3204bb8c5b567a54c14784f0d061712b">is_dir</a> (const std::string path)</td></tr>
<tr class="separator:a3204bb8c5b567a54c14784f0d061712b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acade68ea11593f8658d8b4f497b1585c"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecugl_1_1filetool.html#acade68ea11593f8658d8b4f497b1585c">is_hidden</a> (const std::string path)</td></tr>
<tr class="separator:acade68ea11593f8658d8b4f497b1585c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3095271b6e1f53654d333ca97f2b0507"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecugl_1_1filetool.html#a3095271b6e1f53654d333ca97f2b0507">is_absolute</a> (const std::string path)</td></tr>
<tr class="separator:a3095271b6e1f53654d333ca97f2b0507"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa404bf9e802f52159e219bd7d64a0b6f"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecugl_1_1filetool.html#aa404bf9e802f52159e219bd7d64a0b6f">file_exists</a> (const std::string path)</td></tr>
<tr class="separator:aa404bf9e802f52159e219bd7d64a0b6f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4e9fa6d09ca30ca42eeb99e276447182"><td class="memItemLeft" align="right" valign="top">const std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecugl_1_1filetool.html#a4e9fa6d09ca30ca42eeb99e276447182">file_vol</a> (const std::string path)</td></tr>
<tr class="separator:a4e9fa6d09ca30ca42eeb99e276447182"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a919040fd7543400389e4dd2891cdd0c0"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecugl_1_1filetool.html#a919040fd7543400389e4dd2891cdd0c0">file_size</a> (const std::string path)</td></tr>
<tr class="separator:a919040fd7543400389e4dd2891cdd0c0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad9a92426dd2145536944757013649931"><td class="memItemLeft" align="right" valign="top">Uint64&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecugl_1_1filetool.html#ad9a92426dd2145536944757013649931">file_timestamp</a> (const std::string path)</td></tr>
<tr class="separator:ad9a92426dd2145536944757013649931"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2bb24e87f95f8e69068d84752e15fb1e"><td class="memItemLeft" align="right" valign="top">const std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecugl_1_1filetool.html#a2bb24e87f95f8e69068d84752e15fb1e">dir_name</a> (const std::string path)</td></tr>
<tr class="separator:a2bb24e87f95f8e69068d84752e15fb1e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4fa129a9570ab778401b6a67e008b9e0"><td class="memItemLeft" align="right" valign="top">const std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecugl_1_1filetool.html#a4fa129a9570ab778401b6a67e008b9e0">base_name</a> (const std::string path)</td></tr>
<tr class="separator:a4fa129a9570ab778401b6a67e008b9e0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adfd451205754f44dc3d2f486255e5db7"><td class="memItemLeft" align="right" valign="top">std::pair&lt; std::string, std::string &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecugl_1_1filetool.html#adfd451205754f44dc3d2f486255e5db7">split_path</a> (const std::string path)</td></tr>
<tr class="separator:adfd451205754f44dc3d2f486255e5db7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a24e9041910ea3c21b8d799f3701fea4a"><td class="memItemLeft" align="right" valign="top">std::vector&lt; std::string &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecugl_1_1filetool.html#a24e9041910ea3c21b8d799f3701fea4a">fullsplit_path</a> (const std::string path)</td></tr>
<tr class="separator:a24e9041910ea3c21b8d799f3701fea4a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0c92f7ff0db8556c2f1b0067486a0790"><td class="memItemLeft" align="right" valign="top">const std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecugl_1_1filetool.html#a0c92f7ff0db8556c2f1b0067486a0790">base_prefix</a> (const std::string path)</td></tr>
<tr class="separator:a0c92f7ff0db8556c2f1b0067486a0790"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a362a23f5acb589cb4e6a3db19043a858"><td class="memItemLeft" align="right" valign="top">const std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecugl_1_1filetool.html#a362a23f5acb589cb4e6a3db19043a858">base_suffix</a> (const std::string path)</td></tr>
<tr class="separator:a362a23f5acb589cb4e6a3db19043a858"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aad2dbe2299e78a1befa3b0e106144476"><td class="memItemLeft" align="right" valign="top">const std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecugl_1_1filetool.html#aad2dbe2299e78a1befa3b0e106144476">set_suffix</a> (const std::string path, const std::string suffix)</td></tr>
<tr class="separator:aad2dbe2299e78a1befa3b0e106144476"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a64a00bd36ee24872ed517af198eef1d4"><td class="memItemLeft" align="right" valign="top">std::pair&lt; std::string, std::string &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecugl_1_1filetool.html#a64a00bd36ee24872ed517af198eef1d4">split_base</a> (const std::string path)</td></tr>
<tr class="separator:a64a00bd36ee24872ed517af198eef1d4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acbb3611789d9bd7fdabfabe3f3de5126"><td class="memItemLeft" align="right" valign="top">const std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecugl_1_1filetool.html#acbb3611789d9bd7fdabfabe3f3de5126">normalize_path</a> (const std::string path)</td></tr>
<tr class="separator:acbb3611789d9bd7fdabfabe3f3de5126"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad91cf93bfa6f6dfe6e031060230a7f9d"><td class="memItemLeft" align="right" valign="top">const std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecugl_1_1filetool.html#ad91cf93bfa6f6dfe6e031060230a7f9d">canonicalize_path</a> (const std::string path)</td></tr>
<tr class="separator:ad91cf93bfa6f6dfe6e031060230a7f9d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac8f2e8288a92547342c8a4455972496c"><td class="memItemLeft" align="right" valign="top">const std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecugl_1_1filetool.html#ac8f2e8288a92547342c8a4455972496c">common_path</a> (const std::initializer_list&lt; std::string &gt; paths)</td></tr>
<tr class="separator:ac8f2e8288a92547342c8a4455972496c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1804461f6f6880d8e5a93fe457f4b562"><td class="memItemLeft" align="right" valign="top">const std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecugl_1_1filetool.html#a1804461f6f6880d8e5a93fe457f4b562">common_path</a> (const std::vector&lt; std::string &gt; paths)</td></tr>
<tr class="separator:a1804461f6f6880d8e5a93fe457f4b562"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a791631b82ea180dc26bcdc15b9d8521b"><td class="memItemLeft" align="right" valign="top">const std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecugl_1_1filetool.html#a791631b82ea180dc26bcdc15b9d8521b">common_path</a> (const std::string *paths, size_t size)</td></tr>
<tr class="separator:a791631b82ea180dc26bcdc15b9d8521b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac332bb1790f025d63f1efa98432576fc"><td class="memItemLeft" align="right" valign="top">const std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecugl_1_1filetool.html#ac332bb1790f025d63f1efa98432576fc">join_path</a> (std::initializer_list&lt; std::string &gt; elts)</td></tr>
<tr class="separator:ac332bb1790f025d63f1efa98432576fc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2455b42f99bd4718991e8ed085497206"><td class="memItemLeft" align="right" valign="top">const std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecugl_1_1filetool.html#a2455b42f99bd4718991e8ed085497206">join_path</a> (std::vector&lt; std::string &gt; elts)</td></tr>
<tr class="separator:a2455b42f99bd4718991e8ed085497206"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a60a4d6334f9405945240a2e0d1241885"><td class="memItemLeft" align="right" valign="top">const std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecugl_1_1filetool.html#a60a4d6334f9405945240a2e0d1241885">join_path</a> (const std::string *elts, size_t size)</td></tr>
<tr class="separator:a60a4d6334f9405945240a2e0d1241885"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac1e1cd60a49d391fd1a360d1c850c8b0"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecugl_1_1filetool.html#ac1e1cd60a49d391fd1a360d1c850c8b0">file_create</a> (const std::string path)</td></tr>
<tr class="separator:ac1e1cd60a49d391fd1a360d1c850c8b0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaeaa2ae7e14ced6c2362f507dd3df07a"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecugl_1_1filetool.html#aaeaa2ae7e14ced6c2362f507dd3df07a">file_delete</a> (const std::string path)</td></tr>
<tr class="separator:aaeaa2ae7e14ced6c2362f507dd3df07a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6ccf474fd80609b7e76d19a914db2bcb"><td class="memItemLeft" align="right" valign="top">std::vector&lt; std::string &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecugl_1_1filetool.html#a6ccf474fd80609b7e76d19a914db2bcb">dir_contents</a> (const std::string path)</td></tr>
<tr class="separator:a6ccf474fd80609b7e76d19a914db2bcb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a05cc1a6bad0bc71fb3fabd67787d122f"><td class="memItemLeft" align="right" valign="top">std::vector&lt; std::string &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecugl_1_1filetool.html#a05cc1a6bad0bc71fb3fabd67787d122f">dir_contents</a> (const std::string path, const std::function&lt; bool(const std::string file)&gt; &amp;filter)</td></tr>
<tr class="separator:a05cc1a6bad0bc71fb3fabd67787d122f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9d2a22c39008a07a9e783b48f9755509"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecugl_1_1filetool.html#a9d2a22c39008a07a9e783b48f9755509">dir_create</a> (const std::string path)</td></tr>
<tr class="separator:a9d2a22c39008a07a9e783b48f9755509"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a98becfede45f9d83cede181260cdc16d"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecugl_1_1filetool.html#a98becfede45f9d83cede181260cdc16d">dir_delete</a> (const std::string path)</td></tr>
<tr class="separator:a98becfede45f9d83cede181260cdc16d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a81953f73248591e0568c1c2ea71e74dd"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecugl_1_1filetool.html#a81953f73248591e0568c1c2ea71e74dd">is_readable</a> (const std::string path)</td></tr>
<tr class="separator:a81953f73248591e0568c1c2ea71e74dd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab0c9a14e16d8967e7d6be4854bb1380c"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecugl_1_1filetool.html#ab0c9a14e16d8967e7d6be4854bb1380c">is_searchable</a> (const std::string path)</td></tr>
<tr class="separator:ab0c9a14e16d8967e7d6be4854bb1380c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adce9f8fc9067eb815bc705fcf2b7bbe4"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecugl_1_1filetool.html#adce9f8fc9067eb815bc705fcf2b7bbe4">is_writable</a> (const std::string path)</td></tr>
<tr class="separator:adce9f8fc9067eb815bc705fcf2b7bbe4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5cf60905c28c516c639c6d4bc711f723"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecugl_1_1filetool.html#a5cf60905c28c516c639c6d4bc711f723">set_readable</a> (const std::string path, bool readable)</td></tr>
<tr class="separator:a5cf60905c28c516c639c6d4bc711f723"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae1047282f717119abfb5f109adae82c5"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecugl_1_1filetool.html#ae1047282f717119abfb5f109adae82c5">set_readable</a> (const std::string path, bool readable, bool ownerOnly)</td></tr>
<tr class="separator:ae1047282f717119abfb5f109adae82c5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5babf1b42800e15fad0a5f613096c1e8"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecugl_1_1filetool.html#a5babf1b42800e15fad0a5f613096c1e8">set_readonly</a> (const std::string path)</td></tr>
<tr class="separator:a5babf1b42800e15fad0a5f613096c1e8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa53373010a8a6dac9ac937db7e27f13f"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecugl_1_1filetool.html#aa53373010a8a6dac9ac937db7e27f13f">set_searchable</a> (const std::string path, bool searchable)</td></tr>
<tr class="separator:aa53373010a8a6dac9ac937db7e27f13f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a849d30d82a826eac3b4126e87e5e472e"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecugl_1_1filetool.html#a849d30d82a826eac3b4126e87e5e472e">set_searchable</a> (const std::string path, bool searchable, bool ownerOnly)</td></tr>
<tr class="separator:a849d30d82a826eac3b4126e87e5e472e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a917f5e77d53708c38dfa92e15aaca968"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecugl_1_1filetool.html#a917f5e77d53708c38dfa92e15aaca968">set_writable</a> (const std::string path, bool writable)</td></tr>
<tr class="separator:a917f5e77d53708c38dfa92e15aaca968"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7d00359ae5f33636704af929a46a59c1"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecugl_1_1filetool.html#a7d00359ae5f33636704af929a46a59c1">set_writable</a> (const std::string path, bool writable, bool ownerOnly)</td></tr>
<tr class="separator:a7d00359ae5f33636704af929a46a59c1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a92e707d56f09a06c9bdb04d1af8262aa"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecugl_1_1filetool.html#a92e707d56f09a06c9bdb04d1af8262aa">vol_free_space</a> (const std::string path)</td></tr>
<tr class="separator:a92e707d56f09a06c9bdb04d1af8262aa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af80989d313ef24ce784b7d82d52c8b7d"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecugl_1_1filetool.html#af80989d313ef24ce784b7d82d52c8b7d">vol_available_space</a> (const std::string path)</td></tr>
<tr class="separator:af80989d313ef24ce784b7d82d52c8b7d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a43e007516e86f97944abbe3507c5680f"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecugl_1_1filetool.html#a43e007516e86f97944abbe3507c5680f">vol_total_space</a> (const std::string path)</td></tr>
<tr class="separator:a43e007516e86f97944abbe3507c5680f"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="var-members"></a>
Variables</h2></td></tr>
<tr class="memitem:accfc65979f7462cb9eae1782f01f8d06"><td class="memItemLeft" align="right" valign="top">char&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacecugl_1_1filetool.html#accfc65979f7462cb9eae1782f01f8d06">path_sep</a></td></tr>
<tr class="separator:accfc65979f7462cb9eae1782f01f8d06"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Functions for file management.</p>
<p>This namespace provides several tools for querying and constructing file paths in an OS independent way. It is largely a collection of namespaced functions, much like the stringtool module. It is based off the the <code>os.path</code> module in Python. </p>
</div><h2 class="groupheader">Function Documentation</h2>
<a id="a4fa129a9570ab778401b6a67e008b9e0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4fa129a9570ab778401b6a67e008b9e0">&#9670;&nbsp;</a></span>base_name()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const std::string cugl::filetool::base_name </td>
          <td>(</td>
          <td class="paramtype">const std::string&#160;</td>
          <td class="paramname"><em>path</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns the name of the leaf file of this path.</p>
<p>This value is the same as the second element returned by the function <a class="el" href="namespacecugl_1_1filetool.html#adfd451205754f44dc3d2f486255e5db7">split_path</a>. If the path names ends in a path separator, this will be ignored when determining the leaf.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">path</td><td>The file path name</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the suffix for the leaf file of this path. </dd></dl>

</div>
</div>
<a id="a0c92f7ff0db8556c2f1b0067486a0790"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0c92f7ff0db8556c2f1b0067486a0790">&#9670;&nbsp;</a></span>base_prefix()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const std::string cugl::filetool::base_prefix </td>
          <td>(</td>
          <td class="paramtype">const std::string&#160;</td>
          <td class="paramname"><em>path</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns the suffix for the leaf file of this path.</p>
<p>A suffix is any part of the file name after a final period. If there is no suffix, this function returns the empty string.</p>
<p>This value is the same as the second element returned by the function <a class="el" href="namespacecugl_1_1filetool.html#a64a00bd36ee24872ed517af198eef1d4">split_base</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">path</td><td>The file path name</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the suffix for the leaf file of this path. </dd></dl>

</div>
</div>
<a id="a362a23f5acb589cb4e6a3db19043a858"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a362a23f5acb589cb4e6a3db19043a858">&#9670;&nbsp;</a></span>base_suffix()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const std::string cugl::filetool::base_suffix </td>
          <td>(</td>
          <td class="paramtype">const std::string&#160;</td>
          <td class="paramname"><em>path</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns the suffix for the leaf file of this path.</p>
<p>A suffix is any part of the file name after a final period. If there is no suffix, this function returns the empty string.</p>
<p>This value is the same as the second element returned by the function <a class="el" href="namespacecugl_1_1filetool.html#a64a00bd36ee24872ed517af198eef1d4">split_base</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">path</td><td>The file path name</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the suffix for the leaf file of this path. </dd></dl>

</div>
</div>
<a id="ad91cf93bfa6f6dfe6e031060230a7f9d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad91cf93bfa6f6dfe6e031060230a7f9d">&#9670;&nbsp;</a></span>canonicalize_path()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const std::string cugl::filetool::canonicalize_path </td>
          <td>(</td>
          <td class="paramtype">const std::string&#160;</td>
          <td class="paramname"><em>path</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns the given path, canonicalized to the current platform</p>
<p>Canonicalization does everything that normalization does, plus it converts a relative path to its absolute equivalent. It replaces all path separators with the correct system-dependent versions. It also normalizes the path prefix (e.g. capitalizing drive letters on Windows and so on).</p>
<p>In addition, canonicalization removes all redundant directories (e.g. the directories . and ..). However, it does not expand links or shortcuts as is often the case with path canonicalization.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">path</td><td>The path to canonicalize.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the given path, canonicalized to the current platform </dd></dl>

</div>
</div>
<a id="ac8f2e8288a92547342c8a4455972496c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac8f2e8288a92547342c8a4455972496c">&#9670;&nbsp;</a></span>common_path() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const std::string cugl::filetool::common_path </td>
          <td>(</td>
          <td class="paramtype">const std::initializer_list&lt; std::string &gt;&#160;</td>
          <td class="paramname"><em>paths</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns the common subpath of the given paths.</p>
<p>If there is no common prefix, or if the paths are a mixture of absolute and relative paths, then this function returns the empty string.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">paths</td><td>The collection of paths to search</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the common subpath of the given paths. </dd></dl>

</div>
</div>
<a id="a791631b82ea180dc26bcdc15b9d8521b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a791631b82ea180dc26bcdc15b9d8521b">&#9670;&nbsp;</a></span>common_path() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const std::string cugl::filetool::common_path </td>
          <td>(</td>
          <td class="paramtype">const std::string *&#160;</td>
          <td class="paramname"><em>paths</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns the common subpath of the given paths.</p>
<p>If there is no common prefix, or if the paths are a mixture of absolute and relative paths, then this function returns the empty string.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">paths</td><td>The collection of paths to search </td></tr>
    <tr><td class="paramname">size</td><td>The number of elements in the arrray</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the common subpath of the given paths. </dd></dl>

</div>
</div>
<a id="a1804461f6f6880d8e5a93fe457f4b562"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1804461f6f6880d8e5a93fe457f4b562">&#9670;&nbsp;</a></span>common_path() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const std::string cugl::filetool::common_path </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; std::string &gt;&#160;</td>
          <td class="paramname"><em>paths</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns the common subpath of the given paths.</p>
<p>If there is no common prefix, or if the paths are a mixture of absolute and relative paths, then this function returns the empty string.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">paths</td><td>The collection of paths to search</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the common subpath of the given paths. </dd></dl>

</div>
</div>
<a id="a6ccf474fd80609b7e76d19a914db2bcb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6ccf474fd80609b7e76d19a914db2bcb">&#9670;&nbsp;</a></span>dir_contents() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;std::string&gt; cugl::filetool::dir_contents </td>
          <td>(</td>
          <td class="paramtype">const std::string&#160;</td>
          <td class="paramname"><em>path</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns a list of strings naming the files and directories in this path</p>
<p>This function assumes that this path name denotes a valid directory. If it does not, the list will be empty.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">path</td><td>The file path name</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a list of strings naming the files and directories in this path </dd></dl>

</div>
</div>
<a id="a05cc1a6bad0bc71fb3fabd67787d122f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a05cc1a6bad0bc71fb3fabd67787d122f">&#9670;&nbsp;</a></span>dir_contents() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;std::string&gt; cugl::filetool::dir_contents </td>
          <td>(</td>
          <td class="paramtype">const std::string&#160;</td>
          <td class="paramname"><em>path</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::function&lt; bool(const std::string file)&gt; &amp;&#160;</td>
          <td class="paramname"><em>filter</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns a filtered list of strings naming the files and directories in this path</p>
<p>This function assumes that this path name denotes a valid directory. If it does not, the list will be empty.</p>
<p>The filter will be given the normalized version of each file in the directory. If the directory is specified by an absolute path, each file will be as well.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">path</td><td>The file path name </td></tr>
    <tr><td class="paramname">filter</td><td>The filter to apply to file names</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a filtered list of strings naming the files and directories in this path </dd></dl>

</div>
</div>
<a id="a9d2a22c39008a07a9e783b48f9755509"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9d2a22c39008a07a9e783b48f9755509">&#9670;&nbsp;</a></span>dir_create()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool cugl::filetool::dir_create </td>
          <td>(</td>
          <td class="paramtype">const std::string&#160;</td>
          <td class="paramname"><em>path</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Creates the directory named by this path name.</p>
<p>This function succeeds if and only if a file or directory with this name does not yet exist.</p>
<p>This function will fail if the path name is relative. Relative path names refer to the asset directory, which is a read-only directory.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">path</td><td>The file path name</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if the directory was successfully created. </dd></dl>

</div>
</div>
<a id="a98becfede45f9d83cede181260cdc16d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a98becfede45f9d83cede181260cdc16d">&#9670;&nbsp;</a></span>dir_delete()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool cugl::filetool::dir_delete </td>
          <td>(</td>
          <td class="paramtype">const std::string&#160;</td>
          <td class="paramname"><em>path</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Deletes the directory denoted by this path name.</p>
<p>This function will fail if the file is not a directory or if it does not yet exist.</p>
<p>This function will fail if the file is not a regular file or if it does not yet exist. In addition, it will fail if the path name is relative. Relative path names refer to the asset directory, which is a read-only directory.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">path</td><td>The file path name</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if the directory was successfully deleted. </dd></dl>

</div>
</div>
<a id="a2bb24e87f95f8e69068d84752e15fb1e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2bb24e87f95f8e69068d84752e15fb1e">&#9670;&nbsp;</a></span>dir_name()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const std::string cugl::filetool::dir_name </td>
          <td>(</td>
          <td class="paramtype">const std::string&#160;</td>
          <td class="paramname"><em>path</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns the path name of the parent directory for this file.</p>
<p>This value is the same as the first element returned by the function <a class="el" href="namespacecugl_1_1filetool.html#adfd451205754f44dc3d2f486255e5db7">split_path</a>. If path is a relative reference to a file with no parent directory then this function will return the empty string.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">path</td><td>The file path name</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the suffix for the leaf file of this path. </dd></dl>

</div>
</div>
<a id="ac1e1cd60a49d391fd1a360d1c850c8b0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac1e1cd60a49d391fd1a360d1c850c8b0">&#9670;&nbsp;</a></span>file_create()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool cugl::filetool::file_create </td>
          <td>(</td>
          <td class="paramtype">const std::string&#160;</td>
          <td class="paramname"><em>path</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Creates a new, empty file named by this path name</p>
<p>This function succeeds if and only if a file with this name does not yet exist. The file will be an empty, regular file.</p>
<p>This function will fail if the path name is relative. Relative path names refer to the asset directory, which is a read-only directory.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">path</td><td>The file path name</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if the file was successfully created. </dd></dl>

</div>
</div>
<a id="aaeaa2ae7e14ced6c2362f507dd3df07a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaeaa2ae7e14ced6c2362f507dd3df07a">&#9670;&nbsp;</a></span>file_delete()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool cugl::filetool::file_delete </td>
          <td>(</td>
          <td class="paramtype">const std::string&#160;</td>
          <td class="paramname"><em>path</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Deletes the file denoted by this path name.</p>
<p>This function will fail if the file is not a regular file or if it does not yet exist. In addition, it will fail if the path name is relative. Relative path names refer to the asset directory, which is a read-only directory.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">path</td><td>The file path name</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if the file was successfully deleted. </dd></dl>

</div>
</div>
<a id="aa404bf9e802f52159e219bd7d64a0b6f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa404bf9e802f52159e219bd7d64a0b6f">&#9670;&nbsp;</a></span>file_exists()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool cugl::filetool::file_exists </td>
          <td>(</td>
          <td class="paramtype">const std::string&#160;</td>
          <td class="paramname"><em>path</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns true if the file or directory denoted by this path name exists.</p>
<p>This function will return false is the file does not exist. If the path is a relative path, this function will use the asset directory as the working directory.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">path</td><td>The file path name</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if the file or directory denoted by this path name exists. </dd></dl>

</div>
</div>
<a id="a919040fd7543400389e4dd2891cdd0c0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a919040fd7543400389e4dd2891cdd0c0">&#9670;&nbsp;</a></span>file_size()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t cugl::filetool::file_size </td>
          <td>(</td>
          <td class="paramtype">const std::string&#160;</td>
          <td class="paramname"><em>path</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns the length of the file denoted by this path name.</p>
<p>The value is measured in bytes. This function returns 0 if there is no file at the given path name. If the path is a relative path, this function will use the asset directory as the working directory.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">path</td><td>The file path name</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the length of the file denoted by this path name. </dd></dl>

</div>
</div>
<a id="ad9a92426dd2145536944757013649931"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad9a92426dd2145536944757013649931">&#9670;&nbsp;</a></span>file_timestamp()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Uint64 cugl::filetool::file_timestamp </td>
          <td>(</td>
          <td class="paramtype">const std::string&#160;</td>
          <td class="paramname"><em>path</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns the time that the file for this path name was last modified.</p>
<p>The value is in seconds since the last epoch (e.g. January 1, 1970 on Unix systems). This function returns 0 if there is no file at the given path name. If the path is a relative path, this function will use the asset directory as the working directory.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">path</td><td>The file path name</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the time that the file for this path name was last modified. </dd></dl>

</div>
</div>
<a id="a4e9fa6d09ca30ca42eeb99e276447182"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4e9fa6d09ca30ca42eeb99e276447182">&#9670;&nbsp;</a></span>file_vol()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const std::string cugl::filetool::file_vol </td>
          <td>(</td>
          <td class="paramtype">const std::string&#160;</td>
          <td class="paramname"><em>path</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns the volume prefix for this path name.</p>
<p>There does not have to be a valid file at the given path name for this function to return a value. If the path name is a relative one, it will return the volume of the asset directory. On some platforms (particularly Android) this may return the empty string.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">path</td><td>The file path name</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the volume prefix for this path. </dd></dl>

</div>
</div>
<a id="a24e9041910ea3c21b8d799f3701fea4a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a24e9041910ea3c21b8d799f3701fea4a">&#9670;&nbsp;</a></span>fullsplit_path()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;std::string&gt; cugl::filetool::fullsplit_path </td>
          <td>(</td>
          <td class="paramtype">const std::string&#160;</td>
          <td class="paramname"><em>path</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns the path name broken up into individual elements.</p>
<p>The last element of the vector will be be the leaf file of the path name. All other elements (if they exist) will be directories in the path name. If the path name is absolute then the first element of the vector will include the volume.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">path</td><td>The file path name</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the pair of a leaf file and its parent directory. </dd></dl>

</div>
</div>
<a id="a3095271b6e1f53654d333ca97f2b0507"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3095271b6e1f53654d333ca97f2b0507">&#9670;&nbsp;</a></span>is_absolute()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool cugl::filetool::is_absolute </td>
          <td>(</td>
          <td class="paramtype">const std::string&#160;</td>
          <td class="paramname"><em>path</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns true if this path name is absolute.</p>
<p>An absolute path name has an explicit volume and path from the volume. This function does not require that the file exist. It only checks the naming convention of the file referenced by this path.</p>
<dl class="section return"><dt>Returns</dt><dd>true if this path name is absolute. </dd></dl>

</div>
</div>
<a id="a3204bb8c5b567a54c14784f0d061712b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3204bb8c5b567a54c14784f0d061712b">&#9670;&nbsp;</a></span>is_dir()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool cugl::filetool::is_dir </td>
          <td>(</td>
          <td class="paramtype">const std::string&#160;</td>
          <td class="paramname"><em>path</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns true if the file denoted by this path name is a directory.</p>
<p>This function will return false is the file does not exist. If the path is a relative path, this function will use the asset directory as the working directory.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">path</td><td>The file path name</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if the file denoted by this path name is a directory. </dd></dl>

</div>
</div>
<a id="a9432498a5f59eba21c4a9fed0129a26f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9432498a5f59eba21c4a9fed0129a26f">&#9670;&nbsp;</a></span>is_file()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool cugl::filetool::is_file </td>
          <td>(</td>
          <td class="paramtype">const std::string&#160;</td>
          <td class="paramname"><em>path</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns true if the file denoted by this path name is a normal file.</p>
<p>This function will return false is the file does not exist. If the path is a relative path, this function will use the asset directory as the working directory.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">path</td><td>The file path name</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if the file denoted by this path name is a normal file. </dd></dl>

</div>
</div>
<a id="acade68ea11593f8658d8b4f497b1585c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acade68ea11593f8658d8b4f497b1585c">&#9670;&nbsp;</a></span>is_hidden()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool cugl::filetool::is_hidden </td>
          <td>(</td>
          <td class="paramtype">const std::string&#160;</td>
          <td class="paramname"><em>path</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns true if the file named by this path name is a hidden file (starts with .).</p>
<p>This function does not require that the file exist. It only checks the naming convention of the file referenced by this path.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">path</td><td>The file path name</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if the file named by this path name is a hidden file. </dd></dl>

</div>
</div>
<a id="a81953f73248591e0568c1c2ea71e74dd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a81953f73248591e0568c1c2ea71e74dd">&#9670;&nbsp;</a></span>is_readable()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool cugl::filetool::is_readable </td>
          <td>(</td>
          <td class="paramtype">const std::string&#160;</td>
          <td class="paramname"><em>path</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns true if the application can read the file for this path name.</p>
<p>This function uses the access() POSIX function. Therefore, it does not assume that this application is the file owner, and correctly determines the file access.</p>
<p>If there is no file at the given path, this function returns false. If path name is relative it is assumes it is in the asset directory.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">path</td><td>The file path name</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if the application can read the file for this path name. </dd></dl>

</div>
</div>
<a id="ab0c9a14e16d8967e7d6be4854bb1380c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab0c9a14e16d8967e7d6be4854bb1380c">&#9670;&nbsp;</a></span>is_searchable()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool cugl::filetool::is_searchable </td>
          <td>(</td>
          <td class="paramtype">const std::string&#160;</td>
          <td class="paramname"><em>path</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns true if the application can execute the file for this path name.</p>
<p>Note that the only form of file execution supported by CUGL is searching a directory.</p>
<p>This function uses the access() POSIX function. Therefore, it does not assume that this application is the file owner, and correctly determines the file access.</p>
<p>If there is no file at the given path, this function returns false. If path name is relative it is assumes it is in the asset directory.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">path</td><td>The file path name</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if the application can execute the file for this path name. </dd></dl>

</div>
</div>
<a id="adce9f8fc9067eb815bc705fcf2b7bbe4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adce9f8fc9067eb815bc705fcf2b7bbe4">&#9670;&nbsp;</a></span>is_writable()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool cugl::filetool::is_writable </td>
          <td>(</td>
          <td class="paramtype">const std::string&#160;</td>
          <td class="paramname"><em>path</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns true if the application can modify the file for this path name.</p>
<p>This function uses the access() POSIX function. Therefore, it does not assume that this application is the file owner, and correctly determines the file access.</p>
<p>If there is no file at the given path, this function returns false. If path name is relative it is assumes it is in the asset directory.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">path</td><td>The file path name</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if the application can modify the file for this path name. </dd></dl>

</div>
</div>
<a id="a60a4d6334f9405945240a2e0d1241885"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a60a4d6334f9405945240a2e0d1241885">&#9670;&nbsp;</a></span>join_path() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const std::string cugl::filetool::join_path </td>
          <td>(</td>
          <td class="paramtype">const std::string *&#160;</td>
          <td class="paramname"><em>elts</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns a path that is the concatentation of elts.</p>
<p>The path elements will be concatenated using the platform-specific separator. To create an absolute path the first element should include the volume.</p>
<p>The path returned will not be normalized. Call <a class="el" href="namespacecugl_1_1filetool.html#acbb3611789d9bd7fdabfabe3f3de5126">normalize_path</a> if any additional normalization is necessary.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">elts</td><td>The strings to join </td></tr>
    <tr><td class="paramname">size</td><td>The number of items in elts.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a string that is the concatentation of elts. </dd></dl>

</div>
</div>
<a id="ac332bb1790f025d63f1efa98432576fc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac332bb1790f025d63f1efa98432576fc">&#9670;&nbsp;</a></span>join_path() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const std::string cugl::filetool::join_path </td>
          <td>(</td>
          <td class="paramtype">std::initializer_list&lt; std::string &gt;&#160;</td>
          <td class="paramname"><em>elts</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns a path that is the concatentation of elts.</p>
<p>The path elements will be concatenated using the platform-specific separator. To create an absolute path the first element should include the volume.</p>
<p>The path returned will not be normalized. Call <a class="el" href="namespacecugl_1_1filetool.html#acbb3611789d9bd7fdabfabe3f3de5126">normalize_path</a> if any additional normalization is necessary.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">elts</td><td>The strings to join</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a string that is the concatentation of elts. </dd></dl>

</div>
</div>
<a id="a2455b42f99bd4718991e8ed085497206"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2455b42f99bd4718991e8ed085497206">&#9670;&nbsp;</a></span>join_path() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const std::string cugl::filetool::join_path </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; std::string &gt;&#160;</td>
          <td class="paramname"><em>elts</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns a path that is the concatentation of elts.</p>
<p>The path elements will be concatenated using the platform-specific separator. To create an absolute path the first element should include the volume.</p>
<p>The path returned will not be normalized. Call <a class="el" href="namespacecugl_1_1filetool.html#acbb3611789d9bd7fdabfabe3f3de5126">normalize_path</a> if any additional normalization is necessary.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">elts</td><td>The strings to join</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a string that is the concatentation of elts. </dd></dl>

</div>
</div>
<a id="acbb3611789d9bd7fdabfabe3f3de5126"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acbb3611789d9bd7fdabfabe3f3de5126">&#9670;&nbsp;</a></span>normalize_path()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const std::string cugl::filetool::normalize_path </td>
          <td>(</td>
          <td class="paramtype">const std::string&#160;</td>
          <td class="paramname"><em>path</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns the given path, normalized to the current platform</p>
<p>Normalization replaces all path separators with the correct system- dependent versions. If the path is absolute, it also normalizes the path prefix (e.g. capitalizing drive letters on Windows and so on).</p>
<p>In addition, normalization removes all redundant directories (e.g. the directories . and ..). However, it does not expand links or shortcuts. Furthermore, this function does not convert a relative path into an absolute one. Since the asset directory is not well-defined on all platforms, it is not always possible to perform such a conversion.</p>
<p>In order for normalization to be successful, the path name must be mutliplatform safe. That means no use of colon (:), slash (), or backslash (/) in file names.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">path</td><td>The file path name</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the given path, normalized to the current platform </dd></dl>

</div>
</div>
<a id="a5cf60905c28c516c639c6d4bc711f723"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5cf60905c28c516c639c6d4bc711f723">&#9670;&nbsp;</a></span>set_readable() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool cugl::filetool::set_readable </td>
          <td>(</td>
          <td class="paramtype">const std::string&#160;</td>
          <td class="paramname"><em>path</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>readable</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Sets the owner's read permission for this path name.</p>
<p>The owner may or may not be this application. The function will return false if the application does not have permission for this change.</p>
<p>If there is no file at the given path, this function returns false. This function will also fail if the path name is relative. Relative path names refer to the asset directory, which is a read-only directory.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">path</td><td>The file path name </td></tr>
    <tr><td class="paramname">readable</td><td>Whether the owner may read this file</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if the file permissions where successfully changed. </dd></dl>

</div>
</div>
<a id="ae1047282f717119abfb5f109adae82c5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae1047282f717119abfb5f109adae82c5">&#9670;&nbsp;</a></span>set_readable() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool cugl::filetool::set_readable </td>
          <td>(</td>
          <td class="paramtype">const std::string&#160;</td>
          <td class="paramname"><em>path</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>readable</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>ownerOnly</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Sets the owner's or everybody's read permission for this path name.</p>
<p>The owner may or may not be this application. The function will return false if the application does not have permission for this change.</p>
<p>If there is no file at the given path, this function returns false. This function will also fail if the path name is relative. Relative path names refer to the asset directory, which is a read-only directory.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">path</td><td>The file path name </td></tr>
    <tr><td class="paramname">readable</td><td>Whether this file may be read </td></tr>
    <tr><td class="paramname">ownerOnly</td><td>Whether to apply this change only to the owner</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if the file permissions where successfully changed. </dd></dl>

</div>
</div>
<a id="a5babf1b42800e15fad0a5f613096c1e8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5babf1b42800e15fad0a5f613096c1e8">&#9670;&nbsp;</a></span>set_readonly()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool cugl::filetool::set_readonly </td>
          <td>(</td>
          <td class="paramtype">const std::string&#160;</td>
          <td class="paramname"><em>path</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Marks this file or directory so that only read operations are allowed.</p>
<p>The owner may or may not be this application. The function will return false if the application does not have permission for this change.</p>
<p>If there is no file at the given path, this function returns false. This function will also fail if the path name is relative. Relative path names refer to the asset directory, which is a read-only directory.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">path</td><td>The file path name</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if the file permissions where successfully changed. </dd></dl>

</div>
</div>
<a id="aa53373010a8a6dac9ac937db7e27f13f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa53373010a8a6dac9ac937db7e27f13f">&#9670;&nbsp;</a></span>set_searchable() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool cugl::filetool::set_searchable </td>
          <td>(</td>
          <td class="paramtype">const std::string&#160;</td>
          <td class="paramname"><em>path</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>searchable</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Sets the owner's execution permission for this path name.</p>
<p>Note that the only form of file execution supported by CUGL is searching a directory.</p>
<p>The owner may or may not be this application. The function will return false if the application does not have permission for this change.</p>
<p>If there is no file at the given path, this function returns false. This function will also fail if the path name is relative. Relative path names refer to the asset directory, which is a read-only directory.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">path</td><td>The file path name </td></tr>
    <tr><td class="paramname">searchable</td><td>Whether the owner may execute (search) this file</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if the file permissions where successfully changed. </dd></dl>

</div>
</div>
<a id="a849d30d82a826eac3b4126e87e5e472e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a849d30d82a826eac3b4126e87e5e472e">&#9670;&nbsp;</a></span>set_searchable() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool cugl::filetool::set_searchable </td>
          <td>(</td>
          <td class="paramtype">const std::string&#160;</td>
          <td class="paramname"><em>path</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>searchable</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>ownerOnly</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Sets the owner's or everybody's execution permission for this path name.</p>
<p>Note that the only form of file execution supported by CUGL is searching a directory.</p>
<p>The owner may or may not be this application. The function will return false if the application does not have permission for this change.</p>
<p>If there is no file at the given path, this function returns false. This function will also fail if the path name is relative. Relative path names refer to the asset directory, which is a read-only directory.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">path</td><td>The file path name </td></tr>
    <tr><td class="paramname">searchable</td><td>Whether this file may be excuted </td></tr>
    <tr><td class="paramname">ownerOnly</td><td>Whether to apply this change only to the owner</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if the file permissions where successfully changed. </dd></dl>

</div>
</div>
<a id="aad2dbe2299e78a1befa3b0e106144476"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aad2dbe2299e78a1befa3b0e106144476">&#9670;&nbsp;</a></span>set_suffix()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const std::string cugl::filetool::set_suffix </td>
          <td>(</td>
          <td class="paramtype">const std::string&#160;</td>
          <td class="paramname"><em>path</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string&#160;</td>
          <td class="paramname"><em>suffix</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns a copy of the path name with the given suffix.</p>
<p>A suffix is any part of the file name after a final period. If there is already a suffix in the path name, this function will replace it with the new one.</p>
<p>This function only affects the path name. It does not affect any file associated with the path name.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">path</td><td>The file path name </td></tr>
    <tr><td class="paramname">suffix</td><td>The suffix to test</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a copy of the path name with the given suffix. </dd></dl>

</div>
</div>
<a id="a917f5e77d53708c38dfa92e15aaca968"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a917f5e77d53708c38dfa92e15aaca968">&#9670;&nbsp;</a></span>set_writable() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool cugl::filetool::set_writable </td>
          <td>(</td>
          <td class="paramtype">const std::string&#160;</td>
          <td class="paramname"><em>path</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>writable</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Sets the owner's write permission for this path name.</p>
<p>The owner may or may not be this application. The function will return false if the application does not have permission for this change.</p>
<p>If there is no file at the given path, this function returns false. This function will also fail if the path name is relative. Relative path names refer to the asset directory, which is a read-only directory.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">path</td><td>The file path name </td></tr>
    <tr><td class="paramname">writable</td><td>Whether the owner may write to this file</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if the file permissions where successfully changed. </dd></dl>

</div>
</div>
<a id="a7d00359ae5f33636704af929a46a59c1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7d00359ae5f33636704af929a46a59c1">&#9670;&nbsp;</a></span>set_writable() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool cugl::filetool::set_writable </td>
          <td>(</td>
          <td class="paramtype">const std::string&#160;</td>
          <td class="paramname"><em>path</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>writable</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>ownerOnly</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Sets the owner's or everybody's write permission for this path name.</p>
<p>The owner may or may not be this application. The function will return false if the application does not have permission for this change.</p>
<p>If there is no file at the given path, this function returns false. This function will also fail if the path name is relative. Relative path names refer to the asset directory, which is a read-only directory.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">path</td><td>The file path name </td></tr>
    <tr><td class="paramname">writable</td><td>Whether this file may be written to </td></tr>
    <tr><td class="paramname">ownerOnly</td><td>Whether to apply this change only to the owner</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if the file permissions where successfully changed. </dd></dl>

</div>
</div>
<a id="a64a00bd36ee24872ed517af198eef1d4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a64a00bd36ee24872ed517af198eef1d4">&#9670;&nbsp;</a></span>split_base()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::pair&lt;std::string, std::string&gt; cugl::filetool::split_base </td>
          <td>(</td>
          <td class="paramtype">const std::string&#160;</td>
          <td class="paramname"><em>path</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns a pair of the prefix and suffix of the leaf file of the path.</p>
<p>A suffix is any part of the file name after a final period. If the path name contains any directories other than the base file, they are ignored.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">path</td><td>The file path name</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a pair of the prefix and suffix of the leaf file of the path. </dd></dl>

</div>
</div>
<a id="adfd451205754f44dc3d2f486255e5db7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adfd451205754f44dc3d2f486255e5db7">&#9670;&nbsp;</a></span>split_path()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::pair&lt;std::string, std::string&gt; cugl::filetool::split_path </td>
          <td>(</td>
          <td class="paramtype">const std::string&#160;</td>
          <td class="paramname"><em>path</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns the pair of a leaf file and its parent directory.</p>
<p>The parent directory will be the first element of the pair. If path is a relative reference to a file with no parent directory then the first element will be the empty string. If the path names ends in a path separator, this will be ignored when determining the leaf.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">path</td><td>The file path name</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the pair of a leaf file and its parent directory. </dd></dl>

</div>
</div>
<a id="af80989d313ef24ce784b7d82d52c8b7d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af80989d313ef24ce784b7d82d52c8b7d">&#9670;&nbsp;</a></span>vol_available_space()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t cugl::filetool::vol_available_space </td>
          <td>(</td>
          <td class="paramtype">const std::string&#160;</td>
          <td class="paramname"><em>path</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns the number of available bytes in the partition for this path name.</p>
<p>The value is for the partition containing the given file or directory. If the path name is relative, it assumes that the path name is in the asset directory.</p>
<p>If the path name does not refer to a proper volume, this function will return 0. On some platforms (e.g. Android) the asset directory is not a proper volume and this function will return 0.</p>
<p>This function is similar to <a class="el" href="namespacecugl_1_1filetool.html#a92e707d56f09a06c9bdb04d1af8262aa">vol_free_space</a> except that it measures the number of bytes available for unpriviledged users.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">path</td><td>The file path name</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the number of available bytes in the partition for this path name. </dd></dl>

</div>
</div>
<a id="a92e707d56f09a06c9bdb04d1af8262aa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a92e707d56f09a06c9bdb04d1af8262aa">&#9670;&nbsp;</a></span>vol_free_space()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t cugl::filetool::vol_free_space </td>
          <td>(</td>
          <td class="paramtype">const std::string&#160;</td>
          <td class="paramname"><em>path</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns the number of unallocated bytes in the partition for this path name.</p>
<p>The value is for the partition containing the given file or directory. If the path name is relative, it assumes that the path name is in the asset directory.</p>
<p>If the path name does not refer to a proper volume, this function will return 0. On some platforms (e.g. Android) the asset directory is not a proper volume and this function will return 0.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">path</td><td>The file path name</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the number of unallocated bytes in the partition for this path name. </dd></dl>

</div>
</div>
<a id="a43e007516e86f97944abbe3507c5680f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a43e007516e86f97944abbe3507c5680f">&#9670;&nbsp;</a></span>vol_total_space()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t cugl::filetool::vol_total_space </td>
          <td>(</td>
          <td class="paramtype">const std::string&#160;</td>
          <td class="paramname"><em>path</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns the size of the partition named by this path name.</p>
<p>The value is for the partition containing the given file or directory. If the path name is relative, it assumes that the path name is in the asset directory.</p>
<p>If the path name does not refer to a proper volume, this function will return 0. On some platforms (e.g. Android) the asset directory is not a proper volume and this function will return 0.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">path</td><td>The file path name</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the size of the partition named by this path name. </dd></dl>

</div>
</div>
<h2 class="groupheader">Variable Documentation</h2>
<a id="accfc65979f7462cb9eae1782f01f8d06"></a>
<h2 class="memtitle"><span class="permalink"><a href="#accfc65979f7462cb9eae1782f01f8d06">&#9670;&nbsp;</a></span>path_sep</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">char cugl::filetool::path_sep</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">extern</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>The system-dependent path separator for this platform. </p>

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.1
</small></address>
</body>
</html>
