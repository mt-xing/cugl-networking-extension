<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.9.1"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>CUGL 2.0: cugl::BaseLoader Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">CUGL 2.0
   </div>
   <div id="projectbrief">Cornell University Game Library</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.1 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search','.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespacecugl.html">cugl</a></li><li class="navelem"><a class="el" href="classcugl_1_1_base_loader.html">BaseLoader</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pro-methods">Protected Member Functions</a> &#124;
<a href="#pro-attribs">Protected Attributes</a> &#124;
<a href="classcugl_1_1_base_loader-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">cugl::BaseLoader Class Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p><code>#include &lt;<a class="el" href="_c_u_loader_8h_source.html">CULoader.h</a>&gt;</code></p>
<div class="dynheader">
Inheritance diagram for cugl::BaseLoader:</div>
<div class="dyncontent">
 <div class="center">
  <img src="classcugl_1_1_base_loader.png" usemap="#cugl::BaseLoader_map" alt=""/>
  <map id="cugl::BaseLoader_map" name="cugl::BaseLoader_map">
<area href="classcugl_1_1_loader.html" alt="cugl::Loader&lt; WidgetValue &gt;" shape="rect" coords="0,112,268,136"/>
<area href="classcugl_1_1_loader.html" alt="cugl::Loader&lt; Texture &gt;" shape="rect" coords="278,112,546,136"/>
<area href="classcugl_1_1_loader.html" alt="cugl::Loader&lt; Sound &gt;" shape="rect" coords="556,112,824,136"/>
<area href="classcugl_1_1_loader.html" alt="cugl::Loader&lt; scene2::SceneNode &gt;" shape="rect" coords="834,112,1102,136"/>
<area href="classcugl_1_1_loader.html" alt="cugl::Loader&lt; JsonValue &gt;" shape="rect" coords="1112,112,1380,136"/>
<area href="classcugl_1_1_loader.html" alt="cugl::Loader&lt; Font &gt;" shape="rect" coords="1390,112,1658,136"/>
<area href="classcugl_1_1_loader.html" alt="cugl::Loader&lt; T &gt;" shape="rect" coords="1668,112,1936,136"/>
<area href="classcugl_1_1_widget_loader.html" alt="cugl::WidgetLoader" shape="rect" coords="0,168,268,192"/>
<area href="classcugl_1_1_texture_loader.html" alt="cugl::TextureLoader" shape="rect" coords="278,168,546,192"/>
<area href="classcugl_1_1_sound_loader.html" alt="cugl::SoundLoader" shape="rect" coords="556,168,824,192"/>
<area href="classcugl_1_1_scene2_loader.html" alt="cugl::Scene2Loader" shape="rect" coords="834,168,1102,192"/>
<area href="classcugl_1_1_json_loader.html" alt="cugl::JsonLoader" shape="rect" coords="1112,168,1380,192"/>
<area href="classcugl_1_1_font_loader.html" alt="cugl::FontLoader" shape="rect" coords="1390,168,1658,192"/>
<area href="classcugl_1_1_generic_loader.html" alt="cugl::GenericLoader&lt; T &gt;" shape="rect" coords="1668,168,1936,192"/>
  </map>
</div></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a3e44e2ac3da383bb197a64afea6295e3"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1_base_loader.html#a3e44e2ac3da383bb197a64afea6295e3">BaseLoader</a> ()</td></tr>
<tr class="separator:a3e44e2ac3da383bb197a64afea6295e3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa75929fdec570561008157e8d68733a0"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1_base_loader.html#aa75929fdec570561008157e8d68733a0">~BaseLoader</a> ()</td></tr>
<tr class="separator:aa75929fdec570561008157e8d68733a0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3116375ae9f085bcf324c93173384047"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1_base_loader.html#a3116375ae9f085bcf324c93173384047">dispose</a> ()</td></tr>
<tr class="separator:a3116375ae9f085bcf324c93173384047"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9f4bcf9ab92b3ffdc4433852a85c0ad1"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1_base_loader.html#a9f4bcf9ab92b3ffdc4433852a85c0ad1">init</a> ()</td></tr>
<tr class="separator:a9f4bcf9ab92b3ffdc4433852a85c0ad1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a51be38ac0cfdb90001013c0fd7aa4b9b"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1_base_loader.html#a51be38ac0cfdb90001013c0fd7aa4b9b">init</a> (const std::shared_ptr&lt; <a class="el" href="classcugl_1_1_thread_pool.html">ThreadPool</a> &gt; &amp;threads)</td></tr>
<tr class="separator:a51be38ac0cfdb90001013c0fd7aa4b9b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a747c137667f2836413c8dfafccd04664"><td class="memItemLeft" align="right" valign="top">std::shared_ptr&lt; <a class="el" href="classcugl_1_1_base_loader.html">BaseLoader</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1_base_loader.html#a747c137667f2836413c8dfafccd04664">getHook</a> ()</td></tr>
<tr class="separator:a747c137667f2836413c8dfafccd04664"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2ee13cb49b4df912981abb660c3c55b8"><td class="memItemLeft" align="right" valign="top">std::shared_ptr&lt; <a class="el" href="classcugl_1_1_thread_pool.html">ThreadPool</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1_base_loader.html#a2ee13cb49b4df912981abb660c3c55b8">getThreadPool</a> () const</td></tr>
<tr class="separator:a2ee13cb49b4df912981abb660c3c55b8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a474c54be4615eecb57912310cf4a76b0"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1_base_loader.html#a474c54be4615eecb57912310cf4a76b0">setThreadPool</a> (const std::shared_ptr&lt; <a class="el" href="classcugl_1_1_thread_pool.html">ThreadPool</a> &gt; &amp;threads)</td></tr>
<tr class="separator:a474c54be4615eecb57912310cf4a76b0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ace50c1eff2e013cbbcbb3bb7554c2d0f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1_base_loader.html#ace50c1eff2e013cbbcbb3bb7554c2d0f">setManager</a> (<a class="el" href="classcugl_1_1_asset_manager.html">AssetManager</a> *manager)</td></tr>
<tr class="separator:ace50c1eff2e013cbbcbb3bb7554c2d0f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab3c2cb579d1b66ec280554dec02847c6"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classcugl_1_1_asset_manager.html">AssetManager</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1_base_loader.html#ab3c2cb579d1b66ec280554dec02847c6">getManager</a> () const</td></tr>
<tr class="separator:ab3c2cb579d1b66ec280554dec02847c6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a54100cd81819d774291111b504f86853"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1_base_loader.html#a54100cd81819d774291111b504f86853">load</a> (const std::string &amp;key, const std::string &amp;source)</td></tr>
<tr class="separator:a54100cd81819d774291111b504f86853"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2bd1602f531845bcb990666218574b5c"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1_base_loader.html#a2bd1602f531845bcb990666218574b5c">load</a> (const char *key, const std::string &amp;source)</td></tr>
<tr class="separator:a2bd1602f531845bcb990666218574b5c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4808402d2c1b6ebf3e10dd30d6aab135"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1_base_loader.html#a4808402d2c1b6ebf3e10dd30d6aab135">load</a> (const std::string &amp;key, const char *source)</td></tr>
<tr class="separator:a4808402d2c1b6ebf3e10dd30d6aab135"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a68099ab72c4edf19bb0fac89d0f4cee4"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1_base_loader.html#a68099ab72c4edf19bb0fac89d0f4cee4">load</a> (const char *key, const char *source)</td></tr>
<tr class="separator:a68099ab72c4edf19bb0fac89d0f4cee4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a977d270bee0dc5a1819a040a2b325f9e"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1_base_loader.html#a977d270bee0dc5a1819a040a2b325f9e">load</a> (const std::shared_ptr&lt; <a class="el" href="classcugl_1_1_json_value.html">JsonValue</a> &gt; &amp;json)</td></tr>
<tr class="separator:a977d270bee0dc5a1819a040a2b325f9e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a02abfeaf208c29096de7f941b7e6e884"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1_base_loader.html#a02abfeaf208c29096de7f941b7e6e884">loadAsync</a> (const std::string &amp;key, const std::string &amp;source, <a class="el" href="namespacecugl.html#ac1cdcaf6dfb69489927e8533a2213d6d">LoaderCallback</a> callback)</td></tr>
<tr class="separator:a02abfeaf208c29096de7f941b7e6e884"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afc4df1e987d6e19c9e0c7217e2bfd21c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1_base_loader.html#afc4df1e987d6e19c9e0c7217e2bfd21c">loadAsync</a> (const char *key, const std::string &amp;source, <a class="el" href="namespacecugl.html#ac1cdcaf6dfb69489927e8533a2213d6d">LoaderCallback</a> callback)</td></tr>
<tr class="separator:afc4df1e987d6e19c9e0c7217e2bfd21c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a65d2d89fe70cda37bef64ada3aa71ef2"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1_base_loader.html#a65d2d89fe70cda37bef64ada3aa71ef2">loadAsync</a> (const std::string &amp;key, const char *source, <a class="el" href="namespacecugl.html#ac1cdcaf6dfb69489927e8533a2213d6d">LoaderCallback</a> callback)</td></tr>
<tr class="separator:a65d2d89fe70cda37bef64ada3aa71ef2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae11fb18ad56cf4e4a0b8f186e80142ea"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1_base_loader.html#ae11fb18ad56cf4e4a0b8f186e80142ea">loadAsync</a> (const char *key, const char *source, <a class="el" href="namespacecugl.html#ac1cdcaf6dfb69489927e8533a2213d6d">LoaderCallback</a> callback)</td></tr>
<tr class="separator:ae11fb18ad56cf4e4a0b8f186e80142ea"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7a67e89e2d2169fdf93b88b5edf900bf"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1_base_loader.html#a7a67e89e2d2169fdf93b88b5edf900bf">loadAsync</a> (const std::shared_ptr&lt; <a class="el" href="classcugl_1_1_json_value.html">JsonValue</a> &gt; &amp;json, <a class="el" href="namespacecugl.html#ac1cdcaf6dfb69489927e8533a2213d6d">LoaderCallback</a> callback)</td></tr>
<tr class="separator:a7a67e89e2d2169fdf93b88b5edf900bf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a760ee62f0e354a1887899f6abfddec6c"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1_base_loader.html#a760ee62f0e354a1887899f6abfddec6c">unload</a> (const std::string &amp;key)</td></tr>
<tr class="separator:a760ee62f0e354a1887899f6abfddec6c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a23185f9343c400573fd5d6dbb3d27b32"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1_base_loader.html#a23185f9343c400573fd5d6dbb3d27b32">unload</a> (const char *key)</td></tr>
<tr class="separator:a23185f9343c400573fd5d6dbb3d27b32"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ade0a13bc4e7537b0d2cf5acad5b608b7"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1_base_loader.html#ade0a13bc4e7537b0d2cf5acad5b608b7">unload</a> (const std::shared_ptr&lt; <a class="el" href="classcugl_1_1_json_value.html">JsonValue</a> &gt; &amp;json)</td></tr>
<tr class="separator:ade0a13bc4e7537b0d2cf5acad5b608b7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a57501d6479fade1107ebc6667e6fb9f4"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1_base_loader.html#a57501d6479fade1107ebc6667e6fb9f4">unloadAll</a> ()</td></tr>
<tr class="separator:a57501d6479fade1107ebc6667e6fb9f4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1abc6e17eb76be4972ecbe6f31180029"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1_base_loader.html#a1abc6e17eb76be4972ecbe6f31180029">contains</a> (const std::string &amp;key) const</td></tr>
<tr class="separator:a1abc6e17eb76be4972ecbe6f31180029"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a97db5400504d7a41de26928e5c0a8725"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1_base_loader.html#a97db5400504d7a41de26928e5c0a8725">contains</a> (const char *key) const</td></tr>
<tr class="separator:a97db5400504d7a41de26928e5c0a8725"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5258e8bb13e82f5dd5c8f3cdcd27ef76"><td class="memItemLeft" align="right" valign="top">virtual size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1_base_loader.html#a5258e8bb13e82f5dd5c8f3cdcd27ef76">loadCount</a> () const</td></tr>
<tr class="separator:a5258e8bb13e82f5dd5c8f3cdcd27ef76"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4bd35ece637a736aa7a7974249e5b61f"><td class="memItemLeft" align="right" valign="top">virtual size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1_base_loader.html#a4bd35ece637a736aa7a7974249e5b61f">waitCount</a> () const</td></tr>
<tr class="separator:a4bd35ece637a736aa7a7974249e5b61f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac4006745ff95fb50a61360a9765c68f4"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1_base_loader.html#ac4006745ff95fb50a61360a9765c68f4">complete</a> () const</td></tr>
<tr class="separator:ac4006745ff95fb50a61360a9765c68f4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2a8c1107c32b2fe132be2de335739dd8"><td class="memItemLeft" align="right" valign="top">float&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1_base_loader.html#a2a8c1107c32b2fe132be2de335739dd8">progress</a> () const</td></tr>
<tr class="separator:a2a8c1107c32b2fe132be2de335739dd8"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pro-methods"></a>
Protected Member Functions</h2></td></tr>
<tr class="memitem:a3516371a6011f05175babc811c998af3"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1_base_loader.html#a3516371a6011f05175babc811c998af3">read</a> (const std::string &amp;key, const std::string &amp;source, <a class="el" href="namespacecugl.html#ac1cdcaf6dfb69489927e8533a2213d6d">LoaderCallback</a> callback, bool async)</td></tr>
<tr class="separator:a3516371a6011f05175babc811c998af3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a65450d28c162915d3125a0d5d7e41916"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1_base_loader.html#a65450d28c162915d3125a0d5d7e41916">read</a> (const std::shared_ptr&lt; <a class="el" href="classcugl_1_1_json_value.html">JsonValue</a> &gt; &amp;json, <a class="el" href="namespacecugl.html#ac1cdcaf6dfb69489927e8533a2213d6d">LoaderCallback</a> callback, bool async)</td></tr>
<tr class="separator:a65450d28c162915d3125a0d5d7e41916"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aead492ed6ade8c15fe66cab70ea2a394"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1_base_loader.html#aead492ed6ade8c15fe66cab70ea2a394">purge</a> (const std::string &amp;key)</td></tr>
<tr class="separator:aead492ed6ade8c15fe66cab70ea2a394"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a48102dffad974a866516e915f373d471"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1_base_loader.html#a48102dffad974a866516e915f373d471">purge</a> (const std::shared_ptr&lt; <a class="el" href="classcugl_1_1_json_value.html">JsonValue</a> &gt; &amp;json)</td></tr>
<tr class="separator:a48102dffad974a866516e915f373d471"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a67c8e28e5746d5a9527dd2a5b7883ab0"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1_base_loader.html#a67c8e28e5746d5a9527dd2a5b7883ab0">verify</a> (const std::string &amp;key) const</td></tr>
<tr class="separator:a67c8e28e5746d5a9527dd2a5b7883ab0"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pro-attribs"></a>
Protected Attributes</h2></td></tr>
<tr class="memitem:af3047a1c594473a433a1eead29e3c99f"><td class="memItemLeft" align="right" valign="top">std::shared_ptr&lt; <a class="el" href="classcugl_1_1_thread_pool.html">ThreadPool</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1_base_loader.html#af3047a1c594473a433a1eead29e3c99f">_loader</a></td></tr>
<tr class="separator:af3047a1c594473a433a1eead29e3c99f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a500bebffc5d3818af46431bc83fa03ad"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classcugl_1_1_asset_manager.html">AssetManager</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1_base_loader.html#a500bebffc5d3818af46431bc83fa03ad">_manager</a></td></tr>
<tr class="separator:a500bebffc5d3818af46431bc83fa03ad"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>This class provides a polymorphic base to the loader system.</p>
<p>This is effectively a Java-style interface. It identifies the methods that all loaders must have, and provides a type for the <a class="el" href="classcugl_1_1_asset_manager.html">AssetManager</a> to use in its underlying storage container.</p>
<p>IMPORTANT: This class is not even remotely thread-safe. Do not call any of these methods outside of the main CUGL thread. </p>
</div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="a3e44e2ac3da383bb197a64afea6295e3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3e44e2ac3da383bb197a64afea6295e3">&#9670;&nbsp;</a></span>BaseLoader()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">cugl::BaseLoader::BaseLoader </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Creates a degenerate asset loader with no resources</p>
<p>NEVER CALL THIS CONSTRUCTOR. As this is an abstract class, you should call one of the static constructors of the appropriate child class. </p>

</div>
</div>
<a id="aa75929fdec570561008157e8d68733a0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa75929fdec570561008157e8d68733a0">&#9670;&nbsp;</a></span>~BaseLoader()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">cugl::BaseLoader::~BaseLoader </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Deletes this asset loader, disposing of all resources. </p>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="ac4006745ff95fb50a61360a9765c68f4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac4006745ff95fb50a61360a9765c68f4">&#9670;&nbsp;</a></span>complete()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool cugl::BaseLoader::complete </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns true if the loader has finished loading all assets.</p>
<p>It is not safe to use asynchronously loaded assets until all loading is complete. This method allows us to determine when asset loading is complete via polling.</p>
<dl class="section return"><dt>Returns</dt><dd>true if the loader has finished loading all assets. </dd></dl>

</div>
</div>
<a id="a97db5400504d7a41de26928e5c0a8725"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a97db5400504d7a41de26928e5c0a8725">&#9670;&nbsp;</a></span>contains() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool cugl::BaseLoader::contains </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>key</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns true if the key maps to a loaded asset.</p>
<p>This method is useful in case the asset fails to load.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">key</td><td>the key associated with the asset</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if the key maps to a loaded asset. </dd></dl>

</div>
</div>
<a id="a1abc6e17eb76be4972ecbe6f31180029"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1abc6e17eb76be4972ecbe6f31180029">&#9670;&nbsp;</a></span>contains() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool cugl::BaseLoader::contains </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>key</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns true if the key maps to a loaded asset.</p>
<p>This method is useful in case the asset fails to load.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">key</td><td>the key associated with the asset</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if the key maps to a loaded asset. </dd></dl>

</div>
</div>
<a id="a3116375ae9f085bcf324c93173384047"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3116375ae9f085bcf324c93173384047">&#9670;&nbsp;</a></span>dispose()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void cugl::BaseLoader::dispose </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Disposes all resources and assets of this loader</p>
<p>Any assets loaded by this object will be immediately released by the loader. However, an asset may still be available if it is referenced by another smart pointer. See the description of the specific implementation for how assets are released.</p>
<p>Once the loader is disposed, any attempts to load a new asset will fail. You must reinitialize the loader to begin loading assets again.</p>
<p>This method is abstract and should be overridden in the specific implementation for each asset. </p>

<p>Reimplemented in <a class="el" href="classcugl_1_1_widget_loader.html#ae27dfdae900867324cab0d1f7b9e1d9f">cugl::WidgetLoader</a>, <a class="el" href="classcugl_1_1_texture_loader.html#acad3dc9f00d811d70d07b8a29139639f">cugl::TextureLoader</a>, <a class="el" href="classcugl_1_1_sound_loader.html#a3f4759b3de5ea1ac4a8ffcbdc25affba">cugl::SoundLoader</a>, <a class="el" href="classcugl_1_1_scene2_loader.html#a1a3af190c89905f1bcffcd65217c9ca1">cugl::Scene2Loader</a>, <a class="el" href="classcugl_1_1_json_loader.html#a05294ef55a3901b9dd17e0e57d02b14f">cugl::JsonLoader</a>, <a class="el" href="classcugl_1_1_generic_loader.html#a4a9f7016220e04ef74e185af9fc085f7">cugl::GenericLoader&lt; T &gt;</a>, and <a class="el" href="classcugl_1_1_font_loader.html#aae5607b67073f47dc0701a175ef5b6af">cugl::FontLoader</a>.</p>

</div>
</div>
<a id="a747c137667f2836413c8dfafccd04664"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a747c137667f2836413c8dfafccd04664">&#9670;&nbsp;</a></span>getHook()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::shared_ptr&lt;<a class="el" href="classcugl_1_1_base_loader.html">BaseLoader</a>&gt; cugl::BaseLoader::getHook </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns a pointer for attaching this loader to an <a class="el" href="classcugl_1_1_asset_manager.html">AssetManager</a>.</p>
<p>Smart pointers are great, and all asset loaders should be referenced by one. However, polymorphism and smart pointers really do not mix and type casting can be quite tricky. This method provides a simple interface for handling this type case.</p>
<dl class="section return"><dt>Returns</dt><dd>a pointer for attaching this loader to an <a class="el" href="classcugl_1_1_asset_manager.html">AssetManager</a>. </dd></dl>

</div>
</div>
<a id="ab3c2cb579d1b66ec280554dec02847c6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab3c2cb579d1b66ec280554dec02847c6">&#9670;&nbsp;</a></span>getManager()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classcugl_1_1_asset_manager.html">AssetManager</a>* cugl::BaseLoader::getManager </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns the asset manager for this loader.</p>
<p>The asset manager allows this loader to access previously loaded assets. This allows materialization of complex, dependent assets.</p>
<dl class="section return"><dt>Returns</dt><dd>the asset manager for this loader </dd></dl>

</div>
</div>
<a id="a2ee13cb49b4df912981abb660c3c55b8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2ee13cb49b4df912981abb660c3c55b8">&#9670;&nbsp;</a></span>getThreadPool()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::shared_ptr&lt;<a class="el" href="classcugl_1_1_thread_pool.html">ThreadPool</a>&gt; cugl::BaseLoader::getThreadPool </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns the thread pool attached to this loader</p>
<p>The thread pool is used for asynchronous loading. Multiple asset loaders can share the same thread pool. This keeps the system from being overloaded by a large number of threads.</p>
<dl class="section return"><dt>Returns</dt><dd>the thread pool attached to this loader </dd></dl>

</div>
</div>
<a id="a9f4bcf9ab92b3ffdc4433852a85c0ad1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9f4bcf9ab92b3ffdc4433852a85c0ad1">&#9670;&nbsp;</a></span>init() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool cugl::BaseLoader::init </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Initializes a new asset loader.</p>
<p>This method bootstraps the loader with any initial resources that it needs to load assets. Attempts to load an asset before this method is called will fail.</p>
<p>This loader will have no associated threads. That means any asynchronous loading will fail until a thread is provided via <a class="el" href="classcugl_1_1_base_loader.html#a474c54be4615eecb57912310cf4a76b0">setThreadPool</a>.</p>
<p>This method is abstract and should be overridden in the specific implementation for each asset.</p>
<dl class="section return"><dt>Returns</dt><dd>true if the asset loader was initialized successfully </dd></dl>

<p>Reimplemented in <a class="el" href="classcugl_1_1_scene2_loader.html#ad29b950d392db24886e899c174062f67">cugl::Scene2Loader</a>.</p>

</div>
</div>
<a id="a51be38ac0cfdb90001013c0fd7aa4b9b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a51be38ac0cfdb90001013c0fd7aa4b9b">&#9670;&nbsp;</a></span>init() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool cugl::BaseLoader::init </td>
          <td>(</td>
          <td class="paramtype">const std::shared_ptr&lt; <a class="el" href="classcugl_1_1_thread_pool.html">ThreadPool</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>threads</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Initializes a new asset loader.</p>
<p>This method bootstraps the loader with any initial resources that it needs to load assets. Attempts to load an asset before this method is called will fail.</p>
<p>This method is abstract and should be overridden in the specific implementation for each asset.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">threads</td><td>The thread pool for asynchronous loading support</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if the asset loader was initialized successfully </dd></dl>

<p>Reimplemented in <a class="el" href="classcugl_1_1_scene2_loader.html#a83b70650c0cc9c27a7725b6315056382">cugl::Scene2Loader</a>.</p>

</div>
</div>
<a id="a68099ab72c4edf19bb0fac89d0f4cee4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a68099ab72c4edf19bb0fac89d0f4cee4">&#9670;&nbsp;</a></span>load() <span class="overload">[1/5]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool cugl::BaseLoader::load </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>source</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Synchronously loads the given asset with the specified key.</p>
<p>The asset will be loaded synchronously, which means the main CUGL thread will block until loading is complete. When it is finished loading, the asset will be added to the contents loader, and accessible under the given key.</p>
<p>This method is abstract and should be overridden in child classes to support the appropriate asset type.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">key</td><td>The key to access the asset after loading </td></tr>
    <tr><td class="paramname">source</td><td>The pathname to the asset</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if the asset was successfully loaded </dd></dl>

</div>
</div>
<a id="a2bd1602f531845bcb990666218574b5c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2bd1602f531845bcb990666218574b5c">&#9670;&nbsp;</a></span>load() <span class="overload">[2/5]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool cugl::BaseLoader::load </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>source</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Synchronously loads the given asset with the specified key.</p>
<p>The asset will be loaded synchronously, which means the main CUGL thread will block until loading is complete. When it is finished loading, the asset will be added to the contents loader, and accessible under the given key.</p>
<p>This method is abstract and should be overridden in child classes to support the appropriate asset type.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">key</td><td>The key to access the asset after loading </td></tr>
    <tr><td class="paramname">source</td><td>The pathname to the asset</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if the asset was successfully loaded </dd></dl>

</div>
</div>
<a id="a977d270bee0dc5a1819a040a2b325f9e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a977d270bee0dc5a1819a040a2b325f9e">&#9670;&nbsp;</a></span>load() <span class="overload">[3/5]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool cugl::BaseLoader::load </td>
          <td>(</td>
          <td class="paramtype">const std::shared_ptr&lt; <a class="el" href="classcugl_1_1_json_value.html">JsonValue</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>json</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Synchronously loads the given asset with the specified key.</p>
<p>The asset will be loaded synchronously, which means the main CUGL thread will block until loading is complete. When it is finished loading, the asset will be added to the contents loader, and accessible under the given key.</p>
<p>This version of load provides support for JSON directories. The exact format of the directory entry is up to you. However, unless the asset is one of the five basic types, it will not be supported by <a class="el" href="classcugl_1_1_asset_manager.html">AssetManager</a>. You will need to load the directory manually in that case.</p>
<p>This method is abstract and should be overridden in child classes to support the appropriate asset type.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">json</td><td>The directory entry for the asset</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if the asset was successfully loaded </dd></dl>

</div>
</div>
<a id="a4808402d2c1b6ebf3e10dd30d6aab135"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4808402d2c1b6ebf3e10dd30d6aab135">&#9670;&nbsp;</a></span>load() <span class="overload">[4/5]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool cugl::BaseLoader::load </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>source</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Synchronously loads the given asset with the specified key.</p>
<p>The asset will be loaded synchronously, which means the main CUGL thread will block until loading is complete. When it is finished loading, the asset will be added to the contents loader, and accessible under the given key.</p>
<p>This method is abstract and should be overridden in child classes to support the appropriate asset type.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">key</td><td>The key to access the asset after loading </td></tr>
    <tr><td class="paramname">source</td><td>The pathname to the asset</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if the asset was successfully loaded </dd></dl>

</div>
</div>
<a id="a54100cd81819d774291111b504f86853"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a54100cd81819d774291111b504f86853">&#9670;&nbsp;</a></span>load() <span class="overload">[5/5]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool cugl::BaseLoader::load </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>source</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Synchronously loads the given asset with the specified key.</p>
<p>The asset will be loaded synchronously, which means the main CUGL thread will block until loading is complete. When it is finished loading, the asset will be added to the contents loader, and accessible under the given key.</p>
<p>This method is abstract and should be overridden in child classes to support the appropriate asset type.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">key</td><td>The key to access the asset after loading </td></tr>
    <tr><td class="paramname">source</td><td>The pathname to the asset</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if the asset was successfully loaded </dd></dl>

</div>
</div>
<a id="ae11fb18ad56cf4e4a0b8f186e80142ea"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae11fb18ad56cf4e4a0b8f186e80142ea">&#9670;&nbsp;</a></span>loadAsync() <span class="overload">[1/5]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void cugl::BaseLoader::loadAsync </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>source</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacecugl.html#ac1cdcaf6dfb69489927e8533a2213d6d">LoaderCallback</a>&#160;</td>
          <td class="paramname"><em>callback</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Asynchronously loads the given asset with the specified key.</p>
<p>The asset will be loaded asynchronously. When it is finished loading, the asset will be added to this loader, and accessible under the given key. This method will mark the loading process as not complete, even if it was completed previously. It is not safe to access the loaded asset until it is complete again.</p>
<p>The optional callback function will be called with the asset status when it either finishes loading or fails to load.</p>
<p>This method is abstract and should be overridden in child classes to support the appropriate asset type.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">key</td><td>The key to access the asset after loading </td></tr>
    <tr><td class="paramname">source</td><td>The pathname to the asset </td></tr>
    <tr><td class="paramname">callback</td><td>An optional callback for asynchronous loading </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="afc4df1e987d6e19c9e0c7217e2bfd21c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afc4df1e987d6e19c9e0c7217e2bfd21c">&#9670;&nbsp;</a></span>loadAsync() <span class="overload">[2/5]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void cugl::BaseLoader::loadAsync </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>source</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacecugl.html#ac1cdcaf6dfb69489927e8533a2213d6d">LoaderCallback</a>&#160;</td>
          <td class="paramname"><em>callback</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Asynchronously loads the given asset with the specified key.</p>
<p>The asset will be loaded asynchronously. When it is finished loading, the asset will be added to this loader, and accessible under the given key. This method will mark the loading process as not complete, even if it was completed previously. It is not safe to access the loaded asset until it is complete again.</p>
<p>The optional callback function will be called with the asset status when it either finishes loading or fails to load.</p>
<p>This method is abstract and should be overridden in child classes to support the appropriate asset type.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">key</td><td>The key to access the asset after loading </td></tr>
    <tr><td class="paramname">source</td><td>The pathname to the asset </td></tr>
    <tr><td class="paramname">callback</td><td>An optional callback for asynchronous loading </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a7a67e89e2d2169fdf93b88b5edf900bf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7a67e89e2d2169fdf93b88b5edf900bf">&#9670;&nbsp;</a></span>loadAsync() <span class="overload">[3/5]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void cugl::BaseLoader::loadAsync </td>
          <td>(</td>
          <td class="paramtype">const std::shared_ptr&lt; <a class="el" href="classcugl_1_1_json_value.html">JsonValue</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>json</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacecugl.html#ac1cdcaf6dfb69489927e8533a2213d6d">LoaderCallback</a>&#160;</td>
          <td class="paramname"><em>callback</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Asynchronously loads the given asset with the specified key.</p>
<p>The asset will be loaded asynchronously. When it is finished loading, the asset will be added to this loader, and accessible under the given key. This method will mark the loading process as not complete, even if it was completed previously. It is not safe to access the loaded asset until it is complete again.</p>
<p>This version of loadAsync provides support for JSON directories. The exact format of the directory entry is up to you. However, unless the asset is one of the five basic types, it will not be supported by <a class="el" href="classcugl_1_1_asset_manager.html">AssetManager</a>. You will need to load the directory manually in that case.</p>
<p>The optional callback function will be called with the asset status when it either finishes loading or fails to load.</p>
<p>This method is abstract and should be overridden in child classes to support the appropriate asset type.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">json</td><td>The JSON entry (and key) associated with the asset </td></tr>
    <tr><td class="paramname">callback</td><td>An optional callback for asynchronous loading </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a65d2d89fe70cda37bef64ada3aa71ef2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a65d2d89fe70cda37bef64ada3aa71ef2">&#9670;&nbsp;</a></span>loadAsync() <span class="overload">[4/5]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void cugl::BaseLoader::loadAsync </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>source</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacecugl.html#ac1cdcaf6dfb69489927e8533a2213d6d">LoaderCallback</a>&#160;</td>
          <td class="paramname"><em>callback</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Asynchronously loads the given asset with the specified key.</p>
<p>The asset will be loaded asynchronously. When it is finished loading, the asset will be added to this loader, and accessible under the given key. This method will mark the loading process as not complete, even if it was completed previously. It is not safe to access the loaded asset until it is complete again.</p>
<p>The optional callback function will be called with the asset status when it either finishes loading or fails to load.</p>
<p>This method is abstract and should be overridden in child classes to support the appropriate asset type.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">key</td><td>The key to access the asset after loading </td></tr>
    <tr><td class="paramname">source</td><td>The pathname to the asset </td></tr>
    <tr><td class="paramname">callback</td><td>An optional callback for asynchronous loading </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a02abfeaf208c29096de7f941b7e6e884"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a02abfeaf208c29096de7f941b7e6e884">&#9670;&nbsp;</a></span>loadAsync() <span class="overload">[5/5]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void cugl::BaseLoader::loadAsync </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>source</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacecugl.html#ac1cdcaf6dfb69489927e8533a2213d6d">LoaderCallback</a>&#160;</td>
          <td class="paramname"><em>callback</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Asynchronously loads the given asset with the specified key.</p>
<p>The asset will be loaded asynchronously. When it is finished loading, the asset will be added to this loader, and accessible under the given key. This method will mark the loading process as not complete, even if it was completed previously. It is not safe to access the loaded asset until it is complete again.</p>
<p>The optional callback function will be called with the asset status when it either finishes loading or fails to load.</p>
<p>This method is abstract and should be overridden in child classes to support the appropriate asset type.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">key</td><td>The key to access the asset after loading </td></tr>
    <tr><td class="paramname">source</td><td>The pathname to the asset </td></tr>
    <tr><td class="paramname">callback</td><td>An optional callback for asynchronous loading </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a5258e8bb13e82f5dd5c8f3cdcd27ef76"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5258e8bb13e82f5dd5c8f3cdcd27ef76">&#9670;&nbsp;</a></span>loadCount()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual size_t cugl::BaseLoader::loadCount </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns the number of assets currently loaded.</p>
<p>This is a rough way to determine how many assets have been loaded so far. This method counts each asset equally regardless of the memory requirements of each asset.</p>
<p>This method is abstract and should be overridden in child classes to support the appropriate asset type.</p>
<dl class="section return"><dt>Returns</dt><dd>the number of assets currently loaded. </dd></dl>

<p>Reimplemented in <a class="el" href="classcugl_1_1_loader.html#a4bd69040c57b7446794ddff451c9d805">cugl::Loader&lt; T &gt;</a>, <a class="el" href="classcugl_1_1_loader.html#a4bd69040c57b7446794ddff451c9d805">cugl::Loader&lt; WidgetValue &gt;</a>, <a class="el" href="classcugl_1_1_loader.html#a4bd69040c57b7446794ddff451c9d805">cugl::Loader&lt; Texture &gt;</a>, <a class="el" href="classcugl_1_1_loader.html#a4bd69040c57b7446794ddff451c9d805">cugl::Loader&lt; Sound &gt;</a>, <a class="el" href="classcugl_1_1_loader.html#a4bd69040c57b7446794ddff451c9d805">cugl::Loader&lt; scene2::SceneNode &gt;</a>, <a class="el" href="classcugl_1_1_loader.html#a4bd69040c57b7446794ddff451c9d805">cugl::Loader&lt; JsonValue &gt;</a>, and <a class="el" href="classcugl_1_1_loader.html#a4bd69040c57b7446794ddff451c9d805">cugl::Loader&lt; Font &gt;</a>.</p>

</div>
</div>
<a id="a2a8c1107c32b2fe132be2de335739dd8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2a8c1107c32b2fe132be2de335739dd8">&#9670;&nbsp;</a></span>progress()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">float cugl::BaseLoader::progress </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns the loader progress as a percentage.</p>
<p>This method returns a value between 0 and 1. A value of 0 means no assets have been loaded. A value of 1 means that all assets have been loaded.</p>
<p>Anything in-between indicates that there are assets which have been loaded asynchronously and have not completed loading. It is not safe to use asynchronously loaded assets until all loading is complete.</p>
<dl class="section return"><dt>Returns</dt><dd>the loader progress as a percentage. </dd></dl>

</div>
</div>
<a id="a48102dffad974a866516e915f373d471"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a48102dffad974a866516e915f373d471">&#9670;&nbsp;</a></span>purge() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool cugl::BaseLoader::purge </td>
          <td>(</td>
          <td class="paramtype">const std::shared_ptr&lt; <a class="el" href="classcugl_1_1_json_value.html">JsonValue</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>json</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">protected</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Unloads the asset for the given directory entry</p>
<p>An asset may still be available if it is referenced by a smart pointer. See the description of the specific implementation for how assets are released.</p>
<p>This method is abstract and should be overridden in child classes. You will notice that this method is essentially identical to unload. We separated the methods because overloading and virtual methods do not place nice.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">json</td><td>The directory entry for the asset</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if the asset was successfully unloaded </dd></dl>

<p>Reimplemented in <a class="el" href="classcugl_1_1_texture_loader.html#ac784539ed166d1e7609c5aeb9b96ebeb">cugl::TextureLoader</a>, and <a class="el" href="classcugl_1_1_scene2_loader.html#ad08ec6546c01d2cc841886648f452761">cugl::Scene2Loader</a>.</p>

</div>
</div>
<a id="aead492ed6ade8c15fe66cab70ea2a394"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aead492ed6ade8c15fe66cab70ea2a394">&#9670;&nbsp;</a></span>purge() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool cugl::BaseLoader::purge </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>key</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">protected</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Unloads the asset for the given key</p>
<p>An asset may still be available if it is referenced by a smart pointer. See the description of the specific implementation for how assets are released.</p>
<p>This method is abstract and should be overridden in child classes. You will notice that this method is essentially identical to unload. We separated the methods because overloading and virtual methods do not place nice. </p><dl class="section return"><dt>Returns</dt><dd>true if the asset was successfully unloaded </dd></dl>

<p>Reimplemented in <a class="el" href="classcugl_1_1_loader.html#a4a49f580c27721663c85c1ce9c8d7721">cugl::Loader&lt; T &gt;</a>, <a class="el" href="classcugl_1_1_loader.html#a4a49f580c27721663c85c1ce9c8d7721">cugl::Loader&lt; WidgetValue &gt;</a>, <a class="el" href="classcugl_1_1_loader.html#a4a49f580c27721663c85c1ce9c8d7721">cugl::Loader&lt; Texture &gt;</a>, <a class="el" href="classcugl_1_1_loader.html#a4a49f580c27721663c85c1ce9c8d7721">cugl::Loader&lt; Sound &gt;</a>, <a class="el" href="classcugl_1_1_loader.html#a4a49f580c27721663c85c1ce9c8d7721">cugl::Loader&lt; scene2::SceneNode &gt;</a>, <a class="el" href="classcugl_1_1_loader.html#a4a49f580c27721663c85c1ce9c8d7721">cugl::Loader&lt; JsonValue &gt;</a>, and <a class="el" href="classcugl_1_1_loader.html#a4a49f580c27721663c85c1ce9c8d7721">cugl::Loader&lt; Font &gt;</a>.</p>

</div>
</div>
<a id="a65450d28c162915d3125a0d5d7e41916"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a65450d28c162915d3125a0d5d7e41916">&#9670;&nbsp;</a></span>read() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool cugl::BaseLoader::read </td>
          <td>(</td>
          <td class="paramtype">const std::shared_ptr&lt; <a class="el" href="classcugl_1_1_json_value.html">JsonValue</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>json</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacecugl.html#ac1cdcaf6dfb69489927e8533a2213d6d">LoaderCallback</a>&#160;</td>
          <td class="paramname"><em>callback</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>async</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">protected</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Internal method to support asset loading.</p>
<p>This method supports either synchronous or asynchronous loading, as specified by the given parameter. If the loading is asynchronous, the user may specify an optional callback function.</p>
<p>This method is abstract and should be overridden in child classes to support the appropriate asset type.</p>
<p>This version of read provides support for JSON directories. The exact exact format of the directory entry is up to you. However, unless the asset is one of the four basic types, it will not be supported by <a class="el" href="classcugl_1_1_asset_manager.html">AssetManager</a>. You will need to load the directory manually in that case.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">json</td><td>The directory entry for the asset </td></tr>
    <tr><td class="paramname">callback</td><td>An optional callback for asynchronous loading </td></tr>
    <tr><td class="paramname">async</td><td>Whether the asset was loaded asynchronously</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if the asset was successfully loaded </dd></dl>

<p>Reimplemented in <a class="el" href="classcugl_1_1_widget_loader.html#a52a0fdfc51a6e81491a2e3518d7dae78">cugl::WidgetLoader</a>, <a class="el" href="classcugl_1_1_texture_loader.html#a41d6e0ebc2b6b4d576a15196e0938bde">cugl::TextureLoader</a>, <a class="el" href="classcugl_1_1_sound_loader.html#a4653d77d7df155f4b814362425b43772">cugl::SoundLoader</a>, <a class="el" href="classcugl_1_1_scene2_loader.html#aa4b2d704e3b03043a50e407edbbe3b78">cugl::Scene2Loader</a>, <a class="el" href="classcugl_1_1_json_loader.html#a26ccb2bd6177f2ea22c790f089bdb115">cugl::JsonLoader</a>, <a class="el" href="classcugl_1_1_generic_loader.html#a55d2fff668ebb81b1d38b9ac16a7f1f7">cugl::GenericLoader&lt; T &gt;</a>, and <a class="el" href="classcugl_1_1_font_loader.html#a1ffdfd7d8960e21f525ba54b23951e41">cugl::FontLoader</a>.</p>

</div>
</div>
<a id="a3516371a6011f05175babc811c998af3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3516371a6011f05175babc811c998af3">&#9670;&nbsp;</a></span>read() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool cugl::BaseLoader::read </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>source</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacecugl.html#ac1cdcaf6dfb69489927e8533a2213d6d">LoaderCallback</a>&#160;</td>
          <td class="paramname"><em>callback</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>async</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">protected</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Internal method to support asset loading.</p>
<p>This method supports either synchronous or asynchronous loading, as specified by the given parameter. If the loading is asynchronous, the user may specify an optional callback function.</p>
<p>This method is abstract and should be overridden in child classes to support the appropriate asset type.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">key</td><td>The key to access the asset after loading </td></tr>
    <tr><td class="paramname">source</td><td>The pathname to the asset </td></tr>
    <tr><td class="paramname">callback</td><td>An optional callback for asynchronous loading </td></tr>
    <tr><td class="paramname">async</td><td>Whether the asset was loaded asynchronously</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if the asset was successfully loaded </dd></dl>

<p>Reimplemented in <a class="el" href="classcugl_1_1_widget_loader.html#a6a134f6b572f7d3d43b3f1c9e46e3f89">cugl::WidgetLoader</a>, <a class="el" href="classcugl_1_1_texture_loader.html#a722cff7bcc4367058ec8416b3b905bbe">cugl::TextureLoader</a>, <a class="el" href="classcugl_1_1_sound_loader.html#ac4840271f87495cb793d06eafc00caf5">cugl::SoundLoader</a>, <a class="el" href="classcugl_1_1_scene2_loader.html#a11701fa0a2a548bdfae6996a5caeae93">cugl::Scene2Loader</a>, <a class="el" href="classcugl_1_1_json_loader.html#aabb580fc672eaef89ce44619cafcde93">cugl::JsonLoader</a>, <a class="el" href="classcugl_1_1_generic_loader.html#a228fc235bf895c786e109766dc528d1f">cugl::GenericLoader&lt; T &gt;</a>, and <a class="el" href="classcugl_1_1_font_loader.html#a99a7f074b95f15157667f5856bc3546e">cugl::FontLoader</a>.</p>

</div>
</div>
<a id="ace50c1eff2e013cbbcbb3bb7554c2d0f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ace50c1eff2e013cbbcbb3bb7554c2d0f">&#9670;&nbsp;</a></span>setManager()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void cugl::BaseLoader::setManager </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classcugl_1_1_asset_manager.html">AssetManager</a> *&#160;</td>
          <td class="paramname"><em>manager</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Sets the asset manager for this loader.</p>
<p>The asset manager allows this loader to access previously loaded assets. This allows materialization of complex, dependent assets.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">manager</td><td>The asset manager </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a474c54be4615eecb57912310cf4a76b0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a474c54be4615eecb57912310cf4a76b0">&#9670;&nbsp;</a></span>setThreadPool()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void cugl::BaseLoader::setThreadPool </td>
          <td>(</td>
          <td class="paramtype">const std::shared_ptr&lt; <a class="el" href="classcugl_1_1_thread_pool.html">ThreadPool</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>threads</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Sets the thread pool attached to this loader</p>
<p>If there was a previously attached thread pool, it will be deleted and the threads will be shutdown. Assets not yet loaded by that thread pool will fail to load. Hence it is unsafe to call this method if the loader is actively loading assets.</p>
<p>The thread pool is used for asynchronous loading. Multiple asset loaders can share the same thread pool. This keeps the system from being overloaded by a large number of threads.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">threads</td><td>The thread pool attached to this loader </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a23185f9343c400573fd5d6dbb3d27b32"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a23185f9343c400573fd5d6dbb3d27b32">&#9670;&nbsp;</a></span>unload() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool cugl::BaseLoader::unload </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>key</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Unloads the asset for the given key</p>
<p>An asset may still be available if it is referenced by a smart pointer. See the description of the specific implementation for how assets are released.</p>
<p>This method is abstract and should be overridden in the child classes.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">key</td><td>the key associated with the asset</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if the asset was successfully unloaded </dd></dl>

</div>
</div>
<a id="ade0a13bc4e7537b0d2cf5acad5b608b7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ade0a13bc4e7537b0d2cf5acad5b608b7">&#9670;&nbsp;</a></span>unload() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool cugl::BaseLoader::unload </td>
          <td>(</td>
          <td class="paramtype">const std::shared_ptr&lt; <a class="el" href="classcugl_1_1_json_value.html">JsonValue</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>json</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Unloads the asset for the given JSON entry</p>
<p>An asset may still be available if it is referenced by a smart pointer. See the description of the specific implementation for how assets are released.</p>
<p>This method is abstract and should be overridden in the child classes.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">json</td><td>the JSON entry (and key) associated with the asset</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if the asset was successfully unloaded </dd></dl>

</div>
</div>
<a id="a760ee62f0e354a1887899f6abfddec6c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a760ee62f0e354a1887899f6abfddec6c">&#9670;&nbsp;</a></span>unload() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool cugl::BaseLoader::unload </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>key</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Unloads the asset for the given key</p>
<p>An asset may still be available if it is referenced by a smart pointer. See the description of the specific implementation for how assets are released.</p>
<p>This method is abstract and should be overridden in child classes.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">key</td><td>the key associated with the asset</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if the asset was successfully unloaded </dd></dl>

</div>
</div>
<a id="a57501d6479fade1107ebc6667e6fb9f4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a57501d6479fade1107ebc6667e6fb9f4">&#9670;&nbsp;</a></span>unloadAll()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void cugl::BaseLoader::unloadAll </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Unloads all assets present in this loader.</p>
<p>An asset may still be available if it is referenced by a smart pointer. See the description of the specific implementation for how assets are released.</p>
<p>This method is abstract and should be overridden in the child classes. </p>

<p>Reimplemented in <a class="el" href="classcugl_1_1_loader.html#a1783dde733eb9d1745ad2e0331e54ac5">cugl::Loader&lt; T &gt;</a>, <a class="el" href="classcugl_1_1_loader.html#a1783dde733eb9d1745ad2e0331e54ac5">cugl::Loader&lt; WidgetValue &gt;</a>, <a class="el" href="classcugl_1_1_loader.html#a1783dde733eb9d1745ad2e0331e54ac5">cugl::Loader&lt; Texture &gt;</a>, <a class="el" href="classcugl_1_1_loader.html#a1783dde733eb9d1745ad2e0331e54ac5">cugl::Loader&lt; Sound &gt;</a>, <a class="el" href="classcugl_1_1_loader.html#a1783dde733eb9d1745ad2e0331e54ac5">cugl::Loader&lt; scene2::SceneNode &gt;</a>, <a class="el" href="classcugl_1_1_loader.html#a1783dde733eb9d1745ad2e0331e54ac5">cugl::Loader&lt; JsonValue &gt;</a>, and <a class="el" href="classcugl_1_1_loader.html#a1783dde733eb9d1745ad2e0331e54ac5">cugl::Loader&lt; Font &gt;</a>.</p>

</div>
</div>
<a id="a67c8e28e5746d5a9527dd2a5b7883ab0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a67c8e28e5746d5a9527dd2a5b7883ab0">&#9670;&nbsp;</a></span>verify()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool cugl::BaseLoader::verify </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>key</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">protected</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns true if the key maps to a loaded asset.</p>
<p>This method is useful in case the asset fails to load. You will notice that this method is essentially identical to contains. We separated the methods because overloading and virtual methods do not place nice.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">key</td><td>The key associated with the asset</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if the key maps to a loaded asset. </dd></dl>

<p>Reimplemented in <a class="el" href="classcugl_1_1_loader.html#a03b557b5c0f2627edc4846747c4bcd05">cugl::Loader&lt; T &gt;</a>, <a class="el" href="classcugl_1_1_loader.html#a03b557b5c0f2627edc4846747c4bcd05">cugl::Loader&lt; WidgetValue &gt;</a>, <a class="el" href="classcugl_1_1_loader.html#a03b557b5c0f2627edc4846747c4bcd05">cugl::Loader&lt; Texture &gt;</a>, <a class="el" href="classcugl_1_1_loader.html#a03b557b5c0f2627edc4846747c4bcd05">cugl::Loader&lt; Sound &gt;</a>, <a class="el" href="classcugl_1_1_loader.html#a03b557b5c0f2627edc4846747c4bcd05">cugl::Loader&lt; scene2::SceneNode &gt;</a>, <a class="el" href="classcugl_1_1_loader.html#a03b557b5c0f2627edc4846747c4bcd05">cugl::Loader&lt; JsonValue &gt;</a>, and <a class="el" href="classcugl_1_1_loader.html#a03b557b5c0f2627edc4846747c4bcd05">cugl::Loader&lt; Font &gt;</a>.</p>

</div>
</div>
<a id="a4bd35ece637a736aa7a7974249e5b61f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4bd35ece637a736aa7a7974249e5b61f">&#9670;&nbsp;</a></span>waitCount()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual size_t cugl::BaseLoader::waitCount </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns the number of assets waiting to load.</p>
<p>This is a rough way to determine how many assets are still pending. An asset is pending if it has been loaded asychronously, and the loading process has not yet finished. This method counts each asset equally regardless of the memory requirements of each asset.</p>
<p>This method is abstract and should be overridden in child classes to support the appropriate asset type.</p>
<dl class="section return"><dt>Returns</dt><dd>the number of assets waiting to load. </dd></dl>

<p>Reimplemented in <a class="el" href="classcugl_1_1_loader.html#a24cd92e412bba05496438c123c4d50b9">cugl::Loader&lt; T &gt;</a>, <a class="el" href="classcugl_1_1_loader.html#a24cd92e412bba05496438c123c4d50b9">cugl::Loader&lt; WidgetValue &gt;</a>, <a class="el" href="classcugl_1_1_loader.html#a24cd92e412bba05496438c123c4d50b9">cugl::Loader&lt; Texture &gt;</a>, <a class="el" href="classcugl_1_1_loader.html#a24cd92e412bba05496438c123c4d50b9">cugl::Loader&lt; Sound &gt;</a>, <a class="el" href="classcugl_1_1_loader.html#a24cd92e412bba05496438c123c4d50b9">cugl::Loader&lt; scene2::SceneNode &gt;</a>, <a class="el" href="classcugl_1_1_loader.html#a24cd92e412bba05496438c123c4d50b9">cugl::Loader&lt; JsonValue &gt;</a>, and <a class="el" href="classcugl_1_1_loader.html#a24cd92e412bba05496438c123c4d50b9">cugl::Loader&lt; Font &gt;</a>.</p>

</div>
</div>
<h2 class="groupheader">Member Data Documentation</h2>
<a id="af3047a1c594473a433a1eead29e3c99f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af3047a1c594473a433a1eead29e3c99f">&#9670;&nbsp;</a></span>_loader</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::shared_ptr&lt;<a class="el" href="classcugl_1_1_thread_pool.html">ThreadPool</a>&gt; cugl::BaseLoader::_loader</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>The associated thread for asynchronous loading</p>
<p>If this value is nullptr, only synchronous loading is supported </p>

</div>
</div>
<a id="a500bebffc5d3818af46431bc83fa03ad"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a500bebffc5d3818af46431bc83fa03ad">&#9670;&nbsp;</a></span>_manager</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcugl_1_1_asset_manager.html">AssetManager</a>* cugl::BaseLoader::_manager</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>The parent asset manager for this loader (may be null)</p>
<p>This is a weak reference to avoid cycles. </p>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>include/cugl/assets/<a class="el" href="_c_u_loader_8h_source.html">CULoader.h</a></li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.1
</small></address>
</body>
</html>
