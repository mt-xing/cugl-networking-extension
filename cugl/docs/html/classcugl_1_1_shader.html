<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.9.1"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>CUGL 2.0: cugl::Shader Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">CUGL 2.0
   </div>
   <div id="projectbrief">Cornell University Game Library</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.1 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search','.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespacecugl.html">cugl</a></li><li class="navelem"><a class="el" href="classcugl_1_1_shader.html">Shader</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-static-methods">Static Public Member Functions</a> &#124;
<a href="#pro-attribs">Protected Attributes</a> &#124;
<a href="classcugl_1_1_shader-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">cugl::Shader Class Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p><code>#include &lt;<a class="el" href="_c_u_shader_8h_source.html">CUShader.h</a>&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a1f45b4e8cda28709f1dccfe4933ef363"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1_shader.html#a1f45b4e8cda28709f1dccfe4933ef363">Shader</a> ()</td></tr>
<tr class="separator:a1f45b4e8cda28709f1dccfe4933ef363"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a51039e6ccd81e1041cca8abc2a876209"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1_shader.html#a51039e6ccd81e1041cca8abc2a876209">~Shader</a> ()</td></tr>
<tr class="separator:a51039e6ccd81e1041cca8abc2a876209"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae311cd023ba662bb8c3bec26e7a579ed"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1_shader.html#ae311cd023ba662bb8c3bec26e7a579ed">dispose</a> ()</td></tr>
<tr class="separator:ae311cd023ba662bb8c3bec26e7a579ed"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4e6cb4d084b72f9276ab03f8bdc370b2"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1_shader.html#a4e6cb4d084b72f9276ab03f8bdc370b2">init</a> (const std::string vsource, std::string fsource)</td></tr>
<tr class="separator:a4e6cb4d084b72f9276ab03f8bdc370b2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac83752645253890a578f0306570ec332"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1_shader.html#ac83752645253890a578f0306570ec332">bind</a> ()</td></tr>
<tr class="separator:ac83752645253890a578f0306570ec332"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a947558fe76fbfe66fe10b024d3aa5c63"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1_shader.html#a947558fe76fbfe66fe10b024d3aa5c63">unbind</a> ()</td></tr>
<tr class="separator:a947558fe76fbfe66fe10b024d3aa5c63"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aac3764774f73d5ffe24bbe2d1856eec1"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1_shader.html#aac3764774f73d5ffe24bbe2d1856eec1">isReady</a> () const</td></tr>
<tr class="separator:aac3764774f73d5ffe24bbe2d1856eec1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab33787a07657f2e0c94fecfddad10f90"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1_shader.html#ab33787a07657f2e0c94fecfddad10f90">isBound</a> () const</td></tr>
<tr class="separator:ab33787a07657f2e0c94fecfddad10f90"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae11b0b1a9c4ade9a501bd30448ff202e"><td class="memItemLeft" align="right" valign="top">const std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1_shader.html#ae11b0b1a9c4ade9a501bd30448ff202e">getVertSource</a> () const</td></tr>
<tr class="separator:ae11b0b1a9c4ade9a501bd30448ff202e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aab781df9a094c246fb354c45244f55ee"><td class="memItemLeft" align="right" valign="top">const std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1_shader.html#aab781df9a094c246fb354c45244f55ee">getFragSource</a> () const</td></tr>
<tr class="separator:aab781df9a094c246fb354c45244f55ee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a500360d59cf2b0e8519d779584843552"><td class="memItemLeft" align="right" valign="top">GLuint&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1_shader.html#a500360d59cf2b0e8519d779584843552">getProgram</a> () const</td></tr>
<tr class="separator:a500360d59cf2b0e8519d779584843552"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9b69a41d7400bdc604d872cacc323bd0"><td class="memItemLeft" align="right" valign="top">std::vector&lt; std::string &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1_shader.html#a9b69a41d7400bdc604d872cacc323bd0">getAttributes</a> () const</td></tr>
<tr class="separator:a9b69a41d7400bdc604d872cacc323bd0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af51f4c12d990642720743b25abbb1735"><td class="memItemLeft" align="right" valign="top">GLint&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1_shader.html#af51f4c12d990642720743b25abbb1735">getAttributeLocation</a> (const std::string name) const</td></tr>
<tr class="separator:af51f4c12d990642720743b25abbb1735"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af7c0ff97d740a3f4e5210d103dea27ea"><td class="memItemLeft" align="right" valign="top">GLint&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1_shader.html#af7c0ff97d740a3f4e5210d103dea27ea">getAttributeSize</a> (const std::string name) const</td></tr>
<tr class="separator:af7c0ff97d740a3f4e5210d103dea27ea"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a26d4c13fa89707f20fed37c7b9c3d9b6"><td class="memItemLeft" align="right" valign="top">GLenum&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1_shader.html#a26d4c13fa89707f20fed37c7b9c3d9b6">getAttributeType</a> (const std::string name) const</td></tr>
<tr class="separator:a26d4c13fa89707f20fed37c7b9c3d9b6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abd4ecaf24ddce0d86bdd6342b5b4412d"><td class="memItemLeft" align="right" valign="top">GLint&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1_shader.html#abd4ecaf24ddce0d86bdd6342b5b4412d">getOutputLocation</a> (const std::string name) const</td></tr>
<tr class="separator:abd4ecaf24ddce0d86bdd6342b5b4412d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7b10e442569e72ab4c8d0558efba239d"><td class="memItemLeft" align="right" valign="top">std::vector&lt; std::string &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1_shader.html#a7b10e442569e72ab4c8d0558efba239d">getUniforms</a> () const</td></tr>
<tr class="separator:a7b10e442569e72ab4c8d0558efba239d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a68ecdd5013205690e6ac211974b91363"><td class="memItemLeft" align="right" valign="top">GLint&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1_shader.html#a68ecdd5013205690e6ac211974b91363">getUniformLocation</a> (const std::string name) const</td></tr>
<tr class="separator:a68ecdd5013205690e6ac211974b91363"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a95fbae3e24ed6688bd5e3c577d01ccb0"><td class="memItemLeft" align="right" valign="top">GLint&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1_shader.html#a95fbae3e24ed6688bd5e3c577d01ccb0">getUniformSize</a> (const std::string name) const</td></tr>
<tr class="separator:a95fbae3e24ed6688bd5e3c577d01ccb0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa438eaa2aed5752a26cc7537b0f036c8"><td class="memItemLeft" align="right" valign="top">GLenum&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1_shader.html#aa438eaa2aed5752a26cc7537b0f036c8">getUniformType</a> (const std::string name) const</td></tr>
<tr class="separator:aa438eaa2aed5752a26cc7537b0f036c8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a07d157eff503c6df9eadbf320e84c543"><td class="memItemLeft" align="right" valign="top">std::vector&lt; std::string &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1_shader.html#a07d157eff503c6df9eadbf320e84c543">getSamplers</a> () const</td></tr>
<tr class="separator:a07d157eff503c6df9eadbf320e84c543"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a05290c7a5b69d15de38b8dc4b239e4d9"><td class="memItemLeft" align="right" valign="top">GLint&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1_shader.html#a05290c7a5b69d15de38b8dc4b239e4d9">getSamplerLocation</a> (const std::string name) const</td></tr>
<tr class="separator:a05290c7a5b69d15de38b8dc4b239e4d9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a071fe403382f133ee28d5e4adeb1fe08"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1_shader.html#a071fe403382f133ee28d5e4adeb1fe08">setSampler</a> (GLint pos, GLuint bpoint)</td></tr>
<tr class="separator:a071fe403382f133ee28d5e4adeb1fe08"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad040645d332b014080a0cbfb50823365"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1_shader.html#ad040645d332b014080a0cbfb50823365">setSampler</a> (const std::string name, GLuint bpoint)</td></tr>
<tr class="separator:ad040645d332b014080a0cbfb50823365"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a15a63caa00e20c3cc6a59129e283d606"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1_shader.html#a15a63caa00e20c3cc6a59129e283d606">setSampler</a> (GLint pos, const std::shared_ptr&lt; <a class="el" href="classcugl_1_1_texture.html">Texture</a> &gt; &amp;texture)</td></tr>
<tr class="separator:a15a63caa00e20c3cc6a59129e283d606"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a084172af4970025715267be7eb342632"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1_shader.html#a084172af4970025715267be7eb342632">setSampler</a> (const std::string name, const std::shared_ptr&lt; <a class="el" href="classcugl_1_1_texture.html">Texture</a> &gt; &amp;texture)</td></tr>
<tr class="separator:a084172af4970025715267be7eb342632"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a87e9b3c923cbd35245f0cb20d1196fea"><td class="memItemLeft" align="right" valign="top">GLuint&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1_shader.html#a87e9b3c923cbd35245f0cb20d1196fea">getSampler</a> (GLint pos) const</td></tr>
<tr class="separator:a87e9b3c923cbd35245f0cb20d1196fea"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab17e493b6191b2dd01a18abe3c84b321"><td class="memItemLeft" align="right" valign="top">GLuint&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1_shader.html#ab17e493b6191b2dd01a18abe3c84b321">getSampler</a> (const std::string name) const</td></tr>
<tr class="separator:ab17e493b6191b2dd01a18abe3c84b321"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8323ba02b41ddc141d1f968cb5b53c21"><td class="memItemLeft" align="right" valign="top">std::vector&lt; std::string &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1_shader.html#a8323ba02b41ddc141d1f968cb5b53c21">getUniformBlocks</a> () const</td></tr>
<tr class="separator:a8323ba02b41ddc141d1f968cb5b53c21"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae1c57ed76852be204f083453516aa391"><td class="memItemLeft" align="right" valign="top">std::vector&lt; std::string &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1_shader.html#ae1c57ed76852be204f083453516aa391">getUniformsForBlock</a> (GLint pos) const</td></tr>
<tr class="separator:ae1c57ed76852be204f083453516aa391"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abf80fea40769446a5f5144a069dcdd77"><td class="memItemLeft" align="right" valign="top">std::vector&lt; std::string &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1_shader.html#abf80fea40769446a5f5144a069dcdd77">getUniformsForBlock</a> (std::string name) const</td></tr>
<tr class="separator:abf80fea40769446a5f5144a069dcdd77"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5958ebed6e243170e26300553308a618"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1_shader.html#a5958ebed6e243170e26300553308a618">setUniformBlock</a> (GLint pos, GLuint bpoint)</td></tr>
<tr class="separator:a5958ebed6e243170e26300553308a618"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab40d65cd58488becc46b5e81e596f659"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1_shader.html#ab40d65cd58488becc46b5e81e596f659">setUniformBlock</a> (const std::string name, GLuint bpoint)</td></tr>
<tr class="separator:ab40d65cd58488becc46b5e81e596f659"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2825dd85e0ca79643c86d4fa09bfa150"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1_shader.html#a2825dd85e0ca79643c86d4fa09bfa150">setUniformBlock</a> (GLint pos, const std::shared_ptr&lt; <a class="el" href="classcugl_1_1_uniform_buffer.html">UniformBuffer</a> &gt; &amp;buffer)</td></tr>
<tr class="separator:a2825dd85e0ca79643c86d4fa09bfa150"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abc8c16e5e660161368819dbd5e10f0ac"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1_shader.html#abc8c16e5e660161368819dbd5e10f0ac">setUniformBlock</a> (const std::string name, const std::shared_ptr&lt; <a class="el" href="classcugl_1_1_uniform_buffer.html">UniformBuffer</a> &gt; &amp;buffer)</td></tr>
<tr class="separator:abc8c16e5e660161368819dbd5e10f0ac"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6fbcfc6ad9ef7ad887db24a258024aa8"><td class="memItemLeft" align="right" valign="top">GLuint&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1_shader.html#a6fbcfc6ad9ef7ad887db24a258024aa8">getUniformBlock</a> (GLint pos) const</td></tr>
<tr class="separator:a6fbcfc6ad9ef7ad887db24a258024aa8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7169b8a1041b8f1fe13074fb6d4e8261"><td class="memItemLeft" align="right" valign="top">GLuint&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1_shader.html#a7169b8a1041b8f1fe13074fb6d4e8261">getUniformBlock</a> (const std::string name) const</td></tr>
<tr class="separator:a7169b8a1041b8f1fe13074fb6d4e8261"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac64dbe301e9ee93f505ca288031188a8"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1_shader.html#ac64dbe301e9ee93f505ca288031188a8">setUniformVec2</a> (GLint pos, const <a class="el" href="classcugl_1_1_vec2.html">Vec2</a> vec)</td></tr>
<tr class="separator:ac64dbe301e9ee93f505ca288031188a8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6fb65fb32f9e3189f893b6beee40ff7b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1_shader.html#a6fb65fb32f9e3189f893b6beee40ff7b">setUniformVec2</a> (const std::string name, const <a class="el" href="classcugl_1_1_vec2.html">Vec2</a> vec)</td></tr>
<tr class="separator:a6fb65fb32f9e3189f893b6beee40ff7b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac2c63e406dbef9693e656895c42974b6"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1_shader.html#ac2c63e406dbef9693e656895c42974b6">getUniformVec2</a> (GLint pos, <a class="el" href="classcugl_1_1_vec2.html">Vec2</a> &amp;vec) const</td></tr>
<tr class="separator:ac2c63e406dbef9693e656895c42974b6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2a391f95655031aae9129590f8f1182a"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1_shader.html#a2a391f95655031aae9129590f8f1182a">getUniformVec2</a> (const std::string name, <a class="el" href="classcugl_1_1_vec2.html">Vec2</a> &amp;vec) const</td></tr>
<tr class="separator:a2a391f95655031aae9129590f8f1182a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5d0328d43e02b31b4a8bce680ae25f0e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1_shader.html#a5d0328d43e02b31b4a8bce680ae25f0e">setUniformVec3</a> (GLint pos, const <a class="el" href="classcugl_1_1_vec3.html">Vec3</a> vec)</td></tr>
<tr class="separator:a5d0328d43e02b31b4a8bce680ae25f0e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aae3d66b522f80975b4931581cdac03a9"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1_shader.html#aae3d66b522f80975b4931581cdac03a9">setUniformVec3</a> (const std::string name, const <a class="el" href="classcugl_1_1_vec3.html">Vec3</a> vec)</td></tr>
<tr class="separator:aae3d66b522f80975b4931581cdac03a9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a60bea1dcccb2e633de865ee7961faf4a"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1_shader.html#a60bea1dcccb2e633de865ee7961faf4a">getUniformVec3</a> (GLint pos, <a class="el" href="classcugl_1_1_vec3.html">Vec3</a> &amp;vec) const</td></tr>
<tr class="separator:a60bea1dcccb2e633de865ee7961faf4a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6d305ed33fc6f53ad1cbf6c7c9ea5bc7"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1_shader.html#a6d305ed33fc6f53ad1cbf6c7c9ea5bc7">getUniformVec3</a> (const std::string name, <a class="el" href="classcugl_1_1_vec3.html">Vec3</a> &amp;vec) const</td></tr>
<tr class="separator:a6d305ed33fc6f53ad1cbf6c7c9ea5bc7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab4882e989691f4730d96ec03debcb803"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1_shader.html#ab4882e989691f4730d96ec03debcb803">setUniformVec4</a> (GLint pos, const <a class="el" href="classcugl_1_1_vec4.html">Vec4</a> vec)</td></tr>
<tr class="separator:ab4882e989691f4730d96ec03debcb803"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a40261c13525dcae116a0314658cdbd82"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1_shader.html#a40261c13525dcae116a0314658cdbd82">setUniformVec4</a> (const std::string name, const <a class="el" href="classcugl_1_1_vec4.html">Vec4</a> vec)</td></tr>
<tr class="separator:a40261c13525dcae116a0314658cdbd82"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a49e0a88ea49043c4a3f035636df62f27"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1_shader.html#a49e0a88ea49043c4a3f035636df62f27">getUniformVec4</a> (GLint pos, <a class="el" href="classcugl_1_1_vec4.html">Vec4</a> &amp;vec) const</td></tr>
<tr class="separator:a49e0a88ea49043c4a3f035636df62f27"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaaef0dc4f372baca5e1c289162fa4b73"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1_shader.html#aaaef0dc4f372baca5e1c289162fa4b73">getUniformVec4</a> (const std::string name, <a class="el" href="classcugl_1_1_vec4.html">Vec4</a> &amp;vec) const</td></tr>
<tr class="separator:aaaef0dc4f372baca5e1c289162fa4b73"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2846b6e58f6303122913cb33a85e990e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1_shader.html#a2846b6e58f6303122913cb33a85e990e">setUniformColor4</a> (GLint pos, const <a class="el" href="classcugl_1_1_color4.html">Color4</a> color)</td></tr>
<tr class="separator:a2846b6e58f6303122913cb33a85e990e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5a387193ddd447e72f35ec0f4f627687"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1_shader.html#a5a387193ddd447e72f35ec0f4f627687">setUniformColor4</a> (const std::string name, const <a class="el" href="classcugl_1_1_color4.html">Color4</a> color)</td></tr>
<tr class="separator:a5a387193ddd447e72f35ec0f4f627687"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a759b2107673b66d9890b40daefff5ee5"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1_shader.html#a759b2107673b66d9890b40daefff5ee5">getUniformColor4</a> (GLint pos, <a class="el" href="classcugl_1_1_color4.html">Color4</a> &amp;color) const</td></tr>
<tr class="separator:a759b2107673b66d9890b40daefff5ee5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a850ef97dd4ec7b969f798cbce88e351c"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1_shader.html#a850ef97dd4ec7b969f798cbce88e351c">getUniformColor4</a> (const std::string name, <a class="el" href="classcugl_1_1_color4.html">Color4</a> &amp;color) const</td></tr>
<tr class="separator:a850ef97dd4ec7b969f798cbce88e351c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afb6753ffe4126b75b29be4227bd44f2c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1_shader.html#afb6753ffe4126b75b29be4227bd44f2c">setUniformColor4f</a> (GLint pos, const <a class="el" href="classcugl_1_1_color4f.html">Color4f</a> color)</td></tr>
<tr class="separator:afb6753ffe4126b75b29be4227bd44f2c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab75f1475be381140560d53316baefac0"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1_shader.html#ab75f1475be381140560d53316baefac0">setUniformColor4f</a> (const std::string name, const <a class="el" href="classcugl_1_1_color4f.html">Color4f</a> color)</td></tr>
<tr class="separator:ab75f1475be381140560d53316baefac0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a156be997ea28efb2280040d471c56c98"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1_shader.html#a156be997ea28efb2280040d471c56c98">getUniformColor4f</a> (GLint pos, <a class="el" href="classcugl_1_1_color4f.html">Color4f</a> &amp;color) const</td></tr>
<tr class="separator:a156be997ea28efb2280040d471c56c98"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4b94899f51224ff3bad7e96eb66be52c"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1_shader.html#a4b94899f51224ff3bad7e96eb66be52c">getUniformColor4f</a> (const std::string name, <a class="el" href="classcugl_1_1_color4f.html">Color4f</a> &amp;color) const</td></tr>
<tr class="separator:a4b94899f51224ff3bad7e96eb66be52c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa0e115a0fb120ec337c55c1088b9a92f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1_shader.html#aa0e115a0fb120ec337c55c1088b9a92f">setUniformMat4</a> (GLint pos, const <a class="el" href="classcugl_1_1_mat4.html">Mat4</a> &amp;mat)</td></tr>
<tr class="separator:aa0e115a0fb120ec337c55c1088b9a92f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae4052ee41ef043094d2f19a5baa7aed6"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1_shader.html#ae4052ee41ef043094d2f19a5baa7aed6">setUniformMat4</a> (const std::string name, const <a class="el" href="classcugl_1_1_mat4.html">Mat4</a> &amp;mat)</td></tr>
<tr class="separator:ae4052ee41ef043094d2f19a5baa7aed6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a022ce83a628b49f9d9d2fba7b585394f"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1_shader.html#a022ce83a628b49f9d9d2fba7b585394f">getUniformMat4</a> (GLint pos, <a class="el" href="classcugl_1_1_mat4.html">Mat4</a> &amp;mat) const</td></tr>
<tr class="separator:a022ce83a628b49f9d9d2fba7b585394f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a79bef8b32fbf88d496bddfd79986a5d1"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1_shader.html#a79bef8b32fbf88d496bddfd79986a5d1">getUniformMat4</a> (const std::string name, <a class="el" href="classcugl_1_1_mat4.html">Mat4</a> &amp;mat) const</td></tr>
<tr class="separator:a79bef8b32fbf88d496bddfd79986a5d1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a712ce1ba4eb7b7af7ea453a48dba6468"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1_shader.html#a712ce1ba4eb7b7af7ea453a48dba6468">setUniformAffine2</a> (GLint pos, const <a class="el" href="classcugl_1_1_affine2.html">Affine2</a> &amp;mat)</td></tr>
<tr class="separator:a712ce1ba4eb7b7af7ea453a48dba6468"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9a8bc34910dc84faeee53decf09cd3c2"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1_shader.html#a9a8bc34910dc84faeee53decf09cd3c2">setUniformAffine2</a> (const std::string name, const <a class="el" href="classcugl_1_1_affine2.html">Affine2</a> &amp;mat)</td></tr>
<tr class="separator:a9a8bc34910dc84faeee53decf09cd3c2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3aea4774493a9992ca72c3992819c9d4"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1_shader.html#a3aea4774493a9992ca72c3992819c9d4">getUniformAffine2</a> (GLint pos, <a class="el" href="classcugl_1_1_affine2.html">Affine2</a> &amp;mat) const</td></tr>
<tr class="separator:a3aea4774493a9992ca72c3992819c9d4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae32fffe6089192528ed016b8c2cb96fe"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1_shader.html#ae32fffe6089192528ed016b8c2cb96fe">getUniformAffine2</a> (const std::string name, <a class="el" href="classcugl_1_1_affine2.html">Affine2</a> &amp;mat) const</td></tr>
<tr class="separator:ae32fffe6089192528ed016b8c2cb96fe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abee706109d45f6c4cf52701335581fa5"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1_shader.html#abee706109d45f6c4cf52701335581fa5">setUniformQuaternion</a> (GLint pos, const <a class="el" href="classcugl_1_1_quaternion.html">Quaternion</a> &amp;quat)</td></tr>
<tr class="separator:abee706109d45f6c4cf52701335581fa5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9768849854da5f6e202828689c321930"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1_shader.html#a9768849854da5f6e202828689c321930">setUniformQuaternion</a> (const std::string name, const <a class="el" href="classcugl_1_1_quaternion.html">Quaternion</a> &amp;quat)</td></tr>
<tr class="separator:a9768849854da5f6e202828689c321930"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0a06ccf9bf14788fb959c76bcafb7fc8"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1_shader.html#a0a06ccf9bf14788fb959c76bcafb7fc8">getUniformQuaternion</a> (GLint pos, <a class="el" href="classcugl_1_1_quaternion.html">Quaternion</a> &amp;quat) const</td></tr>
<tr class="separator:a0a06ccf9bf14788fb959c76bcafb7fc8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5064922915e7527a87b6caeadc70344e"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1_shader.html#a5064922915e7527a87b6caeadc70344e">getUniformQuaternion</a> (const std::string name, <a class="el" href="classcugl_1_1_quaternion.html">Quaternion</a> &amp;quat) const</td></tr>
<tr class="separator:a5064922915e7527a87b6caeadc70344e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac7a326e9afdd8a62eabf07948214feab"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1_shader.html#ac7a326e9afdd8a62eabf07948214feab">setUniform1f</a> (GLint pos, GLfloat v0)</td></tr>
<tr class="separator:ac7a326e9afdd8a62eabf07948214feab"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a057e71d7f33de4f67c12f426dd7ef3ed"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1_shader.html#a057e71d7f33de4f67c12f426dd7ef3ed">setUniform1f</a> (const std::string name, GLfloat v0)</td></tr>
<tr class="separator:a057e71d7f33de4f67c12f426dd7ef3ed"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3feb1e8b24731c13d524181cdd2d265d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1_shader.html#a3feb1e8b24731c13d524181cdd2d265d">setUniform2f</a> (GLint pos, GLfloat v0, GLfloat v1)</td></tr>
<tr class="separator:a3feb1e8b24731c13d524181cdd2d265d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae45339cbc6cbdf5da76793928c45ad15"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1_shader.html#ae45339cbc6cbdf5da76793928c45ad15">setUniform2f</a> (const std::string name, GLfloat v0, GLfloat v1)</td></tr>
<tr class="separator:ae45339cbc6cbdf5da76793928c45ad15"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a038edd04e4da980317c78eb27678fbb7"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1_shader.html#a038edd04e4da980317c78eb27678fbb7">setUniform3f</a> (GLint pos, GLfloat v0, GLfloat v1, GLfloat v2)</td></tr>
<tr class="separator:a038edd04e4da980317c78eb27678fbb7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a23bdb8e98357997c02ee87c1cca4a4b1"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1_shader.html#a23bdb8e98357997c02ee87c1cca4a4b1">setUniform3f</a> (const std::string name, GLfloat v0, GLfloat v1, GLfloat v2)</td></tr>
<tr class="separator:a23bdb8e98357997c02ee87c1cca4a4b1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6af8cfbcd795f3fb5478d35b2d0be52e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1_shader.html#a6af8cfbcd795f3fb5478d35b2d0be52e">setUniform4f</a> (GLint pos, GLfloat v0, GLfloat v1, GLfloat v2, GLfloat v3)</td></tr>
<tr class="separator:a6af8cfbcd795f3fb5478d35b2d0be52e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad1bb4fab3f9dd3ab3bf5080fe5b1eccc"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1_shader.html#ad1bb4fab3f9dd3ab3bf5080fe5b1eccc">setUniform4f</a> (const std::string name, GLfloat v0, GLfloat v1, GLfloat v2, GLfloat v3)</td></tr>
<tr class="separator:ad1bb4fab3f9dd3ab3bf5080fe5b1eccc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a81375366f1128711de01ab364186c675"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1_shader.html#a81375366f1128711de01ab364186c675">setUniform1i</a> (GLint pos, GLint v0)</td></tr>
<tr class="separator:a81375366f1128711de01ab364186c675"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4d5e0d5cdf90008f1530f6689b1fa274"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1_shader.html#a4d5e0d5cdf90008f1530f6689b1fa274">setUniform1i</a> (const std::string name, GLint v0)</td></tr>
<tr class="separator:a4d5e0d5cdf90008f1530f6689b1fa274"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9857968b2733469923123613a7867ddd"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1_shader.html#a9857968b2733469923123613a7867ddd">setUniform2i</a> (GLint pos, GLint v0, GLint v1)</td></tr>
<tr class="separator:a9857968b2733469923123613a7867ddd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a46e5d8e90bf0c860a4d31f8821525960"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1_shader.html#a46e5d8e90bf0c860a4d31f8821525960">setUniform2i</a> (const std::string name, GLint v0, GLint v1)</td></tr>
<tr class="separator:a46e5d8e90bf0c860a4d31f8821525960"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aef45e318ceb14453544f5479c21c81ca"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1_shader.html#aef45e318ceb14453544f5479c21c81ca">setUniform3i</a> (GLint pos, GLint v0, GLint v1, GLint v2)</td></tr>
<tr class="separator:aef45e318ceb14453544f5479c21c81ca"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac510f31b95df89a218e32b9a81759dec"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1_shader.html#ac510f31b95df89a218e32b9a81759dec">setUniform3i</a> (const std::string name, GLint v0, GLint v1, GLint v2)</td></tr>
<tr class="separator:ac510f31b95df89a218e32b9a81759dec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a06fec667614481149ef98841e197650e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1_shader.html#a06fec667614481149ef98841e197650e">setUniform4i</a> (GLint pos, GLint v0, GLint v1, GLint v2, GLint v3)</td></tr>
<tr class="separator:a06fec667614481149ef98841e197650e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac65cd7f7d4f9aac5d42f631bd95ede3d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1_shader.html#ac65cd7f7d4f9aac5d42f631bd95ede3d">setUniform4i</a> (const std::string name, GLint v0, GLint v1, GLint v2, GLint v3)</td></tr>
<tr class="separator:ac65cd7f7d4f9aac5d42f631bd95ede3d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a27a1a6b739c2e027cbce581ccadd4e88"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1_shader.html#a27a1a6b739c2e027cbce581ccadd4e88">setUniform1ui</a> (GLint pos, GLuint v0)</td></tr>
<tr class="separator:a27a1a6b739c2e027cbce581ccadd4e88"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afc08c8dbe806caf7a0fae1e2d9d49127"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1_shader.html#afc08c8dbe806caf7a0fae1e2d9d49127">setUniform1ui</a> (const std::string name, GLuint v0)</td></tr>
<tr class="separator:afc08c8dbe806caf7a0fae1e2d9d49127"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac5ec2d2f8ce35546f67ad01e3b84cd71"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1_shader.html#ac5ec2d2f8ce35546f67ad01e3b84cd71">setUniform2ui</a> (GLint pos, GLuint v0, GLuint v1)</td></tr>
<tr class="separator:ac5ec2d2f8ce35546f67ad01e3b84cd71"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad55b7a0402bbc4b1ed226c200e9e839d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1_shader.html#ad55b7a0402bbc4b1ed226c200e9e839d">setUniform2ui</a> (const std::string name, GLuint v0, GLuint v1)</td></tr>
<tr class="separator:ad55b7a0402bbc4b1ed226c200e9e839d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac9318d0b82465f97ed53de69262bed48"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1_shader.html#ac9318d0b82465f97ed53de69262bed48">setUniform3ui</a> (GLint pos, GLuint v0, GLuint v1, GLuint v2)</td></tr>
<tr class="separator:ac9318d0b82465f97ed53de69262bed48"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a53103e680fa8b11fd1bd8b506047f13b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1_shader.html#a53103e680fa8b11fd1bd8b506047f13b">setUniform3ui</a> (const std::string name, GLuint v0, GLuint v1, GLuint v2)</td></tr>
<tr class="separator:a53103e680fa8b11fd1bd8b506047f13b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac08366f232511e78b3a00ec464ee563c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1_shader.html#ac08366f232511e78b3a00ec464ee563c">setUniform4ui</a> (GLint pos, GLuint v0, GLuint v1, GLuint v2, GLuint v3)</td></tr>
<tr class="separator:ac08366f232511e78b3a00ec464ee563c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a583130125d01fbad8b410150edcb4af0"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1_shader.html#a583130125d01fbad8b410150edcb4af0">setUniform4ui</a> (const std::string name, GLuint v0, GLuint v1, GLuint v2, GLuint v3)</td></tr>
<tr class="separator:a583130125d01fbad8b410150edcb4af0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aee4d3d42a7a1db77d6f42dc6ee893f10"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1_shader.html#aee4d3d42a7a1db77d6f42dc6ee893f10">setUniform1fv</a> (GLint pos, GLsizei count, const GLfloat *value)</td></tr>
<tr class="separator:aee4d3d42a7a1db77d6f42dc6ee893f10"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4483075e887c626c524d46d0126cbe9b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1_shader.html#a4483075e887c626c524d46d0126cbe9b">setUniform1fv</a> (const std::string name, GLsizei count, const GLfloat *value)</td></tr>
<tr class="separator:a4483075e887c626c524d46d0126cbe9b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9ea814749a0bc17f84e81091c8d35b1d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1_shader.html#a9ea814749a0bc17f84e81091c8d35b1d">setUniform2fv</a> (GLint pos, GLsizei count, const GLfloat *value)</td></tr>
<tr class="separator:a9ea814749a0bc17f84e81091c8d35b1d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac4341fa43ababa675bd9e0ea7f8fac12"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1_shader.html#ac4341fa43ababa675bd9e0ea7f8fac12">setUniform2fv</a> (const std::string name, GLsizei count, const GLfloat *value)</td></tr>
<tr class="separator:ac4341fa43ababa675bd9e0ea7f8fac12"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af4ab58718b2c190d9b7e8444d3a4a4db"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1_shader.html#af4ab58718b2c190d9b7e8444d3a4a4db">setUniform3fv</a> (GLint pos, GLsizei count, const GLfloat *value)</td></tr>
<tr class="separator:af4ab58718b2c190d9b7e8444d3a4a4db"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af0c36937bd3f9fb5b61aa7c98d87b585"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1_shader.html#af0c36937bd3f9fb5b61aa7c98d87b585">setUniform3fv</a> (const std::string name, GLsizei count, const GLfloat *value)</td></tr>
<tr class="separator:af0c36937bd3f9fb5b61aa7c98d87b585"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac21de69a16467af4c07528ef614d1878"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1_shader.html#ac21de69a16467af4c07528ef614d1878">setUniform4fv</a> (GLint pos, GLsizei count, const GLfloat *value)</td></tr>
<tr class="separator:ac21de69a16467af4c07528ef614d1878"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0e157d12a1dfdd7bf58860bf4c0dd780"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1_shader.html#a0e157d12a1dfdd7bf58860bf4c0dd780">setUniform4fv</a> (const std::string name, GLsizei count, const GLfloat *value)</td></tr>
<tr class="separator:a0e157d12a1dfdd7bf58860bf4c0dd780"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acd1fc3f884e98a765f260ad602973ac7"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1_shader.html#acd1fc3f884e98a765f260ad602973ac7">setUniform1iv</a> (GLint pos, GLsizei count, const GLint *value)</td></tr>
<tr class="separator:acd1fc3f884e98a765f260ad602973ac7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aff9e56614c2c5d501a71f78f1d112960"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1_shader.html#aff9e56614c2c5d501a71f78f1d112960">setUniform1iv</a> (const std::string name, GLsizei count, const GLint *value)</td></tr>
<tr class="separator:aff9e56614c2c5d501a71f78f1d112960"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a51fcaf5b738fab8a75c6ae026061ea60"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1_shader.html#a51fcaf5b738fab8a75c6ae026061ea60">setUniform2iv</a> (GLint pos, GLsizei count, const GLint *value)</td></tr>
<tr class="separator:a51fcaf5b738fab8a75c6ae026061ea60"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a621bc5442c0feb68737c26e20b90fc42"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1_shader.html#a621bc5442c0feb68737c26e20b90fc42">setUniform2iv</a> (const std::string name, GLsizei count, const GLint *value)</td></tr>
<tr class="separator:a621bc5442c0feb68737c26e20b90fc42"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a98206e18d28bf8dc55b406371ffe021f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1_shader.html#a98206e18d28bf8dc55b406371ffe021f">setUniform3iv</a> (GLint pos, GLsizei count, const GLint *value)</td></tr>
<tr class="separator:a98206e18d28bf8dc55b406371ffe021f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3db575e5765c01940daa1d6da8389c23"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1_shader.html#a3db575e5765c01940daa1d6da8389c23">setUniform3iv</a> (const std::string name, GLsizei count, const GLint *value)</td></tr>
<tr class="separator:a3db575e5765c01940daa1d6da8389c23"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aecbfcf2e367ef4d05eb3c72fb10e6293"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1_shader.html#aecbfcf2e367ef4d05eb3c72fb10e6293">setUniform4iv</a> (GLint pos, GLsizei count, const GLint *value)</td></tr>
<tr class="separator:aecbfcf2e367ef4d05eb3c72fb10e6293"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1a2e30c4f3c3ce28aeb1b89b3346ae3d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1_shader.html#a1a2e30c4f3c3ce28aeb1b89b3346ae3d">setUniform4iv</a> (const std::string name, GLsizei count, const GLint *value)</td></tr>
<tr class="separator:a1a2e30c4f3c3ce28aeb1b89b3346ae3d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae0138c7905f98fdea5d4f3f3852385cf"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1_shader.html#ae0138c7905f98fdea5d4f3f3852385cf">setUniform1uiv</a> (GLint pos, GLsizei count, const GLuint *value)</td></tr>
<tr class="separator:ae0138c7905f98fdea5d4f3f3852385cf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aed35a57792a89f07ae7951af376ed08c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1_shader.html#aed35a57792a89f07ae7951af376ed08c">setUniform1uiv</a> (const std::string name, GLsizei count, const GLuint *value)</td></tr>
<tr class="separator:aed35a57792a89f07ae7951af376ed08c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7addcb5d41c2586c466d71cafddcf033"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1_shader.html#a7addcb5d41c2586c466d71cafddcf033">setUniform2uiv</a> (GLint pos, GLsizei count, const GLuint *value)</td></tr>
<tr class="separator:a7addcb5d41c2586c466d71cafddcf033"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9d8ad1e822a41dff01d35f9d00f2f16d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1_shader.html#a9d8ad1e822a41dff01d35f9d00f2f16d">setUniform2uiv</a> (const std::string name, GLsizei count, const GLuint *value)</td></tr>
<tr class="separator:a9d8ad1e822a41dff01d35f9d00f2f16d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3dcded2d495e514be4590da942fa2b33"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1_shader.html#a3dcded2d495e514be4590da942fa2b33">setUniform3uiv</a> (GLint pos, GLsizei count, const GLuint *value)</td></tr>
<tr class="separator:a3dcded2d495e514be4590da942fa2b33"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a87bfc6728ff9cafd4362b702132e7ebf"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1_shader.html#a87bfc6728ff9cafd4362b702132e7ebf">setUniform3uiv</a> (const std::string name, GLsizei count, const GLuint *value)</td></tr>
<tr class="separator:a87bfc6728ff9cafd4362b702132e7ebf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a95ce1f0fcc1fc85ce69d7e7a0f949698"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1_shader.html#a95ce1f0fcc1fc85ce69d7e7a0f949698">setUniform4uiv</a> (GLint pos, GLsizei count, const GLuint *value)</td></tr>
<tr class="separator:a95ce1f0fcc1fc85ce69d7e7a0f949698"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a58d3f800d2b9caabb894b559eda02c59"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1_shader.html#a58d3f800d2b9caabb894b559eda02c59">setUniform4uiv</a> (const std::string name, GLsizei count, const GLuint *value)</td></tr>
<tr class="separator:a58d3f800d2b9caabb894b559eda02c59"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad40a39377396f24498170f396eea00a0"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1_shader.html#ad40a39377396f24498170f396eea00a0">setUniformMatrix2fv</a> (GLint pos, GLsizei count, const GLfloat *value, GLboolean tpose=false)</td></tr>
<tr class="separator:ad40a39377396f24498170f396eea00a0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3b057ce153ad522f0610034378f3171a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1_shader.html#a3b057ce153ad522f0610034378f3171a">setUniformMatrix2fv</a> (const std::string name, GLsizei count, const GLfloat *value, GLboolean tpose=false)</td></tr>
<tr class="separator:a3b057ce153ad522f0610034378f3171a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0096f077f122a12cf97140f1e543b86e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1_shader.html#a0096f077f122a12cf97140f1e543b86e">setUniformMatrix3fv</a> (GLint pos, GLsizei count, const GLfloat *value, GLboolean tpose=false)</td></tr>
<tr class="separator:a0096f077f122a12cf97140f1e543b86e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a37c23ddbbc9f18f3ed3688cbfeefa492"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1_shader.html#a37c23ddbbc9f18f3ed3688cbfeefa492">setUniformMatrix3fv</a> (const std::string name, GLsizei count, const GLfloat *value, GLboolean tpose=false)</td></tr>
<tr class="separator:a37c23ddbbc9f18f3ed3688cbfeefa492"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a93fc729b28103f9ae51bab3f6ffeb914"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1_shader.html#a93fc729b28103f9ae51bab3f6ffeb914">setUniformMatrix4fv</a> (GLint pos, GLsizei count, const GLfloat *value, GLboolean tpose=false)</td></tr>
<tr class="separator:a93fc729b28103f9ae51bab3f6ffeb914"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa7ad8dae86bfc96bf48d8b036a906b3d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1_shader.html#aa7ad8dae86bfc96bf48d8b036a906b3d">setUniformMatrix4fv</a> (const std::string name, GLsizei count, const GLfloat *value, GLboolean tpose=false)</td></tr>
<tr class="separator:aa7ad8dae86bfc96bf48d8b036a906b3d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad766876ba9040fc22c79e43def531716"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1_shader.html#ad766876ba9040fc22c79e43def531716">setUniformMatrix2x3fv</a> (GLint pos, GLsizei count, const GLfloat *value, GLboolean tpose=false)</td></tr>
<tr class="separator:ad766876ba9040fc22c79e43def531716"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1170ad0e0e0886f625a27b369ed7e970"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1_shader.html#a1170ad0e0e0886f625a27b369ed7e970">setUniformMatrix2x3fv</a> (const std::string name, GLsizei count, const GLfloat *value, GLboolean tpose=false)</td></tr>
<tr class="separator:a1170ad0e0e0886f625a27b369ed7e970"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3127476da9e4a0309dc08be48e28aa5f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1_shader.html#a3127476da9e4a0309dc08be48e28aa5f">setUniformMatrix3x2fv</a> (GLint pos, GLsizei count, const GLfloat *value, GLboolean tpose=false)</td></tr>
<tr class="separator:a3127476da9e4a0309dc08be48e28aa5f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abed1cd44327cf09515fe5779b4674f94"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1_shader.html#abed1cd44327cf09515fe5779b4674f94">setUniformMatrix3x2fv</a> (const std::string name, GLsizei count, const GLfloat *value, GLboolean tpose=false)</td></tr>
<tr class="separator:abed1cd44327cf09515fe5779b4674f94"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5035da73ec381eaa0ad9c0ef31a5f1bc"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1_shader.html#a5035da73ec381eaa0ad9c0ef31a5f1bc">setUniformMatrix2x4fv</a> (GLint pos, GLsizei count, const GLfloat *value, GLboolean tpose=false)</td></tr>
<tr class="separator:a5035da73ec381eaa0ad9c0ef31a5f1bc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:addd607e514bd044928fb1a0ffcf889b3"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1_shader.html#addd607e514bd044928fb1a0ffcf889b3">setUniformMatrix2x4fv</a> (const std::string name, GLsizei count, const GLfloat *value, GLboolean tpose=false)</td></tr>
<tr class="separator:addd607e514bd044928fb1a0ffcf889b3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a13ec51abc1bfaa5d06a65e03499d9725"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1_shader.html#a13ec51abc1bfaa5d06a65e03499d9725">setUniformMatrix4x2fv</a> (GLint pos, GLsizei count, const GLfloat *value, GLboolean tpose=false)</td></tr>
<tr class="separator:a13ec51abc1bfaa5d06a65e03499d9725"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4db71d444041b822c307a0db034a982b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1_shader.html#a4db71d444041b822c307a0db034a982b">setUniformMatrix4x2fv</a> (const std::string name, GLsizei count, const GLfloat *value, GLboolean tpose=false)</td></tr>
<tr class="separator:a4db71d444041b822c307a0db034a982b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad1de16a2ad8f48d94b8c6e8da842a5db"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1_shader.html#ad1de16a2ad8f48d94b8c6e8da842a5db">setUniformMatrix3x4fv</a> (GLint pos, GLsizei count, const GLfloat *value, GLboolean tpose=false)</td></tr>
<tr class="separator:ad1de16a2ad8f48d94b8c6e8da842a5db"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a77e0f30f82295ac6a54b87516d1cccc7"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1_shader.html#a77e0f30f82295ac6a54b87516d1cccc7">setUniformMatrix3x4fv</a> (const std::string name, GLsizei count, const GLfloat *value, GLboolean tpose=false)</td></tr>
<tr class="separator:a77e0f30f82295ac6a54b87516d1cccc7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4082351141fefc9cdab2a80f449f63b2"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1_shader.html#a4082351141fefc9cdab2a80f449f63b2">setUniformMatrix4x3fv</a> (GLint pos, GLsizei count, const GLfloat *value, GLboolean tpose=false)</td></tr>
<tr class="separator:a4082351141fefc9cdab2a80f449f63b2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0f4303f35f4550fa1eab703906338719"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1_shader.html#a0f4303f35f4550fa1eab703906338719">setUniformMatrix4x3fv</a> (const std::string name, GLsizei count, const GLfloat *value, GLboolean tpose=false)</td></tr>
<tr class="separator:a0f4303f35f4550fa1eab703906338719"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7d36aca9e21928b3fccd52f5e53a1573"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1_shader.html#a7d36aca9e21928b3fccd52f5e53a1573">getUniformfv</a> (GLint pos, GLsizei size, GLfloat *value) const</td></tr>
<tr class="separator:a7d36aca9e21928b3fccd52f5e53a1573"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a730a2dcefd0ee8f696548ba685d383e5"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1_shader.html#a730a2dcefd0ee8f696548ba685d383e5">getUniformfv</a> (const std::string name, GLsizei size, GLfloat *value) const</td></tr>
<tr class="separator:a730a2dcefd0ee8f696548ba685d383e5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a367db85b48c01006f68c2f51dafdda6f"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1_shader.html#a367db85b48c01006f68c2f51dafdda6f">getUniformiv</a> (GLint pos, GLsizei size, GLint *value) const</td></tr>
<tr class="separator:a367db85b48c01006f68c2f51dafdda6f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a73fdfdad9c6d67c0b17fe27735f5ca9b"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1_shader.html#a73fdfdad9c6d67c0b17fe27735f5ca9b">getUniformiv</a> (const std::string name, GLsizei size, GLint *value) const</td></tr>
<tr class="separator:a73fdfdad9c6d67c0b17fe27735f5ca9b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a74c13300817ed8394a4ff3914ac506d0"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1_shader.html#a74c13300817ed8394a4ff3914ac506d0">getUniformuiv</a> (GLint pos, GLsizei size, GLuint *value) const</td></tr>
<tr class="separator:a74c13300817ed8394a4ff3914ac506d0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3718174de1e78bec860ece3a582d0a99"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1_shader.html#a3718174de1e78bec860ece3a582d0a99">getUniformuiv</a> (const std::string name, GLsizei size, GLuint *value) const</td></tr>
<tr class="separator:a3718174de1e78bec860ece3a582d0a99"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-static-methods"></a>
Static Public Member Functions</h2></td></tr>
<tr class="memitem:a8d8f40560699be6c4ae6a02e66d66ac0"><td class="memItemLeft" align="right" valign="top">static std::shared_ptr&lt; <a class="el" href="classcugl_1_1_shader.html">Shader</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1_shader.html#a8d8f40560699be6c4ae6a02e66d66ac0">alloc</a> (const std::string vsource, std::string fsource)</td></tr>
<tr class="separator:a8d8f40560699be6c4ae6a02e66d66ac0"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pro-attribs"></a>
Protected Attributes</h2></td></tr>
<tr class="memitem:aaf5dd17fa273e53bdc86beb5d82243dc"><td class="memItemLeft" align="right" valign="top">GLuint&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1_shader.html#aaf5dd17fa273e53bdc86beb5d82243dc">_program</a></td></tr>
<tr class="separator:aaf5dd17fa273e53bdc86beb5d82243dc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a023c20d88612467ea0ba992516393da5"><td class="memItemLeft" align="right" valign="top">GLuint&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1_shader.html#a023c20d88612467ea0ba992516393da5">_vertShader</a></td></tr>
<tr class="separator:a023c20d88612467ea0ba992516393da5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a10fec4e22c37de1f249d2eea920bfb08"><td class="memItemLeft" align="right" valign="top">GLuint&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1_shader.html#a10fec4e22c37de1f249d2eea920bfb08">_fragShader</a></td></tr>
<tr class="separator:a10fec4e22c37de1f249d2eea920bfb08"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a172bae1008cbed036fec484f6b9b15d0"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1_shader.html#a172bae1008cbed036fec484f6b9b15d0">_vertSource</a></td></tr>
<tr class="separator:a172bae1008cbed036fec484f6b9b15d0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6fcbc98b42cabdea274754b51386fcd6"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1_shader.html#a6fcbc98b42cabdea274754b51386fcd6">_fragSource</a></td></tr>
<tr class="separator:a6fcbc98b42cabdea274754b51386fcd6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a21e6a924b22ab5cdedbada74f24e307f"><td class="memItemLeft" align="right" valign="top">std::unordered_map&lt; std::string, GLenum &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1_shader.html#a21e6a924b22ab5cdedbada74f24e307f">_attribtypes</a></td></tr>
<tr class="separator:a21e6a924b22ab5cdedbada74f24e307f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3eaf330d845736f829448b99cdb50569"><td class="memItemLeft" align="right" valign="top">std::unordered_map&lt; GLint, std::string &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1_shader.html#a3eaf330d845736f829448b99cdb50569">_attribnames</a></td></tr>
<tr class="separator:a3eaf330d845736f829448b99cdb50569"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a591c2872dc55f68cad631697fd9cfe99"><td class="memItemLeft" align="right" valign="top">std::unordered_map&lt; std::string, GLint &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1_shader.html#a591c2872dc55f68cad631697fd9cfe99">_attribsizes</a></td></tr>
<tr class="separator:a591c2872dc55f68cad631697fd9cfe99"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a57e3b86e15e2bdfb0bc5e6cd6a310ddc"><td class="memItemLeft" align="right" valign="top">std::unordered_map&lt; std::string, GLenum &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1_shader.html#a57e3b86e15e2bdfb0bc5e6cd6a310ddc">_uniformtypes</a></td></tr>
<tr class="separator:a57e3b86e15e2bdfb0bc5e6cd6a310ddc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4a5fb2e115e1c2d45e9541f6bbb19fa6"><td class="memItemLeft" align="right" valign="top">std::unordered_map&lt; GLint, std::string &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1_shader.html#a4a5fb2e115e1c2d45e9541f6bbb19fa6">_uniformnames</a></td></tr>
<tr class="separator:a4a5fb2e115e1c2d45e9541f6bbb19fa6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a98fcac69b007c708f01393163679b42d"><td class="memItemLeft" align="right" valign="top">std::unordered_map&lt; std::string, GLint &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1_shader.html#a98fcac69b007c708f01393163679b42d">_uniformsizes</a></td></tr>
<tr class="separator:a98fcac69b007c708f01393163679b42d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae61da7dcab6d99b83b8cb9f0c08560dd"><td class="memItemLeft" align="right" valign="top">std::unordered_map&lt; GLint, std::string &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1_shader.html#ae61da7dcab6d99b83b8cb9f0c08560dd">_uniblocknames</a></td></tr>
<tr class="separator:ae61da7dcab6d99b83b8cb9f0c08560dd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4d8afa8350ff5dd219fd97d44af574bd"><td class="memItemLeft" align="right" valign="top">std::unordered_map&lt; std::string, GLint &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1_shader.html#a4d8afa8350ff5dd219fd97d44af574bd">_uniblocksizes</a></td></tr>
<tr class="separator:a4d8afa8350ff5dd219fd97d44af574bd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a215552de318475ff70a9d68eeb3f1555"><td class="memItemLeft" align="right" valign="top">std::unordered_map&lt; GLint, GLint &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1_shader.html#a215552de318475ff70a9d68eeb3f1555">_uniblockfields</a></td></tr>
<tr class="separator:a215552de318475ff70a9d68eeb3f1555"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>This class defines a GLSL shader.</p>
<p>This class compiles and links any well-defined GLSL shader. It also has methods for querying and binding the shader. The class is written to be agnostic about whether we are using OpenGL or OpenGLES.</p>
<p>However, a shader cannot be used by itself. To use a shader, it must first be attached to a <a class="el" href="classcugl_1_1_vertex_buffer.html">VertexBuffer</a>. When using a shader, with a vertex buffer keep in mind the "performance hit" hierarchy. From our experiments, the cost of changing data in a rendering phase going from most expensive to cheapest is as follows:</p>
<ul>
<li>
Render target </li>
<li>
<a class="el" href="classcugl_1_1_shader.html">Shader</a> </li>
<li>
Sampler </li>
<li>
Vertex Buffer </li>
<li>
Vertex Stream </li>
<li>
<a class="el" href="classcugl_1_1_texture.html">Texture</a> </li>
<li>
Uniform </li>
<li>
Draw Call </li>
</ul>
<p>By vertex stream we mean the act of loading data into a vertex buffer. Since the cost of swapping a vertex buffer is more expensive that reloading data into it, a vertex buffer should only be swapped when the format of the vertex data changes.</p>
<p>Uniforms tend to be fairly cheap. However, some uniforms are samplers and those are incredibly expensive to change. A sampler is a uniform that is bound to a texture bind point. Because of how textures are loaded, it is (much) cheaper to activate a texture to an existing bind point than it is to change the bind point used in the shader.</p>
<p>Even the most basic uniforms are by no means cheap. The best case graphics performance is when you can load the vertex buffer once and then call a single draw command for all of the vertices (the difference is an order of magnitude). <br  />
 Therefore, any properties that space only a few vertices (e.g. quads) should be pushed into the vertex data itself. For example, it is faster to transform quads in the CPU than it is in the GPU.</p>
<p>Because of the limitations of OpenGLES, this class only supports vertex and fragment shaders &ndash; it does not support tesselation or geometry shaders. <br  />
 Furthermore, keep in mind that Apple has deprecated OpenGL. MacOS devices are stuck at OpenGL 4.1 and iOS devices are stuck at OpenGLES 3.0. So it is not safe to use any shader more recent than version 140 on desktop/laptop and version 300 on mobile.</p>
<p>Another side effect of OpenGLES is that this class does not support explicit binding of multiple output locations (glBindFragDataLocation). If a shader has multiple output targets, then these must be explicitly managed inside the shader with the layout keyword. Otherwise, the output bind points from the appropriate query methods. </p>
</div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="a1f45b4e8cda28709f1dccfe4933ef363"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1f45b4e8cda28709f1dccfe4933ef363">&#9670;&nbsp;</a></span>Shader()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">cugl::Shader::Shader </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Creates an uninitialized shader with no source.</p>
<p>You must initialize the shader to add a source and compile it. </p>

</div>
</div>
<a id="a51039e6ccd81e1041cca8abc2a876209"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a51039e6ccd81e1041cca8abc2a876209">&#9670;&nbsp;</a></span>~Shader()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">cugl::Shader::~Shader </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Deletes this shader, disposing all resources. </p>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="a8d8f40560699be6c4ae6a02e66d66ac0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8d8f40560699be6c4ae6a02e66d66ac0">&#9670;&nbsp;</a></span>alloc()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static std::shared_ptr&lt;<a class="el" href="classcugl_1_1_shader.html">Shader</a>&gt; cugl::Shader::alloc </td>
          <td>(</td>
          <td class="paramtype">const std::string&#160;</td>
          <td class="paramname"><em>vsource</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>fsource</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns a new shader with the given vertex and fragment source.</p>
<p>The shader will compile the vertex and fragment sources and link them together. When compilation is complete, the shader will be bound and active.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">vsource</td><td>The source string for the vertex shader. </td></tr>
    <tr><td class="paramname">fsource</td><td>The source string for the fragment shader.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a new shader with the given vertex and fragment source. </dd></dl>

</div>
</div>
<a id="ac83752645253890a578f0306570ec332"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac83752645253890a578f0306570ec332">&#9670;&nbsp;</a></span>bind()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void cugl::Shader::bind </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Binds this shader, making it active.</p>
<p>Once bound, any OpenGL calls will then be sent to this shader. This call is reentrant, and may safely be called on an active shader. </p>

</div>
</div>
<a id="ae311cd023ba662bb8c3bec26e7a579ed"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae311cd023ba662bb8c3bec26e7a579ed">&#9670;&nbsp;</a></span>dispose()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void cugl::Shader::dispose </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Deletes the OpenGL shader and resets all attributes.</p>
<p>You must reinitialize the shader to use it. </p>

</div>
</div>
<a id="af51f4c12d990642720743b25abbb1735"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af51f4c12d990642720743b25abbb1735">&#9670;&nbsp;</a></span>getAttributeLocation()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">GLint cugl::Shader::getAttributeLocation </td>
          <td>(</td>
          <td class="paramtype">const std::string&#160;</td>
          <td class="paramname"><em>name</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns the program offset of the given attribute</p>
<p>If name is not a valid attribute, this method returns -1.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">name</td><td>The attribute variable name</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the program offset of the given attribute </dd></dl>

</div>
</div>
<a id="a9b69a41d7400bdc604d872cacc323bd0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9b69a41d7400bdc604d872cacc323bd0">&#9670;&nbsp;</a></span>getAttributes()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;std::string&gt; cugl::Shader::getAttributes </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns a vector of all attribute variables in this shader</p>
<dl class="section return"><dt>Returns</dt><dd>a vector of all attribute variables in this shader </dd></dl>

</div>
</div>
<a id="af7c0ff97d740a3f4e5210d103dea27ea"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af7c0ff97d740a3f4e5210d103dea27ea">&#9670;&nbsp;</a></span>getAttributeSize()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">GLint cugl::Shader::getAttributeSize </td>
          <td>(</td>
          <td class="paramtype">const std::string&#160;</td>
          <td class="paramname"><em>name</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns the size (in bytes) of the given attribute</p>
<p>If name is not a valid attribute, this method returns -1.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">name</td><td>The attribute variable name</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the size (in bytes) of the given attribute </dd></dl>

</div>
</div>
<a id="a26d4c13fa89707f20fed37c7b9c3d9b6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a26d4c13fa89707f20fed37c7b9c3d9b6">&#9670;&nbsp;</a></span>getAttributeType()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">GLenum cugl::Shader::getAttributeType </td>
          <td>(</td>
          <td class="paramtype">const std::string&#160;</td>
          <td class="paramname"><em>name</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns the type of the given attribute</p>
<p>If name is not a valid attribute, this method returns GL_FALSE.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">name</td><td>The attribute variable name</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the type of the given attribute </dd></dl>

</div>
</div>
<a id="aab781df9a094c246fb354c45244f55ee"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aab781df9a094c246fb354c45244f55ee">&#9670;&nbsp;</a></span>getFragSource()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const std::string cugl::Shader::getFragSource </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns the source string for the fragment shader.</p>
<p>The string is empty if not defined.</p>
<dl class="section return"><dt>Returns</dt><dd>the source string for the fragment shader. </dd></dl>

</div>
</div>
<a id="abd4ecaf24ddce0d86bdd6342b5b4412d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abd4ecaf24ddce0d86bdd6342b5b4412d">&#9670;&nbsp;</a></span>getOutputLocation()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">GLint cugl::Shader::getOutputLocation </td>
          <td>(</td>
          <td class="paramtype">const std::string&#160;</td>
          <td class="paramname"><em>name</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns the program offset of the given output variable.</p>
<p>An output variable is a variable in a fragment shader that writes to a texture. All shaders have at least one output variable. However, shaders can have more than one output variable, particularly when used in conjunction with a <a class="el" href="classcugl_1_1_render_target.html">RenderTarget</a>. This method is helpful for getting the number and names of these variables for setting up a <a class="el" href="classcugl_1_1_render_target.html">RenderTarget</a>.</p>
<p>To explicit set the program offset of an output variable, the shader should use the layout keyword in GLSL. Because of compatibility issues with Apple products (iOS, MacOS), it is not possible to get much information about output variables other than their location.</p>
<p>If name is not a valid output variable, this method returns -1.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">name</td><td>The output variable name</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the program offset of the given output variable. </dd></dl>

</div>
</div>
<a id="a500360d59cf2b0e8519d779584843552"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a500360d59cf2b0e8519d779584843552">&#9670;&nbsp;</a></span>getProgram()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">GLuint cugl::Shader::getProgram </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns the OpenGL program associated with this shader.</p>
<p>This method will return 0 if the program is not initialized.</p>
<dl class="section return"><dt>Returns</dt><dd>the OpenGL program associated with this shader. </dd></dl>

</div>
</div>
<a id="ab17e493b6191b2dd01a18abe3c84b321"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab17e493b6191b2dd01a18abe3c84b321">&#9670;&nbsp;</a></span>getSampler() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">GLuint cugl::Shader::getSampler </td>
          <td>(</td>
          <td class="paramtype">const std::string&#160;</td>
          <td class="paramname"><em>name</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns the texture bindpoint associated with the given sampler variable.</p>
<p>The shader does not track the actual texture associated with this bindpoint, only the bindpoint itself. It is up to the software developer to keep track of what texture is currently at that bindpoint.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">name</td><td>The name of the sampler variable</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the texture bindpoint associated with the given sampler variable. </dd></dl>

</div>
</div>
<a id="a87e9b3c923cbd35245f0cb20d1196fea"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a87e9b3c923cbd35245f0cb20d1196fea">&#9670;&nbsp;</a></span>getSampler() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">GLuint cugl::Shader::getSampler </td>
          <td>(</td>
          <td class="paramtype">GLint&#160;</td>
          <td class="paramname"><em>pos</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns the texture bindpoint associated with the given sampler variable.</p>
<p>The shader does not track the actual texture associated with this bindpoint, only the bindpoint itself. It is up to the software developer to keep track of what texture is currently at that bindpoint.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pos</td><td>The location of the sampler in the shader</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the texture bindpoint associated with the given sampler variable. </dd></dl>

</div>
</div>
<a id="a05290c7a5b69d15de38b8dc4b239e4d9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a05290c7a5b69d15de38b8dc4b239e4d9">&#9670;&nbsp;</a></span>getSamplerLocation()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">GLint cugl::Shader::getSamplerLocation </td>
          <td>(</td>
          <td class="paramtype">const std::string&#160;</td>
          <td class="paramname"><em>name</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns the program offset of the given sampler variable</p>
<p>A sampler is a variable attached to a texture. All samplers are also uniforms. Therefore this method has the same effect as the method <a class="el" href="classcugl_1_1_shader.html#a68ecdd5013205690e6ac211974b91363">getUniformLocation</a>.</p>
<p>If name is not a valid sampler, this method returns -1.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">name</td><td>The sampler variable name</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the program offset of the given sampler variable </dd></dl>

</div>
</div>
<a id="a07d157eff503c6df9eadbf320e84c543"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a07d157eff503c6df9eadbf320e84c543">&#9670;&nbsp;</a></span>getSamplers()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;std::string&gt; cugl::Shader::getSamplers </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns a vector of all samplers used by this shader</p>
<p>A sampler is a variable attached to a texture. All samplers are also uniforms. Therefore this vector is a subset of the names returned by <a class="el" href="classcugl_1_1_shader.html#a7b10e442569e72ab4c8d0558efba239d">getUniforms</a>.</p>
<dl class="section return"><dt>Returns</dt><dd>a vector of all samplers used by this shader </dd></dl>

</div>
</div>
<a id="ae32fffe6089192528ed016b8c2cb96fe"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae32fffe6089192528ed016b8c2cb96fe">&#9670;&nbsp;</a></span>getUniformAffine2() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool cugl::Shader::getUniformAffine2 </td>
          <td>(</td>
          <td class="paramtype">const std::string&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classcugl_1_1_affine2.html">Affine2</a> &amp;&#160;</td>
          <td class="paramname"><em>mat</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns true if it can access the given uniform as an affine transform.</p>
<p>Affine transforms are read from a shader as a 3x3 matrix on homogenous coordinates. This method will only succeed if the shader is actively bound. It assumes that the shader variable is a mat3 (or larger).</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">name</td><td>The name of the uniform </td></tr>
    <tr><td class="paramname">mat</td><td>The object to store the result</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if it can access the given uniform as an affine transform. </dd></dl>

</div>
</div>
<a id="a3aea4774493a9992ca72c3992819c9d4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3aea4774493a9992ca72c3992819c9d4">&#9670;&nbsp;</a></span>getUniformAffine2() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool cugl::Shader::getUniformAffine2 </td>
          <td>(</td>
          <td class="paramtype">GLint&#160;</td>
          <td class="paramname"><em>pos</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classcugl_1_1_affine2.html">Affine2</a> &amp;&#160;</td>
          <td class="paramname"><em>mat</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns true if it can access the given uniform as an affine transform.</p>
<p>Affine transforms are read from a shader as a 3x3 matrix on homogenous coordinates. This method will only succeed if the shader is actively bound. It assumes that the shader variable is a mat3 (or larger).</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pos</td><td>The location of the uniform in the shader </td></tr>
    <tr><td class="paramname">mat</td><td>The object to store the result</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if it can access the given uniform as an affine transform. </dd></dl>

</div>
</div>
<a id="a7169b8a1041b8f1fe13074fb6d4e8261"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7169b8a1041b8f1fe13074fb6d4e8261">&#9670;&nbsp;</a></span>getUniformBlock() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">GLuint cugl::Shader::getUniformBlock </td>
          <td>(</td>
          <td class="paramtype">const std::string&#160;</td>
          <td class="paramname"><em>name</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns the buffer bindpoint associated with the given uniform block.</p>
<p>The shader does not track the actual uniform buffer associated with this bindpoint, only the bindpoint itself. It is up to the software developer to keep track of what uniform buffer is currently at that bindpoint.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">name</td><td>The name of the uniform block in the shader</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the buffer bindpoint associated with the given uniform block. </dd></dl>

</div>
</div>
<a id="a6fbcfc6ad9ef7ad887db24a258024aa8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6fbcfc6ad9ef7ad887db24a258024aa8">&#9670;&nbsp;</a></span>getUniformBlock() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">GLuint cugl::Shader::getUniformBlock </td>
          <td>(</td>
          <td class="paramtype">GLint&#160;</td>
          <td class="paramname"><em>pos</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns the buffer bindpoint associated with the given uniform block.</p>
<p>The shader does not track the actual uniform buffer associated with this bindpoint, only the bindpoint itself. It is up to the software developer to keep track of what uniform buffer is currently at that bindpoint.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pos</td><td>The location of the uniform block in the shader</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the buffer bindpoint associated with the given uniform block. </dd></dl>

</div>
</div>
<a id="a8323ba02b41ddc141d1f968cb5b53c21"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8323ba02b41ddc141d1f968cb5b53c21">&#9670;&nbsp;</a></span>getUniformBlocks()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;std::string&gt; cugl::Shader::getUniformBlocks </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns a vector of all uniform blocks used by this shader</p>
<p>A uniform block is a variable attached to a uniform buffer. It is not the same as a normal uniform and cannot be treated as such. In this case the uniform values are set in the <a class="el" href="classcugl_1_1_uniform_buffer.html">UniformBuffer</a> object and not the shader.</p>
<dl class="section return"><dt>Returns</dt><dd>a vector of all uniform blocks used by this shader </dd></dl>

</div>
</div>
<a id="a850ef97dd4ec7b969f798cbce88e351c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a850ef97dd4ec7b969f798cbce88e351c">&#9670;&nbsp;</a></span>getUniformColor4() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool cugl::Shader::getUniformColor4 </td>
          <td>(</td>
          <td class="paramtype">const std::string&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classcugl_1_1_color4.html">Color4</a> &amp;&#160;</td>
          <td class="paramname"><em>color</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns true if it can access the given uniform as a color.</p>
<p>This method will only succeed if the shader is actively bound. It assumes that the shader variable is a vec4 (or larger).</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">name</td><td>The name of the uniform </td></tr>
    <tr><td class="paramname">color</td><td>The object to store the result</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if it can access the given uniform as a color. </dd></dl>

</div>
</div>
<a id="a759b2107673b66d9890b40daefff5ee5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a759b2107673b66d9890b40daefff5ee5">&#9670;&nbsp;</a></span>getUniformColor4() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool cugl::Shader::getUniformColor4 </td>
          <td>(</td>
          <td class="paramtype">GLint&#160;</td>
          <td class="paramname"><em>pos</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classcugl_1_1_color4.html">Color4</a> &amp;&#160;</td>
          <td class="paramname"><em>color</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns true if it can access the given uniform as a color.</p>
<p>This method will only succeed if the shader is actively bound. It assumes that the shader variable is a vec4 (or larger).</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pos</td><td>The location of the uniform in the shader </td></tr>
    <tr><td class="paramname">color</td><td>The object to store the result</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if it can access the given uniform as a color. </dd></dl>

</div>
</div>
<a id="a4b94899f51224ff3bad7e96eb66be52c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4b94899f51224ff3bad7e96eb66be52c">&#9670;&nbsp;</a></span>getUniformColor4f() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool cugl::Shader::getUniformColor4f </td>
          <td>(</td>
          <td class="paramtype">const std::string&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classcugl_1_1_color4f.html">Color4f</a> &amp;&#160;</td>
          <td class="paramname"><em>color</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns true if it can access the given uniform as a color.</p>
<p>This method will only succeed if the shader is actively bound. It assumes that the shader variable is a vec4 (or larger).</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">name</td><td>The name of the uniform </td></tr>
    <tr><td class="paramname">color</td><td>The object to store the result</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if it can access the given uniform as a color. </dd></dl>

</div>
</div>
<a id="a156be997ea28efb2280040d471c56c98"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a156be997ea28efb2280040d471c56c98">&#9670;&nbsp;</a></span>getUniformColor4f() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool cugl::Shader::getUniformColor4f </td>
          <td>(</td>
          <td class="paramtype">GLint&#160;</td>
          <td class="paramname"><em>pos</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classcugl_1_1_color4f.html">Color4f</a> &amp;&#160;</td>
          <td class="paramname"><em>color</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns true if it can access the given uniform as a color.</p>
<p>This method will only succeed if the shader is actively bound. It assumes that the shader variable is a vec4 (or larger).</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pos</td><td>The location of the uniform in the shader </td></tr>
    <tr><td class="paramname">color</td><td>The object to store the result</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if it can access the given uniform as a color. </dd></dl>

</div>
</div>
<a id="a730a2dcefd0ee8f696548ba685d383e5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a730a2dcefd0ee8f696548ba685d383e5">&#9670;&nbsp;</a></span>getUniformfv() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool cugl::Shader::getUniformfv </td>
          <td>(</td>
          <td class="paramtype">const std::string&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">GLsizei&#160;</td>
          <td class="paramname"><em>size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">GLfloat *&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Gets the given uniform as an array of float values</p>
<p>This method will only succeed if the shader is actively bound. It will silently fail (with no error) if name is does not refer to a valid uniform.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">name</td><td>The name of the uniform </td></tr>
    <tr><td class="paramname">size</td><td>The available size of the value array </td></tr>
    <tr><td class="paramname">value</td><td>The array to receive the values</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if data was successfully read into value </dd></dl>

</div>
</div>
<a id="a7d36aca9e21928b3fccd52f5e53a1573"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7d36aca9e21928b3fccd52f5e53a1573">&#9670;&nbsp;</a></span>getUniformfv() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool cugl::Shader::getUniformfv </td>
          <td>(</td>
          <td class="paramtype">GLint&#160;</td>
          <td class="paramname"><em>pos</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">GLsizei&#160;</td>
          <td class="paramname"><em>size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">GLfloat *&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Gets the given uniform as an array of float values</p>
<p>This method will only succeed if the shader is actively bound.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pos</td><td>The location of the uniform in the shader </td></tr>
    <tr><td class="paramname">size</td><td>The available size of the value array </td></tr>
    <tr><td class="paramname">value</td><td>The array to receive the values</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if data was successfully read into value </dd></dl>

</div>
</div>
<a id="a73fdfdad9c6d67c0b17fe27735f5ca9b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a73fdfdad9c6d67c0b17fe27735f5ca9b">&#9670;&nbsp;</a></span>getUniformiv() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool cugl::Shader::getUniformiv </td>
          <td>(</td>
          <td class="paramtype">const std::string&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">GLsizei&#160;</td>
          <td class="paramname"><em>size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">GLint *&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Gets the given uniform as an array of integer values</p>
<p>This method will only succeed if the shader is actively bound. It will silently fail (with no error) if name is does not refer to a valid uniform.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">name</td><td>The name of the uniform </td></tr>
    <tr><td class="paramname">size</td><td>The available size of the value array </td></tr>
    <tr><td class="paramname">value</td><td>The array to receive the values</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if data was successfully read into value </dd></dl>

</div>
</div>
<a id="a367db85b48c01006f68c2f51dafdda6f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a367db85b48c01006f68c2f51dafdda6f">&#9670;&nbsp;</a></span>getUniformiv() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool cugl::Shader::getUniformiv </td>
          <td>(</td>
          <td class="paramtype">GLint&#160;</td>
          <td class="paramname"><em>pos</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">GLsizei&#160;</td>
          <td class="paramname"><em>size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">GLint *&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Gets the given uniform as an array of integer values</p>
<p>This method will only succeed if the shader is actively bound.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pos</td><td>The location of the uniform in the shader </td></tr>
    <tr><td class="paramname">size</td><td>The available size of the value array </td></tr>
    <tr><td class="paramname">value</td><td>The array to receive the values</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if data was successfully read into value </dd></dl>

</div>
</div>
<a id="a68ecdd5013205690e6ac211974b91363"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a68ecdd5013205690e6ac211974b91363">&#9670;&nbsp;</a></span>getUniformLocation()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">GLint cugl::Shader::getUniformLocation </td>
          <td>(</td>
          <td class="paramtype">const std::string&#160;</td>
          <td class="paramname"><em>name</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns the program offset of the given uniform</p>
<p>If name is not a valid uniform, this method returns -1.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">name</td><td>The uniform variable name</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the program offset of the given uniform </dd></dl>

</div>
</div>
<a id="a79bef8b32fbf88d496bddfd79986a5d1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a79bef8b32fbf88d496bddfd79986a5d1">&#9670;&nbsp;</a></span>getUniformMat4() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool cugl::Shader::getUniformMat4 </td>
          <td>(</td>
          <td class="paramtype">const std::string&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classcugl_1_1_mat4.html">Mat4</a> &amp;&#160;</td>
          <td class="paramname"><em>mat</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns true if it can access the given uniform as a matrix.</p>
<p>This method will only succeed if the shader is actively bound. It assumes that the shader variable is a mat4 (or larger).</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">name</td><td>The name of the uniform </td></tr>
    <tr><td class="paramname">mat</td><td>The object to store the result</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if it can access the given uniform as a matrix. </dd></dl>

</div>
</div>
<a id="a022ce83a628b49f9d9d2fba7b585394f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a022ce83a628b49f9d9d2fba7b585394f">&#9670;&nbsp;</a></span>getUniformMat4() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool cugl::Shader::getUniformMat4 </td>
          <td>(</td>
          <td class="paramtype">GLint&#160;</td>
          <td class="paramname"><em>pos</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classcugl_1_1_mat4.html">Mat4</a> &amp;&#160;</td>
          <td class="paramname"><em>mat</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns true if it can access the given uniform as a matrix.</p>
<p>This method will only succeed if the shader is actively bound. It assumes that the shader variable is a mat4 (or larger).</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pos</td><td>The location of the uniform in the shader </td></tr>
    <tr><td class="paramname">mat</td><td>The object to store the result</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if it can access the given uniform as a matrix. </dd></dl>

</div>
</div>
<a id="a5064922915e7527a87b6caeadc70344e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5064922915e7527a87b6caeadc70344e">&#9670;&nbsp;</a></span>getUniformQuaternion() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool cugl::Shader::getUniformQuaternion </td>
          <td>(</td>
          <td class="paramtype">const std::string&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classcugl_1_1_quaternion.html">Quaternion</a> &amp;&#160;</td>
          <td class="paramname"><em>quat</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns true if it can access the given uniform as a quaternion.</p>
<p>This method will only succeed if the shader is actively bound. It assumes that the shader variable is a vec4 (or larger).</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">name</td><td>The name of the uniform </td></tr>
    <tr><td class="paramname">quat</td><td>The quaternion to store the result</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if it can access the given uniform as a quaternion. </dd></dl>

</div>
</div>
<a id="a0a06ccf9bf14788fb959c76bcafb7fc8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0a06ccf9bf14788fb959c76bcafb7fc8">&#9670;&nbsp;</a></span>getUniformQuaternion() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool cugl::Shader::getUniformQuaternion </td>
          <td>(</td>
          <td class="paramtype">GLint&#160;</td>
          <td class="paramname"><em>pos</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classcugl_1_1_quaternion.html">Quaternion</a> &amp;&#160;</td>
          <td class="paramname"><em>quat</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns true if it can access the given uniform as a quaternion.</p>
<p>This method will only succeed if the shader is actively bound. It assumes that the shader variable is a vec4 (or larger).</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pos</td><td>The location of the uniform in the shader </td></tr>
    <tr><td class="paramname">quat</td><td>The quaternion to store the result</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if it can access the given uniform as a quaternion. </dd></dl>

</div>
</div>
<a id="a7b10e442569e72ab4c8d0558efba239d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7b10e442569e72ab4c8d0558efba239d">&#9670;&nbsp;</a></span>getUniforms()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;std::string&gt; cugl::Shader::getUniforms </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns a vector of all uniform variables in this shader</p>
<dl class="section return"><dt>Returns</dt><dd>a vector of all uniform variables in this shader </dd></dl>

</div>
</div>
<a id="ae1c57ed76852be204f083453516aa391"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae1c57ed76852be204f083453516aa391">&#9670;&nbsp;</a></span>getUniformsForBlock() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;std::string&gt; cugl::Shader::getUniformsForBlock </td>
          <td>(</td>
          <td class="paramtype">GLint&#160;</td>
          <td class="paramname"><em>pos</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns a vector of all uniforms for the given block.</p>
<p>A uniform block is a variable attached to a uniform buffer. It is not the same as a normal uniform and cannot be treated as such. In this case the uniform values are set in the <a class="el" href="classcugl_1_1_uniform_buffer.html">UniformBuffer</a> object and not the shader.</p>
<p>This method allows us to verify that at <a class="el" href="classcugl_1_1_uniform_buffer.html">UniformBuffer</a> object properly matches this shader.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pos</td><td>The location of the uniform block in the shader</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a vector of all uniform blocks used by this shader </dd></dl>

</div>
</div>
<a id="abf80fea40769446a5f5144a069dcdd77"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abf80fea40769446a5f5144a069dcdd77">&#9670;&nbsp;</a></span>getUniformsForBlock() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;std::string&gt; cugl::Shader::getUniformsForBlock </td>
          <td>(</td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>name</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns a vector of all uniforms for the given block.</p>
<p>A uniform block is a variable attached to a uniform buffer. It is not the same as a normal uniform and cannot be treated as such. In this case the uniform values are set in the <a class="el" href="classcugl_1_1_uniform_buffer.html">UniformBuffer</a> object and not the shader.</p>
<p>This method allows us to verify that at <a class="el" href="classcugl_1_1_uniform_buffer.html">UniformBuffer</a> object properly matches this shader.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">name</td><td>The name of the uniform block in the shader</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a vector of all uniform blocks used by this shader </dd></dl>

</div>
</div>
<a id="a95fbae3e24ed6688bd5e3c577d01ccb0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a95fbae3e24ed6688bd5e3c577d01ccb0">&#9670;&nbsp;</a></span>getUniformSize()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">GLint cugl::Shader::getUniformSize </td>
          <td>(</td>
          <td class="paramtype">const std::string&#160;</td>
          <td class="paramname"><em>name</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns the size (in bytes) of the given uniform</p>
<p>If name is not a valid uniform, this method returns -1.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">name</td><td>The uniform variable name</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the size (in bytes) of the given uniform </dd></dl>

</div>
</div>
<a id="aa438eaa2aed5752a26cc7537b0f036c8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa438eaa2aed5752a26cc7537b0f036c8">&#9670;&nbsp;</a></span>getUniformType()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">GLenum cugl::Shader::getUniformType </td>
          <td>(</td>
          <td class="paramtype">const std::string&#160;</td>
          <td class="paramname"><em>name</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns the type of the given uniform</p>
<p>If name is not a valid uniform, this method returns GL_FALSE.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">name</td><td>The uniform variable name</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the type of the given uniform </dd></dl>

</div>
</div>
<a id="a3718174de1e78bec860ece3a582d0a99"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3718174de1e78bec860ece3a582d0a99">&#9670;&nbsp;</a></span>getUniformuiv() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool cugl::Shader::getUniformuiv </td>
          <td>(</td>
          <td class="paramtype">const std::string&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">GLsizei&#160;</td>
          <td class="paramname"><em>size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">GLuint *&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Gets the given uniform as an array of unsigned integer values</p>
<p>This method will only succeed if the shader is actively bound. It will silently fail (with no error) if name is does not refer to a valid uniform.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">name</td><td>The name of the uniform </td></tr>
    <tr><td class="paramname">size</td><td>The available size of the value array </td></tr>
    <tr><td class="paramname">value</td><td>The array to receive the values</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if data was successfully read into value </dd></dl>

</div>
</div>
<a id="a74c13300817ed8394a4ff3914ac506d0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a74c13300817ed8394a4ff3914ac506d0">&#9670;&nbsp;</a></span>getUniformuiv() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool cugl::Shader::getUniformuiv </td>
          <td>(</td>
          <td class="paramtype">GLint&#160;</td>
          <td class="paramname"><em>pos</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">GLsizei&#160;</td>
          <td class="paramname"><em>size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">GLuint *&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Gets the given uniform as an array of unsigned integer values</p>
<p>This method will only succeed if the shader is actively bound.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pos</td><td>The location of the uniform in the shader </td></tr>
    <tr><td class="paramname">size</td><td>The available size of the value array </td></tr>
    <tr><td class="paramname">value</td><td>The array to receive the values</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if data was successfully read into value </dd></dl>

</div>
</div>
<a id="a2a391f95655031aae9129590f8f1182a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2a391f95655031aae9129590f8f1182a">&#9670;&nbsp;</a></span>getUniformVec2() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool cugl::Shader::getUniformVec2 </td>
          <td>(</td>
          <td class="paramtype">const std::string&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classcugl_1_1_vec2.html">Vec2</a> &amp;&#160;</td>
          <td class="paramname"><em>vec</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns true if it can access the given uniform as a vector.</p>
<p>This method will only succeed if the shader is actively bound. It assumes that the shader variable is a vec2 (or larger).</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">name</td><td>The name of the uniform </td></tr>
    <tr><td class="paramname">vec</td><td>The vector to store the result</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if it can access the given uniform as a vector. </dd></dl>

</div>
</div>
<a id="ac2c63e406dbef9693e656895c42974b6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac2c63e406dbef9693e656895c42974b6">&#9670;&nbsp;</a></span>getUniformVec2() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool cugl::Shader::getUniformVec2 </td>
          <td>(</td>
          <td class="paramtype">GLint&#160;</td>
          <td class="paramname"><em>pos</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classcugl_1_1_vec2.html">Vec2</a> &amp;&#160;</td>
          <td class="paramname"><em>vec</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns true if it can access the given uniform as a vector.</p>
<p>This method will only succeed if the shader is actively bound. It assumes that the shader variable is a vec2 (or larger).</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pos</td><td>The location of the uniform in the shader </td></tr>
    <tr><td class="paramname">vec</td><td>The vector to store the result</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if it can access the given uniform as a vector. </dd></dl>

</div>
</div>
<a id="a6d305ed33fc6f53ad1cbf6c7c9ea5bc7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6d305ed33fc6f53ad1cbf6c7c9ea5bc7">&#9670;&nbsp;</a></span>getUniformVec3() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool cugl::Shader::getUniformVec3 </td>
          <td>(</td>
          <td class="paramtype">const std::string&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classcugl_1_1_vec3.html">Vec3</a> &amp;&#160;</td>
          <td class="paramname"><em>vec</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns true if it can access the given uniform as a vector.</p>
<p>This method will only succeed if the shader is actively bound. It assumes that the shader variable is a vec3 (or larger).</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">name</td><td>The name of the uniform </td></tr>
    <tr><td class="paramname">vec</td><td>The vector to store the result</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if it can access the given uniform as a vector. </dd></dl>

</div>
</div>
<a id="a60bea1dcccb2e633de865ee7961faf4a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a60bea1dcccb2e633de865ee7961faf4a">&#9670;&nbsp;</a></span>getUniformVec3() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool cugl::Shader::getUniformVec3 </td>
          <td>(</td>
          <td class="paramtype">GLint&#160;</td>
          <td class="paramname"><em>pos</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classcugl_1_1_vec3.html">Vec3</a> &amp;&#160;</td>
          <td class="paramname"><em>vec</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns true if it can access the given uniform as a vector.</p>
<p>This method will only succeed if the shader is actively bound. It assumes that the shader variable is a vec3 (or larger).</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pos</td><td>The location of the uniform in the shader </td></tr>
    <tr><td class="paramname">vec</td><td>The vector to store the result</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if it can access the given uniform as a vector. </dd></dl>

</div>
</div>
<a id="aaaef0dc4f372baca5e1c289162fa4b73"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaaef0dc4f372baca5e1c289162fa4b73">&#9670;&nbsp;</a></span>getUniformVec4() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool cugl::Shader::getUniformVec4 </td>
          <td>(</td>
          <td class="paramtype">const std::string&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classcugl_1_1_vec4.html">Vec4</a> &amp;&#160;</td>
          <td class="paramname"><em>vec</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns true if it can access the given uniform as a vector.</p>
<p>This method will only succeed if the shader is actively bound. It assumes that the shader variable is a vec4 (or larger).</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">name</td><td>The name of the uniform </td></tr>
    <tr><td class="paramname">vec</td><td>The vector to store the result</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if it can access the given uniform as a vector. </dd></dl>

</div>
</div>
<a id="a49e0a88ea49043c4a3f035636df62f27"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a49e0a88ea49043c4a3f035636df62f27">&#9670;&nbsp;</a></span>getUniformVec4() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool cugl::Shader::getUniformVec4 </td>
          <td>(</td>
          <td class="paramtype">GLint&#160;</td>
          <td class="paramname"><em>pos</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classcugl_1_1_vec4.html">Vec4</a> &amp;&#160;</td>
          <td class="paramname"><em>vec</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns true if it can access the given uniform as a vector.</p>
<p>This method will only succeed if the shader is actively bound. It assumes that the shader variable is a vec4 (or larger).</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pos</td><td>The location of the uniform in the shader </td></tr>
    <tr><td class="paramname">vec</td><td>The vector to store the result</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if it can access the given uniform as a vector. </dd></dl>

</div>
</div>
<a id="ae11b0b1a9c4ade9a501bd30448ff202e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae11b0b1a9c4ade9a501bd30448ff202e">&#9670;&nbsp;</a></span>getVertSource()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const std::string cugl::Shader::getVertSource </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns the source string for the vertex shader.</p>
<p>The string is empty if not defined.</p>
<dl class="section return"><dt>Returns</dt><dd>the source string for the vertex shader. </dd></dl>

</div>
</div>
<a id="a4e6cb4d084b72f9276ab03f8bdc370b2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4e6cb4d084b72f9276ab03f8bdc370b2">&#9670;&nbsp;</a></span>init()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool cugl::Shader::init </td>
          <td>(</td>
          <td class="paramtype">const std::string&#160;</td>
          <td class="paramname"><em>vsource</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>fsource</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Initializes this shader with the given vertex and fragment source.</p>
<p>The shader will compile the vertex and fragment sources and link them together. When compilation is complete, the shader will be bound and active.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">vsource</td><td>The source string for the vertex shader. </td></tr>
    <tr><td class="paramname">fsource</td><td>The source string for the fragment shader.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if initialization was successful. </dd></dl>

</div>
</div>
<a id="ab33787a07657f2e0c94fecfddad10f90"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab33787a07657f2e0c94fecfddad10f90">&#9670;&nbsp;</a></span>isBound()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool cugl::Shader::isBound </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns true if this shader is currently bound.</p>
<p>Any OpenGL calls will be sent to this shader only if it is bound.</p>
<dl class="section return"><dt>Returns</dt><dd>true if this shader is currently bound. </dd></dl>

</div>
</div>
<a id="aac3764774f73d5ffe24bbe2d1856eec1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aac3764774f73d5ffe24bbe2d1856eec1">&#9670;&nbsp;</a></span>isReady()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool cugl::Shader::isReady </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns true if this shader has been compiled and is ready for use.</p>
<dl class="section return"><dt>Returns</dt><dd>true if this shader has been compiled and is ready for use. </dd></dl>

</div>
</div>
<a id="a084172af4970025715267be7eb342632"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a084172af4970025715267be7eb342632">&#9670;&nbsp;</a></span>setSampler() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void cugl::Shader::setSampler </td>
          <td>(</td>
          <td class="paramtype">const std::string&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::shared_ptr&lt; <a class="el" href="classcugl_1_1_texture.html">Texture</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>texture</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Sets the given sampler variable to the bindpoint of the given texture.</p>
<p>A sampler is a variable attached to a texture. All samplers are also uniforms. Therefore this method has the same effect as the method <a class="el" href="classcugl_1_1_shader.html#a27a1a6b739c2e027cbce581ccadd4e88">setUniform1ui</a>.</p>
<p>This method will bind the sampler to the current bindpoint of the texture. The shader will not be aware if the texture changes its bindpoint in the future.</p>
<p>This method will only succeed if the shader is actively bound.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">name</td><td>The name of the sampler variable </td></tr>
    <tr><td class="paramname">texture</td><td>The texture to initialize the bindpoint </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ad040645d332b014080a0cbfb50823365"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad040645d332b014080a0cbfb50823365">&#9670;&nbsp;</a></span>setSampler() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void cugl::Shader::setSampler </td>
          <td>(</td>
          <td class="paramtype">const std::string&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">GLuint&#160;</td>
          <td class="paramname"><em>bpoint</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Sets the given sampler variable to a texture bindpoint.</p>
<p>A sampler is a variable attached to a texture. All samplers are also uniforms. Therefore this method has the same effect as the method <a class="el" href="classcugl_1_1_shader.html#a27a1a6b739c2e027cbce581ccadd4e88">setUniform1ui</a>.</p>
<p>This method will only succeed if the shader is actively bound.</p>
<p>Note that changing this value is causes a significant performance hit to a shader. Whenever possible, it is better to keep the bindpoint the same while binding a different texture to the same point.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">name</td><td>The name of the sampler variable </td></tr>
    <tr><td class="paramname">bpoint</td><td>The bindpoint for the sampler </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a15a63caa00e20c3cc6a59129e283d606"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a15a63caa00e20c3cc6a59129e283d606">&#9670;&nbsp;</a></span>setSampler() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void cugl::Shader::setSampler </td>
          <td>(</td>
          <td class="paramtype">GLint&#160;</td>
          <td class="paramname"><em>pos</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::shared_ptr&lt; <a class="el" href="classcugl_1_1_texture.html">Texture</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>texture</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Sets the given sampler variable to the bindpoint of the given texture.</p>
<p>A sampler is a variable attached to a texture. All samplers are also uniforms. Therefore this method has the same effect as the method <a class="el" href="classcugl_1_1_shader.html#a27a1a6b739c2e027cbce581ccadd4e88">setUniform1ui</a>.</p>
<p>This method will only succeed if the shader is actively bound.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pos</td><td>The location of the sampler in the shader </td></tr>
    <tr><td class="paramname">texture</td><td>The texture to initialize the bindpoint </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a071fe403382f133ee28d5e4adeb1fe08"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a071fe403382f133ee28d5e4adeb1fe08">&#9670;&nbsp;</a></span>setSampler() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void cugl::Shader::setSampler </td>
          <td>(</td>
          <td class="paramtype">GLint&#160;</td>
          <td class="paramname"><em>pos</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">GLuint&#160;</td>
          <td class="paramname"><em>bpoint</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Sets the given sampler variable to a texture bindpoint.</p>
<p>A sampler is a variable attached to a texture. All samplers are also uniforms. Therefore this method has the same effect as the method <a class="el" href="classcugl_1_1_shader.html#a27a1a6b739c2e027cbce581ccadd4e88">setUniform1ui</a>.</p>
<p>This method will only succeed if the shader is actively bound.</p>
<p>Note that changing this value is causes a significant performance hit to a shader. Whenever possible, it is better to keep the bindpoint the same while binding a different texture to the same point.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pos</td><td>The location of the sampler in the shader </td></tr>
    <tr><td class="paramname">bpoint</td><td>The bindpoint for the sampler </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a057e71d7f33de4f67c12f426dd7ef3ed"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a057e71d7f33de4f67c12f426dd7ef3ed">&#9670;&nbsp;</a></span>setUniform1f() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void cugl::Shader::setUniform1f </td>
          <td>(</td>
          <td class="paramtype">const std::string&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">GLfloat&#160;</td>
          <td class="paramname"><em>v0</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Sets the given uniform to a single float value.</p>
<p>This method will only succeed if the shader is actively bound. It will silently fail (with no error) if name is does not refer to a valid uniform.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">name</td><td>The name of the uniform </td></tr>
    <tr><td class="paramname">v0</td><td>The value for the uniform </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ac7a326e9afdd8a62eabf07948214feab"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac7a326e9afdd8a62eabf07948214feab">&#9670;&nbsp;</a></span>setUniform1f() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void cugl::Shader::setUniform1f </td>
          <td>(</td>
          <td class="paramtype">GLint&#160;</td>
          <td class="paramname"><em>pos</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">GLfloat&#160;</td>
          <td class="paramname"><em>v0</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Sets the given uniform to a single float value.</p>
<p>This method will only succeed if the shader is actively bound.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pos</td><td>The location of the uniform in the shader </td></tr>
    <tr><td class="paramname">v0</td><td>The value for the uniform </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a4483075e887c626c524d46d0126cbe9b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4483075e887c626c524d46d0126cbe9b">&#9670;&nbsp;</a></span>setUniform1fv() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void cugl::Shader::setUniform1fv </td>
          <td>(</td>
          <td class="paramtype">const std::string&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">GLsizei&#160;</td>
          <td class="paramname"><em>count</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const GLfloat *&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Sets the given uniform to an array of 1-element floats.</p>
<p>This method will only succeed if the shader is actively bound. It will silently fail (with no error) if name is does not refer to a valid uniform.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">name</td><td>The name of the uniform </td></tr>
    <tr><td class="paramname">count</td><td>The number of elements in the array </td></tr>
    <tr><td class="paramname">value</td><td>The array of floats </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aee4d3d42a7a1db77d6f42dc6ee893f10"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aee4d3d42a7a1db77d6f42dc6ee893f10">&#9670;&nbsp;</a></span>setUniform1fv() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void cugl::Shader::setUniform1fv </td>
          <td>(</td>
          <td class="paramtype">GLint&#160;</td>
          <td class="paramname"><em>pos</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">GLsizei&#160;</td>
          <td class="paramname"><em>count</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const GLfloat *&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Sets the given uniform to an array of 1-element floats.</p>
<p>This method will only succeed if the shader is actively bound.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pos</td><td>The location of the uniform in the shader </td></tr>
    <tr><td class="paramname">count</td><td>The number of elements in the array </td></tr>
    <tr><td class="paramname">value</td><td>The array of floats </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a4d5e0d5cdf90008f1530f6689b1fa274"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4d5e0d5cdf90008f1530f6689b1fa274">&#9670;&nbsp;</a></span>setUniform1i() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void cugl::Shader::setUniform1i </td>
          <td>(</td>
          <td class="paramtype">const std::string&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">GLint&#160;</td>
          <td class="paramname"><em>v0</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Sets the given uniform to a single int value.</p>
<p>This method will only succeed if the shader is actively bound. It will silently fail (with no error) if name is does not refer to a valid uniform.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">name</td><td>The name of the uniform </td></tr>
    <tr><td class="paramname">v0</td><td>The value for the uniform </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a81375366f1128711de01ab364186c675"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a81375366f1128711de01ab364186c675">&#9670;&nbsp;</a></span>setUniform1i() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void cugl::Shader::setUniform1i </td>
          <td>(</td>
          <td class="paramtype">GLint&#160;</td>
          <td class="paramname"><em>pos</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">GLint&#160;</td>
          <td class="paramname"><em>v0</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Sets the given uniform to a single int value.</p>
<p>This method will only succeed if the shader is actively bound.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pos</td><td>The location of the uniform in the shader </td></tr>
    <tr><td class="paramname">v0</td><td>The value for the uniform </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aff9e56614c2c5d501a71f78f1d112960"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aff9e56614c2c5d501a71f78f1d112960">&#9670;&nbsp;</a></span>setUniform1iv() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void cugl::Shader::setUniform1iv </td>
          <td>(</td>
          <td class="paramtype">const std::string&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">GLsizei&#160;</td>
          <td class="paramname"><em>count</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const GLint *&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Sets the given uniform to an array of 1-element ints.</p>
<p>This method will only succeed if the shader is actively bound. It will silently fail (with no error) if name is does not refer to a valid uniform.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">name</td><td>The name of the uniform </td></tr>
    <tr><td class="paramname">count</td><td>The number of elements in the array </td></tr>
    <tr><td class="paramname">value</td><td>The array of ints </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="acd1fc3f884e98a765f260ad602973ac7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acd1fc3f884e98a765f260ad602973ac7">&#9670;&nbsp;</a></span>setUniform1iv() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void cugl::Shader::setUniform1iv </td>
          <td>(</td>
          <td class="paramtype">GLint&#160;</td>
          <td class="paramname"><em>pos</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">GLsizei&#160;</td>
          <td class="paramname"><em>count</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const GLint *&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Sets the given uniform to an array of 1-element ints.</p>
<p>This method will only succeed if the shader is actively bound.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pos</td><td>The location of the uniform in the shader </td></tr>
    <tr><td class="paramname">count</td><td>The number of elements in the array </td></tr>
    <tr><td class="paramname">value</td><td>The array of ints </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="afc08c8dbe806caf7a0fae1e2d9d49127"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afc08c8dbe806caf7a0fae1e2d9d49127">&#9670;&nbsp;</a></span>setUniform1ui() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void cugl::Shader::setUniform1ui </td>
          <td>(</td>
          <td class="paramtype">const std::string&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">GLuint&#160;</td>
          <td class="paramname"><em>v0</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Sets the given uniform to a single unsigned value.</p>
<p>This method will only succeed if the shader is actively bound. It will silently fail (with no error) if name is does not refer to a valid uniform.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">name</td><td>The name of the uniform </td></tr>
    <tr><td class="paramname">v0</td><td>The value for the uniform </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a27a1a6b739c2e027cbce581ccadd4e88"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a27a1a6b739c2e027cbce581ccadd4e88">&#9670;&nbsp;</a></span>setUniform1ui() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void cugl::Shader::setUniform1ui </td>
          <td>(</td>
          <td class="paramtype">GLint&#160;</td>
          <td class="paramname"><em>pos</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">GLuint&#160;</td>
          <td class="paramname"><em>v0</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Sets the given uniform to a single unsigned value.</p>
<p>This method will only succeed if the shader is actively bound.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pos</td><td>The location of the uniform in the shader </td></tr>
    <tr><td class="paramname">v0</td><td>The value for the uniform </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aed35a57792a89f07ae7951af376ed08c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aed35a57792a89f07ae7951af376ed08c">&#9670;&nbsp;</a></span>setUniform1uiv() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void cugl::Shader::setUniform1uiv </td>
          <td>(</td>
          <td class="paramtype">const std::string&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">GLsizei&#160;</td>
          <td class="paramname"><em>count</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const GLuint *&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Sets the given uniform to an array of 1-element unsigned ints.</p>
<p>This method will only succeed if the shader is actively bound. It will silently fail (with no error) if name is does not refer to a valid uniform.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">name</td><td>The name of the uniform </td></tr>
    <tr><td class="paramname">count</td><td>The number of elements in the array </td></tr>
    <tr><td class="paramname">value</td><td>The array of unsigned ints </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ae0138c7905f98fdea5d4f3f3852385cf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae0138c7905f98fdea5d4f3f3852385cf">&#9670;&nbsp;</a></span>setUniform1uiv() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void cugl::Shader::setUniform1uiv </td>
          <td>(</td>
          <td class="paramtype">GLint&#160;</td>
          <td class="paramname"><em>pos</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">GLsizei&#160;</td>
          <td class="paramname"><em>count</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const GLuint *&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Sets the given uniform to an array of 1-element unsigned ints.</p>
<p>This method will only succeed if the shader is actively bound.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pos</td><td>The location of the uniform in the shader </td></tr>
    <tr><td class="paramname">count</td><td>The number of elements in the array </td></tr>
    <tr><td class="paramname">value</td><td>The array of unsigned ints </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ae45339cbc6cbdf5da76793928c45ad15"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae45339cbc6cbdf5da76793928c45ad15">&#9670;&nbsp;</a></span>setUniform2f() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void cugl::Shader::setUniform2f </td>
          <td>(</td>
          <td class="paramtype">const std::string&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">GLfloat&#160;</td>
          <td class="paramname"><em>v0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">GLfloat&#160;</td>
          <td class="paramname"><em>v1</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Sets the given uniform to a pair of float values.</p>
<p>This method will only succeed if the shader is actively bound. It will silently fail (with no error) if name is does not refer to a valid uniform.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">name</td><td>The name of the uniform </td></tr>
    <tr><td class="paramname">v0</td><td>The first value for the uniform </td></tr>
    <tr><td class="paramname">v1</td><td>The second value for the uniform </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a3feb1e8b24731c13d524181cdd2d265d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3feb1e8b24731c13d524181cdd2d265d">&#9670;&nbsp;</a></span>setUniform2f() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void cugl::Shader::setUniform2f </td>
          <td>(</td>
          <td class="paramtype">GLint&#160;</td>
          <td class="paramname"><em>pos</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">GLfloat&#160;</td>
          <td class="paramname"><em>v0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">GLfloat&#160;</td>
          <td class="paramname"><em>v1</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Sets the given uniform to a pair of float values.</p>
<p>This method will only succeed if the shader is actively bound.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pos</td><td>The location of the uniform in the shader </td></tr>
    <tr><td class="paramname">v0</td><td>The first value for the uniform </td></tr>
    <tr><td class="paramname">v1</td><td>The second value for the uniform </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ac4341fa43ababa675bd9e0ea7f8fac12"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac4341fa43ababa675bd9e0ea7f8fac12">&#9670;&nbsp;</a></span>setUniform2fv() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void cugl::Shader::setUniform2fv </td>
          <td>(</td>
          <td class="paramtype">const std::string&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">GLsizei&#160;</td>
          <td class="paramname"><em>count</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const GLfloat *&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Sets the given uniform to an array of 2-element floats.</p>
<p>This method will only succeed if the shader is actively bound. It will silently fail (with no error) if name is does not refer to a valid uniform.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">name</td><td>The name of the uniform </td></tr>
    <tr><td class="paramname">count</td><td>The number of elements in the array </td></tr>
    <tr><td class="paramname">value</td><td>The array of floats </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a9ea814749a0bc17f84e81091c8d35b1d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9ea814749a0bc17f84e81091c8d35b1d">&#9670;&nbsp;</a></span>setUniform2fv() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void cugl::Shader::setUniform2fv </td>
          <td>(</td>
          <td class="paramtype">GLint&#160;</td>
          <td class="paramname"><em>pos</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">GLsizei&#160;</td>
          <td class="paramname"><em>count</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const GLfloat *&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Sets the given uniform to an array of 2-element floats.</p>
<p>This method will only succeed if the shader is actively bound.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pos</td><td>The location of the uniform in the shader </td></tr>
    <tr><td class="paramname">count</td><td>The number of elements in the array </td></tr>
    <tr><td class="paramname">value</td><td>The array of floats </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a46e5d8e90bf0c860a4d31f8821525960"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a46e5d8e90bf0c860a4d31f8821525960">&#9670;&nbsp;</a></span>setUniform2i() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void cugl::Shader::setUniform2i </td>
          <td>(</td>
          <td class="paramtype">const std::string&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">GLint&#160;</td>
          <td class="paramname"><em>v0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">GLint&#160;</td>
          <td class="paramname"><em>v1</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Sets the given uniform to a pair of int values.</p>
<p>This method will only succeed if the shader is actively bound. It will silently fail (with no error) if name is does not refer to a valid uniform.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">name</td><td>The name of the uniform </td></tr>
    <tr><td class="paramname">v0</td><td>The first value for the uniform </td></tr>
    <tr><td class="paramname">v1</td><td>The second value for the uniform </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a9857968b2733469923123613a7867ddd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9857968b2733469923123613a7867ddd">&#9670;&nbsp;</a></span>setUniform2i() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void cugl::Shader::setUniform2i </td>
          <td>(</td>
          <td class="paramtype">GLint&#160;</td>
          <td class="paramname"><em>pos</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">GLint&#160;</td>
          <td class="paramname"><em>v0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">GLint&#160;</td>
          <td class="paramname"><em>v1</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Sets the given uniform to a pair of int values.</p>
<p>This method will only succeed if the shader is actively bound.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pos</td><td>The location of the uniform in the shader </td></tr>
    <tr><td class="paramname">v0</td><td>The first value for the uniform </td></tr>
    <tr><td class="paramname">v1</td><td>The second value for the uniform </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a621bc5442c0feb68737c26e20b90fc42"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a621bc5442c0feb68737c26e20b90fc42">&#9670;&nbsp;</a></span>setUniform2iv() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void cugl::Shader::setUniform2iv </td>
          <td>(</td>
          <td class="paramtype">const std::string&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">GLsizei&#160;</td>
          <td class="paramname"><em>count</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const GLint *&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Sets the given uniform to an array of 2-element ints.</p>
<p>This method will only succeed if the shader is actively bound. It will silently fail (with no error) if name is does not refer to a valid uniform.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">name</td><td>The name of the uniform </td></tr>
    <tr><td class="paramname">count</td><td>The number of elements in the array </td></tr>
    <tr><td class="paramname">value</td><td>The array of ints </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a51fcaf5b738fab8a75c6ae026061ea60"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a51fcaf5b738fab8a75c6ae026061ea60">&#9670;&nbsp;</a></span>setUniform2iv() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void cugl::Shader::setUniform2iv </td>
          <td>(</td>
          <td class="paramtype">GLint&#160;</td>
          <td class="paramname"><em>pos</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">GLsizei&#160;</td>
          <td class="paramname"><em>count</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const GLint *&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Sets the given uniform to an array of 2-element ints.</p>
<p>This method will only succeed if the shader is actively bound.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pos</td><td>The location of the uniform in the shader </td></tr>
    <tr><td class="paramname">count</td><td>The number of elements in the array </td></tr>
    <tr><td class="paramname">value</td><td>The array of ints </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ad55b7a0402bbc4b1ed226c200e9e839d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad55b7a0402bbc4b1ed226c200e9e839d">&#9670;&nbsp;</a></span>setUniform2ui() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void cugl::Shader::setUniform2ui </td>
          <td>(</td>
          <td class="paramtype">const std::string&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">GLuint&#160;</td>
          <td class="paramname"><em>v0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">GLuint&#160;</td>
          <td class="paramname"><em>v1</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Sets the given uniform to a pair of unsigned values.</p>
<p>This method will only succeed if the shader is actively bound. It will silently fail (with no error) if name is does not refer to a valid uniform.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">name</td><td>The name of the uniform </td></tr>
    <tr><td class="paramname">v0</td><td>The first value for the uniform </td></tr>
    <tr><td class="paramname">v1</td><td>The second value for the uniform </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ac5ec2d2f8ce35546f67ad01e3b84cd71"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac5ec2d2f8ce35546f67ad01e3b84cd71">&#9670;&nbsp;</a></span>setUniform2ui() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void cugl::Shader::setUniform2ui </td>
          <td>(</td>
          <td class="paramtype">GLint&#160;</td>
          <td class="paramname"><em>pos</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">GLuint&#160;</td>
          <td class="paramname"><em>v0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">GLuint&#160;</td>
          <td class="paramname"><em>v1</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Sets the given uniform to a pair of unsigned values.</p>
<p>This method will only succeed if the shader is actively bound.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pos</td><td>The location of the uniform in the shader </td></tr>
    <tr><td class="paramname">v0</td><td>The first value for the uniform </td></tr>
    <tr><td class="paramname">v1</td><td>The second value for the uniform </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a9d8ad1e822a41dff01d35f9d00f2f16d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9d8ad1e822a41dff01d35f9d00f2f16d">&#9670;&nbsp;</a></span>setUniform2uiv() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void cugl::Shader::setUniform2uiv </td>
          <td>(</td>
          <td class="paramtype">const std::string&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">GLsizei&#160;</td>
          <td class="paramname"><em>count</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const GLuint *&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Sets the given uniform to an array of 2-element unsigned ints.</p>
<p>This method will only succeed if the shader is actively bound. It will silently fail (with no error) if name is does not refer to a valid uniform.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">name</td><td>The name of the uniform </td></tr>
    <tr><td class="paramname">count</td><td>The number of elements in the array </td></tr>
    <tr><td class="paramname">value</td><td>The array of unsigned ints </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a7addcb5d41c2586c466d71cafddcf033"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7addcb5d41c2586c466d71cafddcf033">&#9670;&nbsp;</a></span>setUniform2uiv() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void cugl::Shader::setUniform2uiv </td>
          <td>(</td>
          <td class="paramtype">GLint&#160;</td>
          <td class="paramname"><em>pos</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">GLsizei&#160;</td>
          <td class="paramname"><em>count</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const GLuint *&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Sets the given uniform to an array of 2-element unsigned ints.</p>
<p>This method will only succeed if the shader is actively bound.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pos</td><td>The location of the uniform in the shader </td></tr>
    <tr><td class="paramname">count</td><td>The number of elements in the array </td></tr>
    <tr><td class="paramname">value</td><td>The array of unsigned ints </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a23bdb8e98357997c02ee87c1cca4a4b1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a23bdb8e98357997c02ee87c1cca4a4b1">&#9670;&nbsp;</a></span>setUniform3f() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void cugl::Shader::setUniform3f </td>
          <td>(</td>
          <td class="paramtype">const std::string&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">GLfloat&#160;</td>
          <td class="paramname"><em>v0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">GLfloat&#160;</td>
          <td class="paramname"><em>v1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">GLfloat&#160;</td>
          <td class="paramname"><em>v2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Sets the given uniform to a trio of float values.</p>
<p>This method will only succeed if the shader is actively bound. It will silently fail (with no error) if name is does not refer to a valid uniform.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">name</td><td>The name of the uniform </td></tr>
    <tr><td class="paramname">v0</td><td>The first value for the uniform </td></tr>
    <tr><td class="paramname">v1</td><td>The second value for the uniform </td></tr>
    <tr><td class="paramname">v2</td><td>The third value for the uniform </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a038edd04e4da980317c78eb27678fbb7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a038edd04e4da980317c78eb27678fbb7">&#9670;&nbsp;</a></span>setUniform3f() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void cugl::Shader::setUniform3f </td>
          <td>(</td>
          <td class="paramtype">GLint&#160;</td>
          <td class="paramname"><em>pos</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">GLfloat&#160;</td>
          <td class="paramname"><em>v0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">GLfloat&#160;</td>
          <td class="paramname"><em>v1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">GLfloat&#160;</td>
          <td class="paramname"><em>v2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Sets the given uniform to a trio of float values.</p>
<p>This method will only succeed if the shader is actively bound.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pos</td><td>The location of the uniform in the shader </td></tr>
    <tr><td class="paramname">v0</td><td>The first value for the uniform </td></tr>
    <tr><td class="paramname">v1</td><td>The second value for the uniform </td></tr>
    <tr><td class="paramname">v2</td><td>The third value for the uniform </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="af0c36937bd3f9fb5b61aa7c98d87b585"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af0c36937bd3f9fb5b61aa7c98d87b585">&#9670;&nbsp;</a></span>setUniform3fv() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void cugl::Shader::setUniform3fv </td>
          <td>(</td>
          <td class="paramtype">const std::string&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">GLsizei&#160;</td>
          <td class="paramname"><em>count</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const GLfloat *&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Sets the given uniform to an array of 3-element floats.</p>
<p>This method will only succeed if the shader is actively bound. It will silently fail (with no error) if name is does not refer to a valid uniform.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">name</td><td>The name of the uniform </td></tr>
    <tr><td class="paramname">count</td><td>The number of elements in the array </td></tr>
    <tr><td class="paramname">value</td><td>The array of floats </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="af4ab58718b2c190d9b7e8444d3a4a4db"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af4ab58718b2c190d9b7e8444d3a4a4db">&#9670;&nbsp;</a></span>setUniform3fv() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void cugl::Shader::setUniform3fv </td>
          <td>(</td>
          <td class="paramtype">GLint&#160;</td>
          <td class="paramname"><em>pos</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">GLsizei&#160;</td>
          <td class="paramname"><em>count</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const GLfloat *&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Sets the given uniform to an array of 3-element floats.</p>
<p>This method will only succeed if the shader is actively bound.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pos</td><td>The location of the uniform in the shader </td></tr>
    <tr><td class="paramname">count</td><td>The number of elements in the array </td></tr>
    <tr><td class="paramname">value</td><td>The array of floats </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ac510f31b95df89a218e32b9a81759dec"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac510f31b95df89a218e32b9a81759dec">&#9670;&nbsp;</a></span>setUniform3i() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void cugl::Shader::setUniform3i </td>
          <td>(</td>
          <td class="paramtype">const std::string&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">GLint&#160;</td>
          <td class="paramname"><em>v0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">GLint&#160;</td>
          <td class="paramname"><em>v1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">GLint&#160;</td>
          <td class="paramname"><em>v2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Sets the given uniform to a trio of int values.</p>
<p>This method will only succeed if the shader is actively bound. It will silently fail (with no error) if name is does not refer to a valid uniform.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">name</td><td>The name of the uniform </td></tr>
    <tr><td class="paramname">v0</td><td>The first value for the uniform </td></tr>
    <tr><td class="paramname">v1</td><td>The second value for the uniform </td></tr>
    <tr><td class="paramname">v2</td><td>The third value for the uniform </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aef45e318ceb14453544f5479c21c81ca"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aef45e318ceb14453544f5479c21c81ca">&#9670;&nbsp;</a></span>setUniform3i() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void cugl::Shader::setUniform3i </td>
          <td>(</td>
          <td class="paramtype">GLint&#160;</td>
          <td class="paramname"><em>pos</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">GLint&#160;</td>
          <td class="paramname"><em>v0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">GLint&#160;</td>
          <td class="paramname"><em>v1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">GLint&#160;</td>
          <td class="paramname"><em>v2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Sets the given uniform to a trio of int values.</p>
<p>This method will only succeed if the shader is actively bound.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pos</td><td>The location of the uniform in the shader </td></tr>
    <tr><td class="paramname">v0</td><td>The first value for the uniform </td></tr>
    <tr><td class="paramname">v1</td><td>The second value for the uniform </td></tr>
    <tr><td class="paramname">v2</td><td>The third value for the uniform </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a3db575e5765c01940daa1d6da8389c23"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3db575e5765c01940daa1d6da8389c23">&#9670;&nbsp;</a></span>setUniform3iv() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void cugl::Shader::setUniform3iv </td>
          <td>(</td>
          <td class="paramtype">const std::string&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">GLsizei&#160;</td>
          <td class="paramname"><em>count</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const GLint *&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Sets the given uniform to an array of 3-element ints.</p>
<p>This method will only succeed if the shader is actively bound. It will silently fail (with no error) if name is does not refer to a valid uniform.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">name</td><td>The name of the uniform </td></tr>
    <tr><td class="paramname">count</td><td>The number of elements in the array </td></tr>
    <tr><td class="paramname">value</td><td>The array of ints </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a98206e18d28bf8dc55b406371ffe021f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a98206e18d28bf8dc55b406371ffe021f">&#9670;&nbsp;</a></span>setUniform3iv() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void cugl::Shader::setUniform3iv </td>
          <td>(</td>
          <td class="paramtype">GLint&#160;</td>
          <td class="paramname"><em>pos</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">GLsizei&#160;</td>
          <td class="paramname"><em>count</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const GLint *&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Sets the given uniform to an array of 3-element ints.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pos</td><td>The location of the uniform in the shader </td></tr>
    <tr><td class="paramname">count</td><td>The number of elements in the array </td></tr>
    <tr><td class="paramname">value</td><td>The array of ints </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a53103e680fa8b11fd1bd8b506047f13b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a53103e680fa8b11fd1bd8b506047f13b">&#9670;&nbsp;</a></span>setUniform3ui() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void cugl::Shader::setUniform3ui </td>
          <td>(</td>
          <td class="paramtype">const std::string&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">GLuint&#160;</td>
          <td class="paramname"><em>v0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">GLuint&#160;</td>
          <td class="paramname"><em>v1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">GLuint&#160;</td>
          <td class="paramname"><em>v2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Sets the given uniform to a trio of unsigned values.</p>
<p>This method will only succeed if the shader is actively bound. It will silently fail (with no error) if name is does not refer to a valid uniform.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">name</td><td>The name of the uniform </td></tr>
    <tr><td class="paramname">v0</td><td>The first value for the uniform </td></tr>
    <tr><td class="paramname">v1</td><td>The second value for the uniform </td></tr>
    <tr><td class="paramname">v2</td><td>The third value for the uniform </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ac9318d0b82465f97ed53de69262bed48"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac9318d0b82465f97ed53de69262bed48">&#9670;&nbsp;</a></span>setUniform3ui() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void cugl::Shader::setUniform3ui </td>
          <td>(</td>
          <td class="paramtype">GLint&#160;</td>
          <td class="paramname"><em>pos</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">GLuint&#160;</td>
          <td class="paramname"><em>v0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">GLuint&#160;</td>
          <td class="paramname"><em>v1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">GLuint&#160;</td>
          <td class="paramname"><em>v2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Sets the given uniform to a trio of unsigned values.</p>
<p>This method will only succeed if the shader is actively bound.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pos</td><td>The location of the uniform in the shader </td></tr>
    <tr><td class="paramname">v0</td><td>The first value for the uniform </td></tr>
    <tr><td class="paramname">v1</td><td>The second value for the uniform </td></tr>
    <tr><td class="paramname">v2</td><td>The third value for the uniform </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a87bfc6728ff9cafd4362b702132e7ebf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a87bfc6728ff9cafd4362b702132e7ebf">&#9670;&nbsp;</a></span>setUniform3uiv() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void cugl::Shader::setUniform3uiv </td>
          <td>(</td>
          <td class="paramtype">const std::string&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">GLsizei&#160;</td>
          <td class="paramname"><em>count</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const GLuint *&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Sets the given uniform to an array of 3-element unsigned ints.</p>
<p>This method will only succeed if the shader is actively bound. It will silently fail (with no error) if name is does not refer to a valid uniform.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">name</td><td>The name of the uniform </td></tr>
    <tr><td class="paramname">count</td><td>The number of elements in the array </td></tr>
    <tr><td class="paramname">value</td><td>The array of unsigned ints </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a3dcded2d495e514be4590da942fa2b33"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3dcded2d495e514be4590da942fa2b33">&#9670;&nbsp;</a></span>setUniform3uiv() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void cugl::Shader::setUniform3uiv </td>
          <td>(</td>
          <td class="paramtype">GLint&#160;</td>
          <td class="paramname"><em>pos</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">GLsizei&#160;</td>
          <td class="paramname"><em>count</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const GLuint *&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Sets the given uniform to an array of 3-element unsigned ints.</p>
<p>This method will only succeed if the shader is actively bound.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pos</td><td>The location of the uniform in the shader </td></tr>
    <tr><td class="paramname">count</td><td>The number of elements in the array </td></tr>
    <tr><td class="paramname">value</td><td>The array of unsigned ints </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ad1bb4fab3f9dd3ab3bf5080fe5b1eccc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad1bb4fab3f9dd3ab3bf5080fe5b1eccc">&#9670;&nbsp;</a></span>setUniform4f() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void cugl::Shader::setUniform4f </td>
          <td>(</td>
          <td class="paramtype">const std::string&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">GLfloat&#160;</td>
          <td class="paramname"><em>v0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">GLfloat&#160;</td>
          <td class="paramname"><em>v1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">GLfloat&#160;</td>
          <td class="paramname"><em>v2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">GLfloat&#160;</td>
          <td class="paramname"><em>v3</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Sets the given uniform to a quartet of float values.</p>
<p>This method will only succeed if the shader is actively bound. It will silently fail (with no error) if name is does not refer to a valid uniform.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">name</td><td>The name of the uniform </td></tr>
    <tr><td class="paramname">v0</td><td>The first value for the uniform </td></tr>
    <tr><td class="paramname">v1</td><td>The second value for the uniform </td></tr>
    <tr><td class="paramname">v2</td><td>The third value for the uniform </td></tr>
    <tr><td class="paramname">v3</td><td>The fourth value for the uniform </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a6af8cfbcd795f3fb5478d35b2d0be52e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6af8cfbcd795f3fb5478d35b2d0be52e">&#9670;&nbsp;</a></span>setUniform4f() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void cugl::Shader::setUniform4f </td>
          <td>(</td>
          <td class="paramtype">GLint&#160;</td>
          <td class="paramname"><em>pos</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">GLfloat&#160;</td>
          <td class="paramname"><em>v0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">GLfloat&#160;</td>
          <td class="paramname"><em>v1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">GLfloat&#160;</td>
          <td class="paramname"><em>v2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">GLfloat&#160;</td>
          <td class="paramname"><em>v3</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Sets the given uniform to a quartet of float values.</p>
<p>This method will only succeed if the shader is actively bound.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pos</td><td>The location of the uniform in the shader </td></tr>
    <tr><td class="paramname">v0</td><td>The first value for the uniform </td></tr>
    <tr><td class="paramname">v1</td><td>The second value for the uniform </td></tr>
    <tr><td class="paramname">v2</td><td>The third value for the uniform </td></tr>
    <tr><td class="paramname">v3</td><td>The fourth value for the uniform </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a0e157d12a1dfdd7bf58860bf4c0dd780"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0e157d12a1dfdd7bf58860bf4c0dd780">&#9670;&nbsp;</a></span>setUniform4fv() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void cugl::Shader::setUniform4fv </td>
          <td>(</td>
          <td class="paramtype">const std::string&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">GLsizei&#160;</td>
          <td class="paramname"><em>count</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const GLfloat *&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Sets the given uniform to an array of 4-element floats.</p>
<p>This method will only succeed if the shader is actively bound. It will silently fail (with no error) if name is does not refer to a valid uniform.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">name</td><td>The name of the uniform </td></tr>
    <tr><td class="paramname">count</td><td>The number of elements in the array </td></tr>
    <tr><td class="paramname">value</td><td>The array of floats </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ac21de69a16467af4c07528ef614d1878"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac21de69a16467af4c07528ef614d1878">&#9670;&nbsp;</a></span>setUniform4fv() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void cugl::Shader::setUniform4fv </td>
          <td>(</td>
          <td class="paramtype">GLint&#160;</td>
          <td class="paramname"><em>pos</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">GLsizei&#160;</td>
          <td class="paramname"><em>count</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const GLfloat *&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Sets the given uniform to an array of 4-element floats.</p>
<p>This method will only succeed if the shader is actively bound.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pos</td><td>The location of the uniform in the shader </td></tr>
    <tr><td class="paramname">count</td><td>The number of elements in the array </td></tr>
    <tr><td class="paramname">value</td><td>The array of floats </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ac65cd7f7d4f9aac5d42f631bd95ede3d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac65cd7f7d4f9aac5d42f631bd95ede3d">&#9670;&nbsp;</a></span>setUniform4i() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void cugl::Shader::setUniform4i </td>
          <td>(</td>
          <td class="paramtype">const std::string&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">GLint&#160;</td>
          <td class="paramname"><em>v0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">GLint&#160;</td>
          <td class="paramname"><em>v1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">GLint&#160;</td>
          <td class="paramname"><em>v2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">GLint&#160;</td>
          <td class="paramname"><em>v3</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Sets the given uniform to a quartet of int values.</p>
<p>This method will only succeed if the shader is actively bound. It will silently fail (with no error) if name is does not refer to a valid uniform.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">name</td><td>The name of the uniform </td></tr>
    <tr><td class="paramname">v0</td><td>The first value for the uniform </td></tr>
    <tr><td class="paramname">v1</td><td>The second value for the uniform </td></tr>
    <tr><td class="paramname">v2</td><td>The third value for the uniform </td></tr>
    <tr><td class="paramname">v3</td><td>The fourth value for the uniform </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a06fec667614481149ef98841e197650e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a06fec667614481149ef98841e197650e">&#9670;&nbsp;</a></span>setUniform4i() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void cugl::Shader::setUniform4i </td>
          <td>(</td>
          <td class="paramtype">GLint&#160;</td>
          <td class="paramname"><em>pos</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">GLint&#160;</td>
          <td class="paramname"><em>v0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">GLint&#160;</td>
          <td class="paramname"><em>v1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">GLint&#160;</td>
          <td class="paramname"><em>v2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">GLint&#160;</td>
          <td class="paramname"><em>v3</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Sets the given uniform to a quartet of int values.</p>
<p>This method will only succeed if the shader is actively bound.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pos</td><td>The location of the uniform in the shader </td></tr>
    <tr><td class="paramname">v0</td><td>The first value for the uniform </td></tr>
    <tr><td class="paramname">v1</td><td>The second value for the uniform </td></tr>
    <tr><td class="paramname">v2</td><td>The third value for the uniform </td></tr>
    <tr><td class="paramname">v3</td><td>The fourth value for the uniform </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a1a2e30c4f3c3ce28aeb1b89b3346ae3d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1a2e30c4f3c3ce28aeb1b89b3346ae3d">&#9670;&nbsp;</a></span>setUniform4iv() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void cugl::Shader::setUniform4iv </td>
          <td>(</td>
          <td class="paramtype">const std::string&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">GLsizei&#160;</td>
          <td class="paramname"><em>count</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const GLint *&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Sets the given uniform to an array of 4-element ints.</p>
<p>This method will only succeed if the shader is actively bound. It will silently fail (with no error) if name is does not refer to a valid uniform.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">name</td><td>The name of the uniform </td></tr>
    <tr><td class="paramname">count</td><td>The number of elements in the array </td></tr>
    <tr><td class="paramname">value</td><td>The array of ints </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aecbfcf2e367ef4d05eb3c72fb10e6293"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aecbfcf2e367ef4d05eb3c72fb10e6293">&#9670;&nbsp;</a></span>setUniform4iv() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void cugl::Shader::setUniform4iv </td>
          <td>(</td>
          <td class="paramtype">GLint&#160;</td>
          <td class="paramname"><em>pos</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">GLsizei&#160;</td>
          <td class="paramname"><em>count</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const GLint *&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Sets the given uniform to an array of 4-element ints.</p>
<p>This method will only succeed if the shader is actively bound.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pos</td><td>The location of the uniform in the shader </td></tr>
    <tr><td class="paramname">count</td><td>The number of elements in the array </td></tr>
    <tr><td class="paramname">value</td><td>The array of ints </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a583130125d01fbad8b410150edcb4af0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a583130125d01fbad8b410150edcb4af0">&#9670;&nbsp;</a></span>setUniform4ui() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void cugl::Shader::setUniform4ui </td>
          <td>(</td>
          <td class="paramtype">const std::string&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">GLuint&#160;</td>
          <td class="paramname"><em>v0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">GLuint&#160;</td>
          <td class="paramname"><em>v1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">GLuint&#160;</td>
          <td class="paramname"><em>v2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">GLuint&#160;</td>
          <td class="paramname"><em>v3</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Sets the given uniform to a quartet of unsigned values.</p>
<p>This method will only succeed if the shader is actively bound. It will silently fail (with no error) if name is does not refer to a valid uniform.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">name</td><td>The name of the uniform </td></tr>
    <tr><td class="paramname">v0</td><td>The first value for the uniform </td></tr>
    <tr><td class="paramname">v1</td><td>The second value for the uniform </td></tr>
    <tr><td class="paramname">v2</td><td>The third value for the uniform </td></tr>
    <tr><td class="paramname">v3</td><td>The fourth value for the uniform </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ac08366f232511e78b3a00ec464ee563c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac08366f232511e78b3a00ec464ee563c">&#9670;&nbsp;</a></span>setUniform4ui() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void cugl::Shader::setUniform4ui </td>
          <td>(</td>
          <td class="paramtype">GLint&#160;</td>
          <td class="paramname"><em>pos</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">GLuint&#160;</td>
          <td class="paramname"><em>v0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">GLuint&#160;</td>
          <td class="paramname"><em>v1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">GLuint&#160;</td>
          <td class="paramname"><em>v2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">GLuint&#160;</td>
          <td class="paramname"><em>v3</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Sets the given uniform to a quartet of unsigned values.</p>
<p>This method will only succeed if the shader is actively bound.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pos</td><td>The location of the uniform in the shader </td></tr>
    <tr><td class="paramname">v0</td><td>The first value for the uniform </td></tr>
    <tr><td class="paramname">v1</td><td>The second value for the uniform </td></tr>
    <tr><td class="paramname">v2</td><td>The third value for the uniform </td></tr>
    <tr><td class="paramname">v3</td><td>The fourth value for the uniform </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a58d3f800d2b9caabb894b559eda02c59"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a58d3f800d2b9caabb894b559eda02c59">&#9670;&nbsp;</a></span>setUniform4uiv() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void cugl::Shader::setUniform4uiv </td>
          <td>(</td>
          <td class="paramtype">const std::string&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">GLsizei&#160;</td>
          <td class="paramname"><em>count</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const GLuint *&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Sets the given uniform to an array of 4-element unsigned ints.</p>
<p>This method will only succeed if the shader is actively bound. It will silently fail (with no error) if name is does not refer to a valid uniform.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">name</td><td>The name of the uniform </td></tr>
    <tr><td class="paramname">count</td><td>The number of elements in the array </td></tr>
    <tr><td class="paramname">value</td><td>The array of unsigned ints </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a95ce1f0fcc1fc85ce69d7e7a0f949698"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a95ce1f0fcc1fc85ce69d7e7a0f949698">&#9670;&nbsp;</a></span>setUniform4uiv() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void cugl::Shader::setUniform4uiv </td>
          <td>(</td>
          <td class="paramtype">GLint&#160;</td>
          <td class="paramname"><em>pos</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">GLsizei&#160;</td>
          <td class="paramname"><em>count</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const GLuint *&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Sets the given uniform to an array of 4-element unsigned ints.</p>
<p>This method will only succeed if the shader is actively bound.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pos</td><td>The location of the uniform in the shader </td></tr>
    <tr><td class="paramname">count</td><td>The number of elements in the array </td></tr>
    <tr><td class="paramname">value</td><td>The array of unsigned ints </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a9a8bc34910dc84faeee53decf09cd3c2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9a8bc34910dc84faeee53decf09cd3c2">&#9670;&nbsp;</a></span>setUniformAffine2() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void cugl::Shader::setUniformAffine2 </td>
          <td>(</td>
          <td class="paramtype">const std::string&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classcugl_1_1_affine2.html">Affine2</a> &amp;&#160;</td>
          <td class="paramname"><em>mat</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Sets the given uniform to an affine transform.</p>
<p>Affine transforms are passed to a shader as a 3x3 matrix on homogenous coordinates.</p>
<p>This method will only succeed if the shader is actively bound.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">name</td><td>The name of the uniform </td></tr>
    <tr><td class="paramname">mat</td><td>The value for the uniform </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a712ce1ba4eb7b7af7ea453a48dba6468"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a712ce1ba4eb7b7af7ea453a48dba6468">&#9670;&nbsp;</a></span>setUniformAffine2() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void cugl::Shader::setUniformAffine2 </td>
          <td>(</td>
          <td class="paramtype">GLint&#160;</td>
          <td class="paramname"><em>pos</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classcugl_1_1_affine2.html">Affine2</a> &amp;&#160;</td>
          <td class="paramname"><em>mat</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Sets the given uniform to an affine transform.</p>
<p>Affine transforms are passed to a shader as a 3x3 matrix on homogenous coordinates.</p>
<p>This method will only succeed if the shader is actively bound.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pos</td><td>The location of the uniform in the shader </td></tr>
    <tr><td class="paramname">mat</td><td>The value for the uniform </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="abc8c16e5e660161368819dbd5e10f0ac"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abc8c16e5e660161368819dbd5e10f0ac">&#9670;&nbsp;</a></span>setUniformBlock() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void cugl::Shader::setUniformBlock </td>
          <td>(</td>
          <td class="paramtype">const std::string&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::shared_ptr&lt; <a class="el" href="classcugl_1_1_uniform_buffer.html">UniformBuffer</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>buffer</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Sets the given uniform block variable to the bindpoint of the given uniform buffer.</p>
<p>A uniform block is a variable attached to a uniform buffer. It is not the same as a normal uniform and cannot be treated as such. In this case the uniform values are set in the <a class="el" href="classcugl_1_1_uniform_buffer.html">UniformBuffer</a> object and not the shader.</p>
<p>This method will bind the uniform buffer to the current bindpoint of the block object. The shader will not be aware if the buffer object changes its bindpoint in the future. However, it will verify whether the buffer object has uniform variables matching this shader.</p>
<p>This method will only succeed if the shader is actively bound.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">name</td><td>The name of the uniform block in the shader </td></tr>
    <tr><td class="paramname">buffer</td><td>The buffer to bind to this uniform block </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ab40d65cd58488becc46b5e81e596f659"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab40d65cd58488becc46b5e81e596f659">&#9670;&nbsp;</a></span>setUniformBlock() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void cugl::Shader::setUniformBlock </td>
          <td>(</td>
          <td class="paramtype">const std::string&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">GLuint&#160;</td>
          <td class="paramname"><em>bpoint</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Sets the given uniform block variable to a uniform buffer bindpoint.</p>
<p>A uniform block is a variable attached to a uniform buffer. It is not the same as a normal uniform and cannot be treated as such. In this case the uniform values are set in the <a class="el" href="classcugl_1_1_uniform_buffer.html">UniformBuffer</a> object and not the shader.</p>
<p>This method will only succeed if the shader is actively bound.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">name</td><td>The name of the uniform block in the shader </td></tr>
    <tr><td class="paramname">bpoint</td><td>The bindpoint for the uniform block </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a2825dd85e0ca79643c86d4fa09bfa150"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2825dd85e0ca79643c86d4fa09bfa150">&#9670;&nbsp;</a></span>setUniformBlock() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void cugl::Shader::setUniformBlock </td>
          <td>(</td>
          <td class="paramtype">GLint&#160;</td>
          <td class="paramname"><em>pos</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::shared_ptr&lt; <a class="el" href="classcugl_1_1_uniform_buffer.html">UniformBuffer</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>buffer</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Sets the given uniform block variable to the bindpoint of the given uniform buffer.</p>
<p>A uniform block is a variable attached to a uniform buffer. It is not the same as a normal uniform and cannot be treated as such. In this case the uniform values are set in the <a class="el" href="classcugl_1_1_uniform_buffer.html">UniformBuffer</a> object and not the shader.</p>
<p>This method will bind the uniform buffer to the current bindpoint of the block object. The shader will not be aware if the buffer object changes its bindpoint in the future. However, it will verify whether the buffer object has uniform variables matching this shader.</p>
<p>This method will only succeed if the shader is actively bound.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pos</td><td>The location of the uniform block in the shader </td></tr>
    <tr><td class="paramname">buffer</td><td>The buffer to bind to this uniform block </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a5958ebed6e243170e26300553308a618"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5958ebed6e243170e26300553308a618">&#9670;&nbsp;</a></span>setUniformBlock() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void cugl::Shader::setUniformBlock </td>
          <td>(</td>
          <td class="paramtype">GLint&#160;</td>
          <td class="paramname"><em>pos</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">GLuint&#160;</td>
          <td class="paramname"><em>bpoint</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Sets the given uniform block variable to a uniform buffer bindpoint.</p>
<p>A uniform block is a variable attached to a uniform buffer. It is not the same as a normal uniform and cannot be treated as such. In this case the uniform values are set in the <a class="el" href="classcugl_1_1_uniform_buffer.html">UniformBuffer</a> object and not the shader.</p>
<p>This method will only succeed if the shader is actively bound.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pos</td><td>The location of the uniform block in the shader </td></tr>
    <tr><td class="paramname">bpoint</td><td>The bindpoint for the uniform block </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a5a387193ddd447e72f35ec0f4f627687"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5a387193ddd447e72f35ec0f4f627687">&#9670;&nbsp;</a></span>setUniformColor4() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void cugl::Shader::setUniformColor4 </td>
          <td>(</td>
          <td class="paramtype">const std::string&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classcugl_1_1_color4.html">Color4</a>&#160;</td>
          <td class="paramname"><em>color</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Sets the given uniform to a color value.</p>
<p>This method will only succeed if the shader is actively bound.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">name</td><td>The name of the uniform </td></tr>
    <tr><td class="paramname">color</td><td>The value for the uniform </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a2846b6e58f6303122913cb33a85e990e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2846b6e58f6303122913cb33a85e990e">&#9670;&nbsp;</a></span>setUniformColor4() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void cugl::Shader::setUniformColor4 </td>
          <td>(</td>
          <td class="paramtype">GLint&#160;</td>
          <td class="paramname"><em>pos</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classcugl_1_1_color4.html">Color4</a>&#160;</td>
          <td class="paramname"><em>color</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Sets the given uniform to a color value.</p>
<p>This method will only succeed if the shader is actively bound.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pos</td><td>The location of the uniform in the shader </td></tr>
    <tr><td class="paramname">color</td><td>The value for the uniform </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ab75f1475be381140560d53316baefac0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab75f1475be381140560d53316baefac0">&#9670;&nbsp;</a></span>setUniformColor4f() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void cugl::Shader::setUniformColor4f </td>
          <td>(</td>
          <td class="paramtype">const std::string&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classcugl_1_1_color4f.html">Color4f</a>&#160;</td>
          <td class="paramname"><em>color</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Sets the given uniform to a color value.</p>
<p>This method will only succeed if the shader is actively bound.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">name</td><td>The name of the uniform </td></tr>
    <tr><td class="paramname">color</td><td>The value for the uniform </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="afb6753ffe4126b75b29be4227bd44f2c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afb6753ffe4126b75b29be4227bd44f2c">&#9670;&nbsp;</a></span>setUniformColor4f() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void cugl::Shader::setUniformColor4f </td>
          <td>(</td>
          <td class="paramtype">GLint&#160;</td>
          <td class="paramname"><em>pos</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classcugl_1_1_color4f.html">Color4f</a>&#160;</td>
          <td class="paramname"><em>color</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Sets the given uniform to a color value.</p>
<p>This method will only succeed if the shader is actively bound.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pos</td><td>The location of the uniform in the shader </td></tr>
    <tr><td class="paramname">color</td><td>The value for the uniform </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ae4052ee41ef043094d2f19a5baa7aed6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae4052ee41ef043094d2f19a5baa7aed6">&#9670;&nbsp;</a></span>setUniformMat4() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void cugl::Shader::setUniformMat4 </td>
          <td>(</td>
          <td class="paramtype">const std::string&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classcugl_1_1_mat4.html">Mat4</a> &amp;&#160;</td>
          <td class="paramname"><em>mat</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Sets the given uniform to a matrix value</p>
<p>This method will only succeed if the shader is actively bound. It will silently fail (with no error) if name is does not refer to a valid uniform.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">name</td><td>The name of the uniform </td></tr>
    <tr><td class="paramname">mat</td><td>The value for the uniform </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aa0e115a0fb120ec337c55c1088b9a92f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa0e115a0fb120ec337c55c1088b9a92f">&#9670;&nbsp;</a></span>setUniformMat4() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void cugl::Shader::setUniformMat4 </td>
          <td>(</td>
          <td class="paramtype">GLint&#160;</td>
          <td class="paramname"><em>pos</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classcugl_1_1_mat4.html">Mat4</a> &amp;&#160;</td>
          <td class="paramname"><em>mat</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Sets the given uniform to a matrix value.</p>
<p>This method will only succeed if the shader is actively bound.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pos</td><td>The location of the uniform in the shader </td></tr>
    <tr><td class="paramname">mat</td><td>The value for the uniform </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a3b057ce153ad522f0610034378f3171a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3b057ce153ad522f0610034378f3171a">&#9670;&nbsp;</a></span>setUniformMatrix2fv() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void cugl::Shader::setUniformMatrix2fv </td>
          <td>(</td>
          <td class="paramtype">const std::string&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">GLsizei&#160;</td>
          <td class="paramname"><em>count</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const GLfloat *&#160;</td>
          <td class="paramname"><em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">GLboolean&#160;</td>
          <td class="paramname"><em>tpose</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Sets the given uniform to an array 2x2 matrices.</p>
<p>This method will only succeed if the shader is actively bound. It will silently fail (with no error) if name is does not refer to a valid uniform.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">name</td><td>The name of the uniform </td></tr>
    <tr><td class="paramname">count</td><td>The number of elements in the array </td></tr>
    <tr><td class="paramname">value</td><td>The array of matrices </td></tr>
    <tr><td class="paramname">tpose</td><td>Whether to transpose the matrices </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ad40a39377396f24498170f396eea00a0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad40a39377396f24498170f396eea00a0">&#9670;&nbsp;</a></span>setUniformMatrix2fv() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void cugl::Shader::setUniformMatrix2fv </td>
          <td>(</td>
          <td class="paramtype">GLint&#160;</td>
          <td class="paramname"><em>pos</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">GLsizei&#160;</td>
          <td class="paramname"><em>count</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const GLfloat *&#160;</td>
          <td class="paramname"><em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">GLboolean&#160;</td>
          <td class="paramname"><em>tpose</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Sets the given uniform to an array 2x2 matrices.</p>
<p>This method will only succeed if the shader is actively bound.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pos</td><td>The location of the uniform in the shader </td></tr>
    <tr><td class="paramname">count</td><td>The number of elements in the array </td></tr>
    <tr><td class="paramname">value</td><td>The array of matrices </td></tr>
    <tr><td class="paramname">tpose</td><td>Whether to transpose the matrices </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a1170ad0e0e0886f625a27b369ed7e970"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1170ad0e0e0886f625a27b369ed7e970">&#9670;&nbsp;</a></span>setUniformMatrix2x3fv() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void cugl::Shader::setUniformMatrix2x3fv </td>
          <td>(</td>
          <td class="paramtype">const std::string&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">GLsizei&#160;</td>
          <td class="paramname"><em>count</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const GLfloat *&#160;</td>
          <td class="paramname"><em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">GLboolean&#160;</td>
          <td class="paramname"><em>tpose</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Sets the given uniform to an array 2x3 matrices.</p>
<p>This method will only succeed if the shader is actively bound. It will silently fail (with no error) if name is does not refer to a valid uniform.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">name</td><td>The name of the uniform </td></tr>
    <tr><td class="paramname">count</td><td>The number of elements in the array </td></tr>
    <tr><td class="paramname">value</td><td>The array of matrices </td></tr>
    <tr><td class="paramname">tpose</td><td>Whether to transpose the matrices </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ad766876ba9040fc22c79e43def531716"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad766876ba9040fc22c79e43def531716">&#9670;&nbsp;</a></span>setUniformMatrix2x3fv() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void cugl::Shader::setUniformMatrix2x3fv </td>
          <td>(</td>
          <td class="paramtype">GLint&#160;</td>
          <td class="paramname"><em>pos</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">GLsizei&#160;</td>
          <td class="paramname"><em>count</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const GLfloat *&#160;</td>
          <td class="paramname"><em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">GLboolean&#160;</td>
          <td class="paramname"><em>tpose</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Sets the given uniform to an array 2x3 matrices.</p>
<p>This method will only succeed if the shader is actively bound.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pos</td><td>The location of the uniform in the shader </td></tr>
    <tr><td class="paramname">count</td><td>The number of elements in the array </td></tr>
    <tr><td class="paramname">value</td><td>The array of matrices </td></tr>
    <tr><td class="paramname">tpose</td><td>Whether to transpose the matrices </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="addd607e514bd044928fb1a0ffcf889b3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#addd607e514bd044928fb1a0ffcf889b3">&#9670;&nbsp;</a></span>setUniformMatrix2x4fv() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void cugl::Shader::setUniformMatrix2x4fv </td>
          <td>(</td>
          <td class="paramtype">const std::string&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">GLsizei&#160;</td>
          <td class="paramname"><em>count</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const GLfloat *&#160;</td>
          <td class="paramname"><em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">GLboolean&#160;</td>
          <td class="paramname"><em>tpose</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Sets the given uniform to an array 2x4 matrices.</p>
<p>This method will only succeed if the shader is actively bound. It will silently fail (with no error) if name is does not refer to a valid uniform.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">name</td><td>The name of the uniform </td></tr>
    <tr><td class="paramname">count</td><td>The number of elements in the array </td></tr>
    <tr><td class="paramname">value</td><td>The array of matrices </td></tr>
    <tr><td class="paramname">tpose</td><td>Whether to transpose the matrices </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a5035da73ec381eaa0ad9c0ef31a5f1bc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5035da73ec381eaa0ad9c0ef31a5f1bc">&#9670;&nbsp;</a></span>setUniformMatrix2x4fv() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void cugl::Shader::setUniformMatrix2x4fv </td>
          <td>(</td>
          <td class="paramtype">GLint&#160;</td>
          <td class="paramname"><em>pos</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">GLsizei&#160;</td>
          <td class="paramname"><em>count</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const GLfloat *&#160;</td>
          <td class="paramname"><em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">GLboolean&#160;</td>
          <td class="paramname"><em>tpose</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Sets the given uniform to an array 2x4 matrices.</p>
<p>This method will only succeed if the shader is actively bound.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pos</td><td>The location of the uniform in the shader </td></tr>
    <tr><td class="paramname">count</td><td>The number of elements in the array </td></tr>
    <tr><td class="paramname">value</td><td>The array of matrices </td></tr>
    <tr><td class="paramname">tpose</td><td>Whether to transpose the matrices </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a37c23ddbbc9f18f3ed3688cbfeefa492"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a37c23ddbbc9f18f3ed3688cbfeefa492">&#9670;&nbsp;</a></span>setUniformMatrix3fv() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void cugl::Shader::setUniformMatrix3fv </td>
          <td>(</td>
          <td class="paramtype">const std::string&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">GLsizei&#160;</td>
          <td class="paramname"><em>count</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const GLfloat *&#160;</td>
          <td class="paramname"><em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">GLboolean&#160;</td>
          <td class="paramname"><em>tpose</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Sets the given uniform to an array 3x3 matrices.</p>
<p>This method will only succeed if the shader is actively bound. It will silently fail (with no error) if name is does not refer to a valid uniform.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">name</td><td>The name of the uniform </td></tr>
    <tr><td class="paramname">count</td><td>The number of elements in the array </td></tr>
    <tr><td class="paramname">value</td><td>The array of matrices </td></tr>
    <tr><td class="paramname">tpose</td><td>Whether to transpose the matrices </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a0096f077f122a12cf97140f1e543b86e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0096f077f122a12cf97140f1e543b86e">&#9670;&nbsp;</a></span>setUniformMatrix3fv() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void cugl::Shader::setUniformMatrix3fv </td>
          <td>(</td>
          <td class="paramtype">GLint&#160;</td>
          <td class="paramname"><em>pos</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">GLsizei&#160;</td>
          <td class="paramname"><em>count</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const GLfloat *&#160;</td>
          <td class="paramname"><em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">GLboolean&#160;</td>
          <td class="paramname"><em>tpose</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Sets the given uniform to an array 3x3 matrices.</p>
<p>This method will only succeed if the shader is actively bound.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pos</td><td>The location of the uniform in the shader </td></tr>
    <tr><td class="paramname">count</td><td>The number of elements in the array </td></tr>
    <tr><td class="paramname">value</td><td>The array of matrices </td></tr>
    <tr><td class="paramname">tpose</td><td>Whether to transpose the matrices </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="abed1cd44327cf09515fe5779b4674f94"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abed1cd44327cf09515fe5779b4674f94">&#9670;&nbsp;</a></span>setUniformMatrix3x2fv() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void cugl::Shader::setUniformMatrix3x2fv </td>
          <td>(</td>
          <td class="paramtype">const std::string&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">GLsizei&#160;</td>
          <td class="paramname"><em>count</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const GLfloat *&#160;</td>
          <td class="paramname"><em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">GLboolean&#160;</td>
          <td class="paramname"><em>tpose</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Sets the given uniform to an array 3x2 matrices.</p>
<p>This method will only succeed if the shader is actively bound. It will silently fail (with no error) if name is does not refer to a valid uniform.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">name</td><td>The name of the uniform </td></tr>
    <tr><td class="paramname">count</td><td>The number of elements in the array </td></tr>
    <tr><td class="paramname">value</td><td>The array of matrices </td></tr>
    <tr><td class="paramname">tpose</td><td>Whether to transpose the matrices </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a3127476da9e4a0309dc08be48e28aa5f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3127476da9e4a0309dc08be48e28aa5f">&#9670;&nbsp;</a></span>setUniformMatrix3x2fv() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void cugl::Shader::setUniformMatrix3x2fv </td>
          <td>(</td>
          <td class="paramtype">GLint&#160;</td>
          <td class="paramname"><em>pos</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">GLsizei&#160;</td>
          <td class="paramname"><em>count</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const GLfloat *&#160;</td>
          <td class="paramname"><em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">GLboolean&#160;</td>
          <td class="paramname"><em>tpose</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Sets the given uniform to an array 3x2 matrices.</p>
<p>This method will only succeed if the shader is actively bound.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pos</td><td>The location of the uniform in the shader </td></tr>
    <tr><td class="paramname">count</td><td>The number of elements in the array </td></tr>
    <tr><td class="paramname">value</td><td>The array of matrices </td></tr>
    <tr><td class="paramname">tpose</td><td>Whether to transpose the matrices </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a77e0f30f82295ac6a54b87516d1cccc7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a77e0f30f82295ac6a54b87516d1cccc7">&#9670;&nbsp;</a></span>setUniformMatrix3x4fv() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void cugl::Shader::setUniformMatrix3x4fv </td>
          <td>(</td>
          <td class="paramtype">const std::string&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">GLsizei&#160;</td>
          <td class="paramname"><em>count</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const GLfloat *&#160;</td>
          <td class="paramname"><em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">GLboolean&#160;</td>
          <td class="paramname"><em>tpose</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Sets the given uniform to an array 3x4 matrices.</p>
<p>This method will only succeed if the shader is actively bound. It will silently fail (with no error) if name is does not refer to a valid uniform.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">name</td><td>The name of the uniform </td></tr>
    <tr><td class="paramname">count</td><td>The number of elements in the array </td></tr>
    <tr><td class="paramname">value</td><td>The array of matrices </td></tr>
    <tr><td class="paramname">tpose</td><td>Whether to transpose the matrices </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ad1de16a2ad8f48d94b8c6e8da842a5db"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad1de16a2ad8f48d94b8c6e8da842a5db">&#9670;&nbsp;</a></span>setUniformMatrix3x4fv() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void cugl::Shader::setUniformMatrix3x4fv </td>
          <td>(</td>
          <td class="paramtype">GLint&#160;</td>
          <td class="paramname"><em>pos</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">GLsizei&#160;</td>
          <td class="paramname"><em>count</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const GLfloat *&#160;</td>
          <td class="paramname"><em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">GLboolean&#160;</td>
          <td class="paramname"><em>tpose</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Sets the given uniform to an array 3x4 matrices.</p>
<p>This method will only succeed if the shader is actively bound.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pos</td><td>The location of the uniform in the shader </td></tr>
    <tr><td class="paramname">count</td><td>The number of elements in the array </td></tr>
    <tr><td class="paramname">value</td><td>The array of matrices </td></tr>
    <tr><td class="paramname">tpose</td><td>Whether to transpose the matrices </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aa7ad8dae86bfc96bf48d8b036a906b3d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa7ad8dae86bfc96bf48d8b036a906b3d">&#9670;&nbsp;</a></span>setUniformMatrix4fv() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void cugl::Shader::setUniformMatrix4fv </td>
          <td>(</td>
          <td class="paramtype">const std::string&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">GLsizei&#160;</td>
          <td class="paramname"><em>count</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const GLfloat *&#160;</td>
          <td class="paramname"><em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">GLboolean&#160;</td>
          <td class="paramname"><em>tpose</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Sets the given uniform to an array 4x4 matrices.</p>
<p>This method will only succeed if the shader is actively bound. It will silently fail (with no error) if name is does not refer to a valid uniform.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">name</td><td>The name of the uniform </td></tr>
    <tr><td class="paramname">count</td><td>The number of elements in the array </td></tr>
    <tr><td class="paramname">value</td><td>The array of matrices </td></tr>
    <tr><td class="paramname">tpose</td><td>Whether to transpose the matrices </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a93fc729b28103f9ae51bab3f6ffeb914"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a93fc729b28103f9ae51bab3f6ffeb914">&#9670;&nbsp;</a></span>setUniformMatrix4fv() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void cugl::Shader::setUniformMatrix4fv </td>
          <td>(</td>
          <td class="paramtype">GLint&#160;</td>
          <td class="paramname"><em>pos</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">GLsizei&#160;</td>
          <td class="paramname"><em>count</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const GLfloat *&#160;</td>
          <td class="paramname"><em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">GLboolean&#160;</td>
          <td class="paramname"><em>tpose</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Sets the given uniform to an array 4x4 matrices.</p>
<p>This method will only succeed if the shader is actively bound.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pos</td><td>The location of the uniform in the shader </td></tr>
    <tr><td class="paramname">count</td><td>The number of elements in the array </td></tr>
    <tr><td class="paramname">value</td><td>The array of matrices </td></tr>
    <tr><td class="paramname">tpose</td><td>Whether to transpose the matrices </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a4db71d444041b822c307a0db034a982b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4db71d444041b822c307a0db034a982b">&#9670;&nbsp;</a></span>setUniformMatrix4x2fv() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void cugl::Shader::setUniformMatrix4x2fv </td>
          <td>(</td>
          <td class="paramtype">const std::string&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">GLsizei&#160;</td>
          <td class="paramname"><em>count</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const GLfloat *&#160;</td>
          <td class="paramname"><em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">GLboolean&#160;</td>
          <td class="paramname"><em>tpose</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Sets the given uniform to an array 4x2 matrices.</p>
<p>This method will only succeed if the shader is actively bound. It will silently fail (with no error) if name is does not refer to a valid uniform.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">name</td><td>The name of the uniform </td></tr>
    <tr><td class="paramname">count</td><td>The number of elements in the array </td></tr>
    <tr><td class="paramname">value</td><td>The array of matrices </td></tr>
    <tr><td class="paramname">tpose</td><td>Whether to transpose the matrices </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a13ec51abc1bfaa5d06a65e03499d9725"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a13ec51abc1bfaa5d06a65e03499d9725">&#9670;&nbsp;</a></span>setUniformMatrix4x2fv() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void cugl::Shader::setUniformMatrix4x2fv </td>
          <td>(</td>
          <td class="paramtype">GLint&#160;</td>
          <td class="paramname"><em>pos</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">GLsizei&#160;</td>
          <td class="paramname"><em>count</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const GLfloat *&#160;</td>
          <td class="paramname"><em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">GLboolean&#160;</td>
          <td class="paramname"><em>tpose</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Sets the given uniform to an array 4x2 matrices.</p>
<p>This method will only succeed if the shader is actively bound.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pos</td><td>The location of the uniform in the shader </td></tr>
    <tr><td class="paramname">count</td><td>The number of elements in the array </td></tr>
    <tr><td class="paramname">value</td><td>The array of matrices </td></tr>
    <tr><td class="paramname">tpose</td><td>Whether to transpose the matrices </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a0f4303f35f4550fa1eab703906338719"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0f4303f35f4550fa1eab703906338719">&#9670;&nbsp;</a></span>setUniformMatrix4x3fv() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void cugl::Shader::setUniformMatrix4x3fv </td>
          <td>(</td>
          <td class="paramtype">const std::string&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">GLsizei&#160;</td>
          <td class="paramname"><em>count</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const GLfloat *&#160;</td>
          <td class="paramname"><em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">GLboolean&#160;</td>
          <td class="paramname"><em>tpose</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Sets the given uniform to an array 4x3 matrices.</p>
<p>This method will only succeed if the shader is actively bound. It will silently fail (with no error) if name is does not refer to a valid uniform.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">name</td><td>The name of the uniform </td></tr>
    <tr><td class="paramname">count</td><td>The number of elements in the array </td></tr>
    <tr><td class="paramname">value</td><td>The array of matrices </td></tr>
    <tr><td class="paramname">tpose</td><td>Whether to transpose the matrices </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a4082351141fefc9cdab2a80f449f63b2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4082351141fefc9cdab2a80f449f63b2">&#9670;&nbsp;</a></span>setUniformMatrix4x3fv() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void cugl::Shader::setUniformMatrix4x3fv </td>
          <td>(</td>
          <td class="paramtype">GLint&#160;</td>
          <td class="paramname"><em>pos</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">GLsizei&#160;</td>
          <td class="paramname"><em>count</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const GLfloat *&#160;</td>
          <td class="paramname"><em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">GLboolean&#160;</td>
          <td class="paramname"><em>tpose</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Sets the given uniform to an array 4x3 matrices.</p>
<p>This method will only succeed if the shader is actively bound.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pos</td><td>The location of the uniform in the shader </td></tr>
    <tr><td class="paramname">count</td><td>The number of elements in the array </td></tr>
    <tr><td class="paramname">value</td><td>The array of matrices </td></tr>
    <tr><td class="paramname">tpose</td><td>Whether to transpose the matrices </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a9768849854da5f6e202828689c321930"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9768849854da5f6e202828689c321930">&#9670;&nbsp;</a></span>setUniformQuaternion() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void cugl::Shader::setUniformQuaternion </td>
          <td>(</td>
          <td class="paramtype">const std::string&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classcugl_1_1_quaternion.html">Quaternion</a> &amp;&#160;</td>
          <td class="paramname"><em>quat</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Sets the given uniform to a quaternion.</p>
<p>This method will only succeed if the shader is actively bound.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">name</td><td>The name of the uniform </td></tr>
    <tr><td class="paramname">quat</td><td>The value for the uniform </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="abee706109d45f6c4cf52701335581fa5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abee706109d45f6c4cf52701335581fa5">&#9670;&nbsp;</a></span>setUniformQuaternion() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void cugl::Shader::setUniformQuaternion </td>
          <td>(</td>
          <td class="paramtype">GLint&#160;</td>
          <td class="paramname"><em>pos</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classcugl_1_1_quaternion.html">Quaternion</a> &amp;&#160;</td>
          <td class="paramname"><em>quat</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Sets the given uniform to a quaternion.</p>
<p>This method will only succeed if the shader is actively bound.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pos</td><td>The location of the uniform in the shader </td></tr>
    <tr><td class="paramname">quat</td><td>The value for the uniform </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a6fb65fb32f9e3189f893b6beee40ff7b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6fb65fb32f9e3189f893b6beee40ff7b">&#9670;&nbsp;</a></span>setUniformVec2() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void cugl::Shader::setUniformVec2 </td>
          <td>(</td>
          <td class="paramtype">const std::string&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classcugl_1_1_vec2.html">Vec2</a>&#160;</td>
          <td class="paramname"><em>vec</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Sets the given uniform to a vector value.</p>
<p>This method will only succeed if the shader is actively bound.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">name</td><td>The name of the uniform </td></tr>
    <tr><td class="paramname">vec</td><td>The value for the uniform </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ac64dbe301e9ee93f505ca288031188a8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac64dbe301e9ee93f505ca288031188a8">&#9670;&nbsp;</a></span>setUniformVec2() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void cugl::Shader::setUniformVec2 </td>
          <td>(</td>
          <td class="paramtype">GLint&#160;</td>
          <td class="paramname"><em>pos</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classcugl_1_1_vec2.html">Vec2</a>&#160;</td>
          <td class="paramname"><em>vec</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Sets the given uniform to a vector value.</p>
<p>This method will only succeed if the shader is actively bound.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pos</td><td>The location of the uniform in the shader </td></tr>
    <tr><td class="paramname">vec</td><td>The value for the uniform </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aae3d66b522f80975b4931581cdac03a9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aae3d66b522f80975b4931581cdac03a9">&#9670;&nbsp;</a></span>setUniformVec3() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void cugl::Shader::setUniformVec3 </td>
          <td>(</td>
          <td class="paramtype">const std::string&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classcugl_1_1_vec3.html">Vec3</a>&#160;</td>
          <td class="paramname"><em>vec</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Sets the given uniform to a vector value.</p>
<p>This method will only succeed if the shader is actively bound.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">name</td><td>The name of the uniform </td></tr>
    <tr><td class="paramname">vec</td><td>The value for the uniform </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a5d0328d43e02b31b4a8bce680ae25f0e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5d0328d43e02b31b4a8bce680ae25f0e">&#9670;&nbsp;</a></span>setUniformVec3() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void cugl::Shader::setUniformVec3 </td>
          <td>(</td>
          <td class="paramtype">GLint&#160;</td>
          <td class="paramname"><em>pos</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classcugl_1_1_vec3.html">Vec3</a>&#160;</td>
          <td class="paramname"><em>vec</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Sets the given uniform to a vector value.</p>
<p>This method will only succeed if the shader is actively bound.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pos</td><td>The location of the uniform in the shader </td></tr>
    <tr><td class="paramname">vec</td><td>The value for the uniform </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a40261c13525dcae116a0314658cdbd82"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a40261c13525dcae116a0314658cdbd82">&#9670;&nbsp;</a></span>setUniformVec4() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void cugl::Shader::setUniformVec4 </td>
          <td>(</td>
          <td class="paramtype">const std::string&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classcugl_1_1_vec4.html">Vec4</a>&#160;</td>
          <td class="paramname"><em>vec</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Sets the given uniform to a vector value.</p>
<p>This method will only succeed if the shader is actively bound.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">name</td><td>The name of the uniform </td></tr>
    <tr><td class="paramname">vec</td><td>The value for the uniform </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ab4882e989691f4730d96ec03debcb803"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab4882e989691f4730d96ec03debcb803">&#9670;&nbsp;</a></span>setUniformVec4() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void cugl::Shader::setUniformVec4 </td>
          <td>(</td>
          <td class="paramtype">GLint&#160;</td>
          <td class="paramname"><em>pos</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classcugl_1_1_vec4.html">Vec4</a>&#160;</td>
          <td class="paramname"><em>vec</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Sets the given uniform to a vector value.</p>
<p>This method will only succeed if the shader is actively bound.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pos</td><td>The location of the uniform in the shader </td></tr>
    <tr><td class="paramname">vec</td><td>The value for the uniform </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a947558fe76fbfe66fe10b024d3aa5c63"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a947558fe76fbfe66fe10b024d3aa5c63">&#9670;&nbsp;</a></span>unbind()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void cugl::Shader::unbind </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Unbinds this shader, making it no longer active.</p>
<p>Once unbound, OpenGL calls will no longer be sent to this shader. </p>

</div>
</div>
<h2 class="groupheader">Member Data Documentation</h2>
<a id="a3eaf330d845736f829448b99cdb50569"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3eaf330d845736f829448b99cdb50569">&#9670;&nbsp;</a></span>_attribnames</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::unordered_map&lt;GLint, std::string&gt; cugl::Shader::_attribnames</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>The attribute variable names of this shader </p>

</div>
</div>
<a id="a591c2872dc55f68cad631697fd9cfe99"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a591c2872dc55f68cad631697fd9cfe99">&#9670;&nbsp;</a></span>_attribsizes</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::unordered_map&lt;std::string, GLint&gt; cugl::Shader::_attribsizes</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>The attribute locations of this shader </p>

</div>
</div>
<a id="a21e6a924b22ab5cdedbada74f24e307f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a21e6a924b22ab5cdedbada74f24e307f">&#9670;&nbsp;</a></span>_attribtypes</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::unordered_map&lt;std::string, GLenum&gt; cugl::Shader::_attribtypes</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>The attribute locations of this shader </p>

</div>
</div>
<a id="a10fec4e22c37de1f249d2eea920bfb08"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a10fec4e22c37de1f249d2eea920bfb08">&#9670;&nbsp;</a></span>_fragShader</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">GLuint cugl::Shader::_fragShader</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>The OpenGL fragment shader for this shader </p>

</div>
</div>
<a id="a6fcbc98b42cabdea274754b51386fcd6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6fcbc98b42cabdea274754b51386fcd6">&#9670;&nbsp;</a></span>_fragSource</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::string cugl::Shader::_fragSource</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>The source string for the fragment shader </p>

</div>
</div>
<a id="aaf5dd17fa273e53bdc86beb5d82243dc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaf5dd17fa273e53bdc86beb5d82243dc">&#9670;&nbsp;</a></span>_program</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">GLuint cugl::Shader::_program</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>The OpenGL program for this shader </p>

</div>
</div>
<a id="a215552de318475ff70a9d68eeb3f1555"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a215552de318475ff70a9d68eeb3f1555">&#9670;&nbsp;</a></span>_uniblockfields</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::unordered_map&lt;GLint, GLint&gt; cugl::Shader::_uniblockfields</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Mappings of uniforms to a uniform block </p>

</div>
</div>
<a id="ae61da7dcab6d99b83b8cb9f0c08560dd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae61da7dcab6d99b83b8cb9f0c08560dd">&#9670;&nbsp;</a></span>_uniblocknames</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::unordered_map&lt;GLint,std::string&gt; cugl::Shader::_uniblocknames</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>The uniform block variable names for this shader </p>

</div>
</div>
<a id="a4d8afa8350ff5dd219fd97d44af574bd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4d8afa8350ff5dd219fd97d44af574bd">&#9670;&nbsp;</a></span>_uniblocksizes</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::unordered_map&lt;std::string, GLint&gt; cugl::Shader::_uniblocksizes</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>The uniform block locations of this shader </p>

</div>
</div>
<a id="a4a5fb2e115e1c2d45e9541f6bbb19fa6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4a5fb2e115e1c2d45e9541f6bbb19fa6">&#9670;&nbsp;</a></span>_uniformnames</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::unordered_map&lt;GLint,std::string&gt; cugl::Shader::_uniformnames</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>The uniform variable names for this shader (includes samplers) </p>

</div>
</div>
<a id="a98fcac69b007c708f01393163679b42d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a98fcac69b007c708f01393163679b42d">&#9670;&nbsp;</a></span>_uniformsizes</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::unordered_map&lt;std::string, GLint&gt; cugl::Shader::_uniformsizes</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>The uniform locations of this shader (includes samplers) </p>

</div>
</div>
<a id="a57e3b86e15e2bdfb0bc5e6cd6a310ddc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a57e3b86e15e2bdfb0bc5e6cd6a310ddc">&#9670;&nbsp;</a></span>_uniformtypes</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::unordered_map&lt;std::string, GLenum&gt; cugl::Shader::_uniformtypes</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>The uniform locations of this shader </p>

</div>
</div>
<a id="a023c20d88612467ea0ba992516393da5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a023c20d88612467ea0ba992516393da5">&#9670;&nbsp;</a></span>_vertShader</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">GLuint cugl::Shader::_vertShader</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>The OpenGL vertex shader for this shader </p>

</div>
</div>
<a id="a172bae1008cbed036fec484f6b9b15d0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a172bae1008cbed036fec484f6b9b15d0">&#9670;&nbsp;</a></span>_vertSource</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::string cugl::Shader::_vertSource</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>The source string for the vertex shader </p>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>include/cugl/render/<a class="el" href="_c_u_shader_8h_source.html">CUShader.h</a></li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.1
</small></address>
</body>
</html>
