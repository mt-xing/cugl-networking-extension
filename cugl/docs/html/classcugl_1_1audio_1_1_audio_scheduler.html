<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.9.1"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>CUGL 2.0: cugl::audio::AudioScheduler Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">CUGL 2.0
   </div>
   <div id="projectbrief">Cornell University Game Library</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.1 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search','.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespacecugl.html">cugl</a></li><li class="navelem"><a class="el" href="namespacecugl_1_1audio.html">audio</a></li><li class="navelem"><a class="el" href="classcugl_1_1audio_1_1_audio_scheduler.html">AudioScheduler</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-static-methods">Static Public Member Functions</a> &#124;
<a href="classcugl_1_1audio_1_1_audio_scheduler-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">cugl::audio::AudioScheduler Class Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p><code>#include &lt;<a class="el" href="_c_u_audio_scheduler_8h_source.html">CUAudioScheduler.h</a>&gt;</code></p>
<div class="dynheader">
Inheritance diagram for cugl::audio::AudioScheduler:</div>
<div class="dyncontent">
 <div class="center">
  <img src="classcugl_1_1audio_1_1_audio_scheduler.png" usemap="#cugl::audio::AudioScheduler_map" alt=""/>
  <map id="cugl::audio::AudioScheduler_map" name="cugl::audio::AudioScheduler_map">
<area href="classcugl_1_1audio_1_1_audio_node.html" alt="cugl::audio::AudioNode" shape="rect" coords="0,56,263,80"/>
  </map>
</div></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a1508bbc9b7ff64c4c4c3392b1e9b0525"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1audio_1_1_audio_scheduler.html#a1508bbc9b7ff64c4c4c3392b1e9b0525">AudioScheduler</a> ()</td></tr>
<tr class="separator:a1508bbc9b7ff64c4c4c3392b1e9b0525"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4bb4098001c26a665ad9f664ad592a2a"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1audio_1_1_audio_scheduler.html#a4bb4098001c26a665ad9f664ad592a2a">~AudioScheduler</a> ()</td></tr>
<tr class="separator:a4bb4098001c26a665ad9f664ad592a2a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4ca72d4096931f1dcb65aa3ef484428c"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1audio_1_1_audio_scheduler.html#a4ca72d4096931f1dcb65aa3ef484428c">init</a> () override</td></tr>
<tr class="separator:a4ca72d4096931f1dcb65aa3ef484428c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac30e4c5cc7af3695915f1efe451d4b93"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1audio_1_1_audio_scheduler.html#ac30e4c5cc7af3695915f1efe451d4b93">init</a> (Uint8 channels, Uint32 rate) override</td></tr>
<tr class="separator:ac30e4c5cc7af3695915f1efe451d4b93"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3f4b4d550af84cba9a6d17d21abbb522"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1audio_1_1_audio_scheduler.html#a3f4b4d550af84cba9a6d17d21abbb522">dispose</a> () override</td></tr>
<tr class="separator:a3f4b4d550af84cba9a6d17d21abbb522"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a353680159f8622ee8ecb532eed18d56b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1audio_1_1_audio_scheduler.html#a353680159f8622ee8ecb532eed18d56b">play</a> (const std::shared_ptr&lt; <a class="el" href="classcugl_1_1audio_1_1_audio_node.html">AudioNode</a> &gt; &amp;node, Sint32 loop=0)</td></tr>
<tr class="separator:a353680159f8622ee8ecb532eed18d56b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac2e97bd0ff46c476075f45096fc4d3ce"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1audio_1_1_audio_scheduler.html#ac2e97bd0ff46c476075f45096fc4d3ce">append</a> (const std::shared_ptr&lt; <a class="el" href="classcugl_1_1audio_1_1_audio_node.html">AudioNode</a> &gt; &amp;node, Sint32 loop=0)</td></tr>
<tr class="separator:ac2e97bd0ff46c476075f45096fc4d3ce"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6aef30732a8fca0e4d37fd226809348a"><td class="memItemLeft" align="right" valign="top">std::shared_ptr&lt; <a class="el" href="classcugl_1_1audio_1_1_audio_node.html">AudioNode</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1audio_1_1_audio_scheduler.html#a6aef30732a8fca0e4d37fd226809348a">getCurrent</a> () const</td></tr>
<tr class="separator:a6aef30732a8fca0e4d37fd226809348a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a30f5595158325bc77ab78f515a9cc96f"><td class="memItemLeft" align="right" valign="top">std::deque&lt; std::shared_ptr&lt; <a class="el" href="classcugl_1_1audio_1_1_audio_node.html">AudioNode</a> &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1audio_1_1_audio_scheduler.html#a30f5595158325bc77ab78f515a9cc96f">getTail</a> () const</td></tr>
<tr class="separator:a30f5595158325bc77ab78f515a9cc96f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2796bb6fa222fb0a9f33ea4b5abc745e"><td class="memItemLeft" align="right" valign="top">Uint32&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1audio_1_1_audio_scheduler.html#a2796bb6fa222fb0a9f33ea4b5abc745e">getTailSize</a> () const</td></tr>
<tr class="separator:a2796bb6fa222fb0a9f33ea4b5abc745e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab739e4385d3ecc9fb22a56b8ae5483e0"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1audio_1_1_audio_scheduler.html#ab739e4385d3ecc9fb22a56b8ae5483e0">clear</a> (bool force=false)</td></tr>
<tr class="separator:ab739e4385d3ecc9fb22a56b8ae5483e0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad5542008730767df3c16d7b132ed7740"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1audio_1_1_audio_scheduler.html#ad5542008730767df3c16d7b132ed7740">trim</a> (Sint32 size=-1)</td></tr>
<tr class="separator:ad5542008730767df3c16d7b132ed7740"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac8feb43812b9a09873280edf46cf1047"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1audio_1_1_audio_scheduler.html#ac8feb43812b9a09873280edf46cf1047">skip</a> (Uint32 n=0)</td></tr>
<tr class="separator:ac8feb43812b9a09873280edf46cf1047"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a666050b4ba6f6e0bca03560deca9f296"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1audio_1_1_audio_scheduler.html#a666050b4ba6f6e0bca03560deca9f296">isPlaying</a> ()</td></tr>
<tr class="separator:a666050b4ba6f6e0bca03560deca9f296"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1ce52c4cf180f1480c11dbcaf25e5c9c"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1audio_1_1_audio_scheduler.html#a1ce52c4cf180f1480c11dbcaf25e5c9c">getOverlap</a> () const</td></tr>
<tr class="separator:a1ce52c4cf180f1480c11dbcaf25e5c9c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3d56e326086c334697bf83438c2c5781"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1audio_1_1_audio_scheduler.html#a3d56e326086c334697bf83438c2c5781">setOverlap</a> (double time)</td></tr>
<tr class="separator:a3d56e326086c334697bf83438c2c5781"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac166d89ac6a24fbe80dd915d4d1d3cd9"><td class="memItemLeft" align="right" valign="top">Sint32&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1audio_1_1_audio_scheduler.html#ac166d89ac6a24fbe80dd915d4d1d3cd9">getLoops</a> () const</td></tr>
<tr class="separator:ac166d89ac6a24fbe80dd915d4d1d3cd9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0e12cf61b267caa77cbb9cd20955b686"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1audio_1_1_audio_scheduler.html#a0e12cf61b267caa77cbb9cd20955b686">setLoops</a> (Sint32 loop)</td></tr>
<tr class="separator:a0e12cf61b267caa77cbb9cd20955b686"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa1dd7275d0eecc17c91b1c92b5b0c7e5"><td class="memItemLeft" align="right" valign="top">virtual Uint32&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1audio_1_1_audio_scheduler.html#aa1dd7275d0eecc17c91b1c92b5b0c7e5">read</a> (float *buffer, Uint32 frames) override</td></tr>
<tr class="separator:aa1dd7275d0eecc17c91b1c92b5b0c7e5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a506e67f8f1f6027a1cb376150a1c111a"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1audio_1_1_audio_scheduler.html#a506e67f8f1f6027a1cb376150a1c111a">mark</a> () override</td></tr>
<tr class="separator:a506e67f8f1f6027a1cb376150a1c111a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af40aaa286b71f51c6ecd9a95d56bb61b"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1audio_1_1_audio_scheduler.html#af40aaa286b71f51c6ecd9a95d56bb61b">unmark</a> () override</td></tr>
<tr class="separator:af40aaa286b71f51c6ecd9a95d56bb61b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acf84cf1a4583763b6c14a73d9ff390d1"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1audio_1_1_audio_scheduler.html#acf84cf1a4583763b6c14a73d9ff390d1">reset</a> () override</td></tr>
<tr class="separator:acf84cf1a4583763b6c14a73d9ff390d1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a749826e26eb59da84650595a677e40b8"><td class="memItemLeft" align="right" valign="top">virtual Sint64&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1audio_1_1_audio_scheduler.html#a749826e26eb59da84650595a677e40b8">advance</a> (Uint32 frames) override</td></tr>
<tr class="separator:a749826e26eb59da84650595a677e40b8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1217cd39c75961f07f44e6248790bca8"><td class="memItemLeft" align="right" valign="top">virtual Sint64&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1audio_1_1_audio_scheduler.html#a1217cd39c75961f07f44e6248790bca8">getPosition</a> () const override</td></tr>
<tr class="separator:a1217cd39c75961f07f44e6248790bca8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a79822765daf0103a86e0cd5e82ae45e9"><td class="memItemLeft" align="right" valign="top">virtual Sint64&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1audio_1_1_audio_scheduler.html#a79822765daf0103a86e0cd5e82ae45e9">setPosition</a> (Uint32 position) override</td></tr>
<tr class="separator:a79822765daf0103a86e0cd5e82ae45e9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aab44f829d75467ccc59a1aee6748e446"><td class="memItemLeft" align="right" valign="top">virtual double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1audio_1_1_audio_scheduler.html#aab44f829d75467ccc59a1aee6748e446">getElapsed</a> () const override</td></tr>
<tr class="separator:aab44f829d75467ccc59a1aee6748e446"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aba5c1ea00ad8b3a540b7afaba75f6303"><td class="memItemLeft" align="right" valign="top">virtual double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1audio_1_1_audio_scheduler.html#aba5c1ea00ad8b3a540b7afaba75f6303">setElapsed</a> (double time) override</td></tr>
<tr class="separator:aba5c1ea00ad8b3a540b7afaba75f6303"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_methods_classcugl_1_1audio_1_1_audio_node"><td colspan="2" onclick="javascript:toggleInherit('pub_methods_classcugl_1_1audio_1_1_audio_node')"><img src="closed.png" alt="-"/>&#160;Public Member Functions inherited from <a class="el" href="classcugl_1_1audio_1_1_audio_node.html">cugl::audio::AudioNode</a></td></tr>
<tr class="memitem:a450398de9652ebb1e8c8f3bb760724f2 inherit pub_methods_classcugl_1_1audio_1_1_audio_node"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1audio_1_1_audio_node.html#a450398de9652ebb1e8c8f3bb760724f2">AudioNode</a> ()</td></tr>
<tr class="separator:a450398de9652ebb1e8c8f3bb760724f2 inherit pub_methods_classcugl_1_1audio_1_1_audio_node"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adcc9ce7e8cf1a3db9ea74a8524e6d4bc inherit pub_methods_classcugl_1_1audio_1_1_audio_node"><td class="memItemLeft" align="right" valign="top">virtual&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1audio_1_1_audio_node.html#adcc9ce7e8cf1a3db9ea74a8524e6d4bc">~AudioNode</a> ()</td></tr>
<tr class="separator:adcc9ce7e8cf1a3db9ea74a8524e6d4bc inherit pub_methods_classcugl_1_1audio_1_1_audio_node"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0396f699961bc673abcd40a314c3894d inherit pub_methods_classcugl_1_1audio_1_1_audio_node"><td class="memItemLeft" align="right" valign="top">Uint8&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1audio_1_1_audio_node.html#a0396f699961bc673abcd40a314c3894d">getChannels</a> () const</td></tr>
<tr class="separator:a0396f699961bc673abcd40a314c3894d inherit pub_methods_classcugl_1_1audio_1_1_audio_node"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a312fdd11788433f3cbd7e7402052b950 inherit pub_methods_classcugl_1_1audio_1_1_audio_node"><td class="memItemLeft" align="right" valign="top">Uint32&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1audio_1_1_audio_node.html#a312fdd11788433f3cbd7e7402052b950">getRate</a> () const</td></tr>
<tr class="separator:a312fdd11788433f3cbd7e7402052b950 inherit pub_methods_classcugl_1_1audio_1_1_audio_node"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aecc49eb34dd64752233b04087608be47 inherit pub_methods_classcugl_1_1audio_1_1_audio_node"><td class="memItemLeft" align="right" valign="top">float&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1audio_1_1_audio_node.html#aecc49eb34dd64752233b04087608be47">getGain</a> ()</td></tr>
<tr class="separator:aecc49eb34dd64752233b04087608be47 inherit pub_methods_classcugl_1_1audio_1_1_audio_node"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad54295937be8a66452a9e597442d84dd inherit pub_methods_classcugl_1_1audio_1_1_audio_node"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1audio_1_1_audio_node.html#ad54295937be8a66452a9e597442d84dd">setGain</a> (float gain)</td></tr>
<tr class="separator:ad54295937be8a66452a9e597442d84dd inherit pub_methods_classcugl_1_1audio_1_1_audio_node"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a51b38f641d8ad1f9a61ab5abe3078eeb inherit pub_methods_classcugl_1_1audio_1_1_audio_node"><td class="memItemLeft" align="right" valign="top">const std::string &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1audio_1_1_audio_node.html#a51b38f641d8ad1f9a61ab5abe3078eeb">getClassName</a> () const</td></tr>
<tr class="separator:a51b38f641d8ad1f9a61ab5abe3078eeb inherit pub_methods_classcugl_1_1audio_1_1_audio_node"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeba6f7fbd240123159850cbb499df941 inherit pub_methods_classcugl_1_1audio_1_1_audio_node"><td class="memItemLeft" align="right" valign="top">const std::string &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1audio_1_1_audio_node.html#aeba6f7fbd240123159850cbb499df941">getName</a> () const</td></tr>
<tr class="separator:aeba6f7fbd240123159850cbb499df941 inherit pub_methods_classcugl_1_1audio_1_1_audio_node"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afe5c8c76880bf8aef686a4511a6a236b inherit pub_methods_classcugl_1_1audio_1_1_audio_node"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1audio_1_1_audio_node.html#afe5c8c76880bf8aef686a4511a6a236b">setName</a> (const std::string name)</td></tr>
<tr class="separator:afe5c8c76880bf8aef686a4511a6a236b inherit pub_methods_classcugl_1_1audio_1_1_audio_node"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a36495ae6d6fee3157797f80e3cb75860 inherit pub_methods_classcugl_1_1audio_1_1_audio_node"><td class="memItemLeft" align="right" valign="top">Sint32&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1audio_1_1_audio_node.html#a36495ae6d6fee3157797f80e3cb75860">getTag</a> () const</td></tr>
<tr class="separator:a36495ae6d6fee3157797f80e3cb75860 inherit pub_methods_classcugl_1_1audio_1_1_audio_node"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aae83689d49e5d2fc1a5e0bdb5307cc01 inherit pub_methods_classcugl_1_1audio_1_1_audio_node"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1audio_1_1_audio_node.html#aae83689d49e5d2fc1a5e0bdb5307cc01">setTag</a> (Sint32 tag)</td></tr>
<tr class="separator:aae83689d49e5d2fc1a5e0bdb5307cc01 inherit pub_methods_classcugl_1_1audio_1_1_audio_node"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a659c20facc39e58a4c33111e90455744 inherit pub_methods_classcugl_1_1audio_1_1_audio_node"><td class="memItemLeft" align="right" valign="top">virtual std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1audio_1_1_audio_node.html#a659c20facc39e58a4c33111e90455744">toString</a> (bool verbose=false) const</td></tr>
<tr class="separator:a659c20facc39e58a4c33111e90455744 inherit pub_methods_classcugl_1_1audio_1_1_audio_node"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a640c6af71cde22b38fe2aada84534207 inherit pub_methods_classcugl_1_1audio_1_1_audio_node"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1audio_1_1_audio_node.html#a640c6af71cde22b38fe2aada84534207">operator std::string</a> () const</td></tr>
<tr class="separator:a640c6af71cde22b38fe2aada84534207 inherit pub_methods_classcugl_1_1audio_1_1_audio_node"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab3c43577e83f2c620e2643dea4a159b9 inherit pub_methods_classcugl_1_1audio_1_1_audio_node"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classcugl_1_1audio_1_1_audio_node.html#af4b00d0b569c4c5fd501b6bf8282269c">Callback</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1audio_1_1_audio_node.html#ab3c43577e83f2c620e2643dea4a159b9">getCallback</a> ()</td></tr>
<tr class="separator:ab3c43577e83f2c620e2643dea4a159b9 inherit pub_methods_classcugl_1_1audio_1_1_audio_node"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a480412edb67f40ed96ad1c988046f666 inherit pub_methods_classcugl_1_1audio_1_1_audio_node"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1audio_1_1_audio_node.html#a480412edb67f40ed96ad1c988046f666">setCallback</a> (<a class="el" href="classcugl_1_1audio_1_1_audio_node.html#af4b00d0b569c4c5fd501b6bf8282269c">Callback</a> callback)</td></tr>
<tr class="separator:a480412edb67f40ed96ad1c988046f666 inherit pub_methods_classcugl_1_1audio_1_1_audio_node"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3721e16d5c024b47d6124f6b96a4852a inherit pub_methods_classcugl_1_1audio_1_1_audio_node"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1audio_1_1_audio_node.html#a3721e16d5c024b47d6124f6b96a4852a">isPaused</a> ()</td></tr>
<tr class="separator:a3721e16d5c024b47d6124f6b96a4852a inherit pub_methods_classcugl_1_1audio_1_1_audio_node"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a54f20aa0d41c365daa6234008f1f6ce1 inherit pub_methods_classcugl_1_1audio_1_1_audio_node"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1audio_1_1_audio_node.html#a54f20aa0d41c365daa6234008f1f6ce1">pause</a> ()</td></tr>
<tr class="separator:a54f20aa0d41c365daa6234008f1f6ce1 inherit pub_methods_classcugl_1_1audio_1_1_audio_node"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2863f1318377820ada0dd6dd74a47d96 inherit pub_methods_classcugl_1_1audio_1_1_audio_node"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1audio_1_1_audio_node.html#a2863f1318377820ada0dd6dd74a47d96">resume</a> ()</td></tr>
<tr class="separator:a2863f1318377820ada0dd6dd74a47d96 inherit pub_methods_classcugl_1_1audio_1_1_audio_node"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a891ba93a6189f353c4b6fa893819001f inherit pub_methods_classcugl_1_1audio_1_1_audio_node"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1audio_1_1_audio_node.html#a891ba93a6189f353c4b6fa893819001f">completed</a> ()</td></tr>
<tr class="separator:a891ba93a6189f353c4b6fa893819001f inherit pub_methods_classcugl_1_1audio_1_1_audio_node"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a715678edba83d3c178469fe4fbdc310d inherit pub_methods_classcugl_1_1audio_1_1_audio_node"><td class="memItemLeft" align="right" valign="top">virtual double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1audio_1_1_audio_node.html#a715678edba83d3c178469fe4fbdc310d">getRemaining</a> () const</td></tr>
<tr class="separator:a715678edba83d3c178469fe4fbdc310d inherit pub_methods_classcugl_1_1audio_1_1_audio_node"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adc135ee04252bf1e3adc0a052a1ef2fa inherit pub_methods_classcugl_1_1audio_1_1_audio_node"><td class="memItemLeft" align="right" valign="top">virtual double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1audio_1_1_audio_node.html#adc135ee04252bf1e3adc0a052a1ef2fa">setRemaining</a> (double time)</td></tr>
<tr class="separator:adc135ee04252bf1e3adc0a052a1ef2fa inherit pub_methods_classcugl_1_1audio_1_1_audio_node"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-static-methods"></a>
Static Public Member Functions</h2></td></tr>
<tr class="memitem:a7ef39a3d88f9c3289d17249562d02437"><td class="memItemLeft" align="right" valign="top">static std::shared_ptr&lt; <a class="el" href="classcugl_1_1audio_1_1_audio_scheduler.html">AudioScheduler</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1audio_1_1_audio_scheduler.html#a7ef39a3d88f9c3289d17249562d02437">alloc</a> (Uint8 channels, Uint32 rate)</td></tr>
<tr class="separator:a7ef39a3d88f9c3289d17249562d02437"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="inherited"></a>
Additional Inherited Members</h2></td></tr>
<tr class="inherit_header pub_types_classcugl_1_1audio_1_1_audio_node"><td colspan="2" onclick="javascript:toggleInherit('pub_types_classcugl_1_1audio_1_1_audio_node')"><img src="closed.png" alt="-"/>&#160;Public Types inherited from <a class="el" href="classcugl_1_1audio_1_1_audio_node.html">cugl::audio::AudioNode</a></td></tr>
<tr class="memitem:a398299268055a47f10eac3e714f5ccd5 inherit pub_types_classcugl_1_1audio_1_1_audio_node"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1audio_1_1_audio_node.html#a398299268055a47f10eac3e714f5ccd5">Action</a> : int { <br />
&#160;&#160;<a class="el" href="classcugl_1_1audio_1_1_audio_node.html#a398299268055a47f10eac3e714f5ccd5a6b8d970c554edd2d97d33104de7147d1">COMPLETE</a> = 0
, <a class="el" href="classcugl_1_1audio_1_1_audio_node.html#a398299268055a47f10eac3e714f5ccd5abcc43eacc987a1df1d5bb02876902a0f">INTERRUPT</a> = 1
, <a class="el" href="classcugl_1_1audio_1_1_audio_node.html#a398299268055a47f10eac3e714f5ccd5ac8e63850ccda2900585c54bda450af40">FADE_OUT</a> = 2
, <a class="el" href="classcugl_1_1audio_1_1_audio_node.html#a398299268055a47f10eac3e714f5ccd5ae32c7c77531c0eab9d1c8052ea9f3d94">FADE_IN</a> = 3
, <br />
&#160;&#160;<a class="el" href="classcugl_1_1audio_1_1_audio_node.html#a398299268055a47f10eac3e714f5ccd5a76ab8a0b8ddd34c170cbdce7163595e5">FADE_DIP</a> = 4
, <a class="el" href="classcugl_1_1audio_1_1_audio_node.html#a398299268055a47f10eac3e714f5ccd5ad04cc6ee406b89205d97050f0326f55f">LOOPBACK</a> = 5
<br />
 }</td></tr>
<tr class="separator:a398299268055a47f10eac3e714f5ccd5 inherit pub_types_classcugl_1_1audio_1_1_audio_node"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af4b00d0b569c4c5fd501b6bf8282269c inherit pub_types_classcugl_1_1audio_1_1_audio_node"><td class="memItemLeft" align="right" valign="top">typedef std::function&lt; void(const std::shared_ptr&lt; <a class="el" href="classcugl_1_1audio_1_1_audio_node.html">AudioNode</a> &gt; &amp;node, <a class="el" href="classcugl_1_1audio_1_1_audio_node.html#a398299268055a47f10eac3e714f5ccd5">Action</a> type)&gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1audio_1_1_audio_node.html#af4b00d0b569c4c5fd501b6bf8282269c">Callback</a></td></tr>
<tr class="separator:af4b00d0b569c4c5fd501b6bf8282269c inherit pub_types_classcugl_1_1audio_1_1_audio_node"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_static_attribs_classcugl_1_1audio_1_1_audio_node"><td colspan="2" onclick="javascript:toggleInherit('pub_static_attribs_classcugl_1_1audio_1_1_audio_node')"><img src="closed.png" alt="-"/>&#160;Static Public Attributes inherited from <a class="el" href="classcugl_1_1audio_1_1_audio_node.html">cugl::audio::AudioNode</a></td></tr>
<tr class="memitem:a168caf623eb08584e401f2a133cd51c4 inherit pub_static_attribs_classcugl_1_1audio_1_1_audio_node"><td class="memItemLeft" align="right" valign="top">static const Uint32&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1audio_1_1_audio_node.html#a168caf623eb08584e401f2a133cd51c4">DEFAULT_CHANNELS</a></td></tr>
<tr class="separator:a168caf623eb08584e401f2a133cd51c4 inherit pub_static_attribs_classcugl_1_1audio_1_1_audio_node"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab83764077c3c55ffe04c8056658f2cdd inherit pub_static_attribs_classcugl_1_1audio_1_1_audio_node"><td class="memItemLeft" align="right" valign="top">static const Uint32&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1audio_1_1_audio_node.html#ab83764077c3c55ffe04c8056658f2cdd">DEFAULT_SAMPLING</a></td></tr>
<tr class="separator:ab83764077c3c55ffe04c8056658f2cdd inherit pub_static_attribs_classcugl_1_1audio_1_1_audio_node"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pro_methods_classcugl_1_1audio_1_1_audio_node"><td colspan="2" onclick="javascript:toggleInherit('pro_methods_classcugl_1_1audio_1_1_audio_node')"><img src="closed.png" alt="-"/>&#160;Protected Member Functions inherited from <a class="el" href="classcugl_1_1audio_1_1_audio_node.html">cugl::audio::AudioNode</a></td></tr>
<tr class="memitem:aef15d04ae96c90dbda0071cc2e06011c inherit pro_methods_classcugl_1_1audio_1_1_audio_node"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1audio_1_1_audio_node.html#aef15d04ae96c90dbda0071cc2e06011c">notify</a> (const std::shared_ptr&lt; <a class="el" href="classcugl_1_1audio_1_1_audio_node.html">AudioNode</a> &gt; &amp;node, <a class="el" href="classcugl_1_1audio_1_1_audio_node.html#a398299268055a47f10eac3e714f5ccd5">Action</a> action)</td></tr>
<tr class="separator:aef15d04ae96c90dbda0071cc2e06011c inherit pro_methods_classcugl_1_1audio_1_1_audio_node"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pro_attribs_classcugl_1_1audio_1_1_audio_node"><td colspan="2" onclick="javascript:toggleInherit('pro_attribs_classcugl_1_1audio_1_1_audio_node')"><img src="closed.png" alt="-"/>&#160;Protected Attributes inherited from <a class="el" href="classcugl_1_1audio_1_1_audio_node.html">cugl::audio::AudioNode</a></td></tr>
<tr class="memitem:a4837b4b229b77ec11cb697d0424a63ee inherit pro_attribs_classcugl_1_1audio_1_1_audio_node"><td class="memItemLeft" align="right" valign="top">Uint8&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1audio_1_1_audio_node.html#a4837b4b229b77ec11cb697d0424a63ee">_channels</a></td></tr>
<tr class="separator:a4837b4b229b77ec11cb697d0424a63ee inherit pro_attribs_classcugl_1_1audio_1_1_audio_node"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abcf7a7445a5c3a3cc933d027e99470c1 inherit pro_attribs_classcugl_1_1audio_1_1_audio_node"><td class="memItemLeft" align="right" valign="top">Uint32&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1audio_1_1_audio_node.html#abcf7a7445a5c3a3cc933d027e99470c1">_sampling</a></td></tr>
<tr class="separator:abcf7a7445a5c3a3cc933d027e99470c1 inherit pro_attribs_classcugl_1_1audio_1_1_audio_node"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae57093ef216f3a802828a6f50e8ed9c1 inherit pro_attribs_classcugl_1_1audio_1_1_audio_node"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1audio_1_1_audio_node.html#ae57093ef216f3a802828a6f50e8ed9c1">_booted</a></td></tr>
<tr class="separator:ae57093ef216f3a802828a6f50e8ed9c1 inherit pro_attribs_classcugl_1_1audio_1_1_audio_node"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a628e189aa54ee04f0ebfdec98239a172 inherit pro_attribs_classcugl_1_1audio_1_1_audio_node"><td class="memItemLeft" align="right" valign="top">std::atomic&lt; float &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1audio_1_1_audio_node.html#a628e189aa54ee04f0ebfdec98239a172">_ndgain</a></td></tr>
<tr class="separator:a628e189aa54ee04f0ebfdec98239a172 inherit pro_attribs_classcugl_1_1audio_1_1_audio_node"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aac385495fa5628b048f2f2cfbc542ed8 inherit pro_attribs_classcugl_1_1audio_1_1_audio_node"><td class="memItemLeft" align="right" valign="top">std::atomic&lt; bool &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1audio_1_1_audio_node.html#aac385495fa5628b048f2f2cfbc542ed8">_paused</a></td></tr>
<tr class="separator:aac385495fa5628b048f2f2cfbc542ed8 inherit pro_attribs_classcugl_1_1audio_1_1_audio_node"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8d0ac60c3f854fddc6c83aa6b20b28a6 inherit pro_attribs_classcugl_1_1audio_1_1_audio_node"><td class="memItemLeft" align="right" valign="top">std::atomic&lt; bool &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1audio_1_1_audio_node.html#a8d0ac60c3f854fddc6c83aa6b20b28a6">_polling</a></td></tr>
<tr class="separator:a8d0ac60c3f854fddc6c83aa6b20b28a6 inherit pro_attribs_classcugl_1_1audio_1_1_audio_node"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a175a7edfd8f4febfc0fc337430563818 inherit pro_attribs_classcugl_1_1audio_1_1_audio_node"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classcugl_1_1audio_1_1_audio_node.html#af4b00d0b569c4c5fd501b6bf8282269c">Callback</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1audio_1_1_audio_node.html#a175a7edfd8f4febfc0fc337430563818">_callback</a></td></tr>
<tr class="separator:a175a7edfd8f4febfc0fc337430563818 inherit pro_attribs_classcugl_1_1audio_1_1_audio_node"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a87226a41bc22f0936753606ced5ddfd1 inherit pro_attribs_classcugl_1_1audio_1_1_audio_node"><td class="memItemLeft" align="right" valign="top">std::atomic&lt; bool &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1audio_1_1_audio_node.html#a87226a41bc22f0936753606ced5ddfd1">_calling</a></td></tr>
<tr class="separator:a87226a41bc22f0936753606ced5ddfd1 inherit pro_attribs_classcugl_1_1audio_1_1_audio_node"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a485a1ac91ce96563711fce65c09fabea inherit pro_attribs_classcugl_1_1audio_1_1_audio_node"><td class="memItemLeft" align="right" valign="top">Sint32&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1audio_1_1_audio_node.html#a485a1ac91ce96563711fce65c09fabea">_tag</a></td></tr>
<tr class="separator:a485a1ac91ce96563711fce65c09fabea inherit pro_attribs_classcugl_1_1audio_1_1_audio_node"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8b23d6509865aaa4a4a551c1d4358e55 inherit pro_attribs_classcugl_1_1audio_1_1_audio_node"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1audio_1_1_audio_node.html#a8b23d6509865aaa4a4a551c1d4358e55">_localname</a></td></tr>
<tr class="separator:a8b23d6509865aaa4a4a551c1d4358e55 inherit pro_attribs_classcugl_1_1audio_1_1_audio_node"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaccf795c25ebf8352f91e9a2b2fd1cd1 inherit pro_attribs_classcugl_1_1audio_1_1_audio_node"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1audio_1_1_audio_node.html#aaccf795c25ebf8352f91e9a2b2fd1cd1">_classname</a></td></tr>
<tr class="separator:aaccf795c25ebf8352f91e9a2b2fd1cd1 inherit pro_attribs_classcugl_1_1audio_1_1_audio_node"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a79b6fb623feefb6534c72d0cbcb6d9a2 inherit pro_attribs_classcugl_1_1audio_1_1_audio_node"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1audio_1_1_audio_node.html#a79b6fb623feefb6534c72d0cbcb6d9a2">_hashOfName</a></td></tr>
<tr class="separator:a79b6fb623feefb6534c72d0cbcb6d9a2 inherit pro_attribs_classcugl_1_1audio_1_1_audio_node"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>This class is capable of scheduling audio nodes in sequence.</p>
<p>This node is important for supporting dynamic playback. While we can safely rearrange nodes in the audio graph when it is not active, this allows us to schedule nodes while playback is ongoing. When combined with <a class="el" href="classcugl_1_1audio_1_1_audio_player.html">AudioPlayer</a>, this provides a classic player node such as you might find in AVFoundation. However, by generalizing this concept, we are able to schedule arbitrary audio patches as well.</p>
<p>To support seamless audio, a scheduler is fed by a queue. That way the user can queue up a new source while the current one is playing. However, to simplify the data structures and ensure thread safety, we do not allow the user to look at the contents of the queue. The user can only look at the currently playing node.</p>
<p>The audio graph should only be accessed in the main thread. In addition, no methods marked as AUDIO THREAD ONLY should ever be accessed by the user.</p>
<p>This audio node supports the callback functions in <a class="el" href="classcugl_1_1audio_1_1_audio_node.html#a480412edb67f40ed96ad1c988046f666">AudioNode#setCallback</a>. This function function is called whenever a node is removed from the scheduler. This may be because the node played to completion (defined as a <a class="el" href="classcugl_1_1audio_1_1_audio_scheduler.html#aa1dd7275d0eecc17c91b1c92b5b0c7e5">AudioScheduler#read()</a> result that returns 0) or it was interrupted. </p>
</div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="a1508bbc9b7ff64c4c4c3392b1e9b0525"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1508bbc9b7ff64c4c4c3392b1e9b0525">&#9670;&nbsp;</a></span>AudioScheduler()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">cugl::audio::AudioScheduler::AudioScheduler </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Creates an inactive scheduler node.</p>
<p>NEVER USE A CONSTRUCTOR WITH NEW. If you want to allocate a graph node on the heap, use one of the static constructors instead. </p>

</div>
</div>
<a id="a4bb4098001c26a665ad9f664ad592a2a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4bb4098001c26a665ad9f664ad592a2a">&#9670;&nbsp;</a></span>~AudioScheduler()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">cugl::audio::AudioScheduler::~AudioScheduler </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Deletes the scheduler node, disposing of all resources </p>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="a749826e26eb59da84650595a677e40b8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a749826e26eb59da84650595a677e40b8">&#9670;&nbsp;</a></span>advance()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual Sint64 cugl::audio::AudioScheduler::advance </td>
          <td>(</td>
          <td class="paramtype">Uint32&#160;</td>
          <td class="paramname"><em>frames</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Sets the current frame position of this audio node.</p>
<p>DELEGATED METHOD: This method delegates its call to the current audio node. It returns -1 if there is no active node or if this method is unsupported.</p>
<p>If the number of frames is set beyond the bounds of the current node, the outcome will depend on the state of the audio queue. A looped node will simply loop the given number of frames. Otherwise, if this position causes the audio node to complete, it will continue to advance through the queue so long as this method (and <a class="el" href="classcugl_1_1audio_1_1_audio_node.html#a891ba93a6189f353c4b6fa893819001f">completed()</a>) is supported.</p>
<p>This method is thread safe, and may be called outside the audio thread. However, the accuracy of the result on a non-paused audio source is subject to minor race conditions (e.g. you may set the time, but have it forwarded by the next window size without reading). In addition, some streaming formats are less accurate than others.</p>
<p>This method will work even if <a class="el" href="classcugl_1_1audio_1_1_audio_node.html#a93a80b1ab4063f84d2fc26d7e47c32c3">AudioNode#mark()</a> is not set.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">frames</td><td>The number of frames to advance</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the actual number of frames advanced; -1 if not supported </dd></dl>

<p>Reimplemented from <a class="el" href="classcugl_1_1audio_1_1_audio_node.html#a782081b0057ef90a5c4bb190fb6c39ce">cugl::audio::AudioNode</a>.</p>

</div>
</div>
<a id="a7ef39a3d88f9c3289d17249562d02437"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7ef39a3d88f9c3289d17249562d02437">&#9670;&nbsp;</a></span>alloc()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static std::shared_ptr&lt;<a class="el" href="classcugl_1_1audio_1_1_audio_scheduler.html">AudioScheduler</a>&gt; cugl::audio::AudioScheduler::alloc </td>
          <td>(</td>
          <td class="paramtype">Uint8&#160;</td>
          <td class="paramname"><em>channels</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Uint32&#160;</td>
          <td class="paramname"><em>rate</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns an allocated player with the given number of channels and sample rate</p>
<p>These values determine the buffer the structure for all <a class="el" href="classcugl_1_1audio_1_1_audio_scheduler.html#aa1dd7275d0eecc17c91b1c92b5b0c7e5">read</a> operations. In addition, they also detemine what types of sources that the player can support. A player can only play assets with the right sampling rate and number of channels.</p>
<p>The node starts off inactive. It will become active when a source is added to the queue.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">channels</td><td>The number of audio channels </td></tr>
    <tr><td class="paramname">rate</td><td>The sample rate (frequency) in HZ</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>an allocated player with the given number of channels and sample rate </dd></dl>

</div>
</div>
<a id="ac2e97bd0ff46c476075f45096fc4d3ce"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac2e97bd0ff46c476075f45096fc4d3ce">&#9670;&nbsp;</a></span>append()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void cugl::audio::AudioScheduler::append </td>
          <td>(</td>
          <td class="paramtype">const std::shared_ptr&lt; <a class="el" href="classcugl_1_1audio_1_1_audio_node.html">AudioNode</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>node</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Sint32&#160;</td>
          <td class="paramname"><em>loop</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Appends a new audio node for playback.</p>
<p>This method appends to the node to the playback queue. It will be played as soon as the nodes that are earlier in the queue have completed playing.</p>
<p>This audio node may be any satisfying class, though it is typically an instance of <a class="el" href="classcugl_1_1audio_1_1_audio_player.html">AudioPlayer</a>. Gain control is handled in the node itself (though the scheduler can add extra gain). The only new feature added is looping.</p>
<p>The loop value is an integer. If it is 0, the audio node will not be looped. If it is positive, it will loop the audio that many (additional) times. If it is negative, the audio node will be looped indefinitely until it is stopped.</p>
<p>If the user has provided an optional callback function, this will be called when the node is removed, either because it completed (defined by <a class="el" href="classcugl_1_1audio_1_1_audio_node.html#a891ba93a6189f353c4b6fa893819001f">AudioNode#completed()</a>) or is interrupted.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">node</td><td>The audio node for playback </td></tr>
    <tr><td class="paramname">loop</td><td>The number of times to loop the audio </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ab739e4385d3ecc9fb22a56b8ae5483e0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab739e4385d3ecc9fb22a56b8ae5483e0">&#9670;&nbsp;</a></span>clear()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void cugl::audio::AudioScheduler::clear </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>force</em> = <code>false</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Stops the current playback and empties the queue.</p>
<p>To ensure consistency, this method only flags the nodes for deletion. Clean-up will occur in the audio thread. This ensures that the callback function (if provided) is called from the audio thread for all of the nodes removed from the queue (as well as the current node). The complete flag will be false, indicating that they were interrupted.</p>
<p>The optional force argument allows for sounds to be purged immediately (such as during clean-up). However, doing so will not invoke the callback function, even if it is provided.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">force</td><td>whether to delete the queue immediately, in the current thread </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a3f4b4d550af84cba9a6d17d21abbb522"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3f4b4d550af84cba9a6d17d21abbb522">&#9670;&nbsp;</a></span>dispose()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void cugl::audio::AudioScheduler::dispose </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Disposes any resources allocated for this node</p>
<p>The state of the node is reset to that of an uninitialized constructor. Unlike the destructor, this method allows the node to be reinitialized. </p>

<p>Reimplemented from <a class="el" href="classcugl_1_1audio_1_1_audio_node.html#a41cf3dfa804054ea8b31168e650eea72">cugl::audio::AudioNode</a>.</p>

</div>
</div>
<a id="a6aef30732a8fca0e4d37fd226809348a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6aef30732a8fca0e4d37fd226809348a">&#9670;&nbsp;</a></span>getCurrent()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::shared_ptr&lt;<a class="el" href="classcugl_1_1audio_1_1_audio_node.html">AudioNode</a>&gt; cugl::audio::AudioScheduler::getCurrent </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns the audio node currently being played.</p>
<p>If the user has provided an optional callback function, this will be called when this node is no longer active</p>
<dl class="section return"><dt>Returns</dt><dd>the audio node currently being played. </dd></dl>

</div>
</div>
<a id="aab44f829d75467ccc59a1aee6748e446"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aab44f829d75467ccc59a1aee6748e446">&#9670;&nbsp;</a></span>getElapsed()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual double cugl::audio::AudioScheduler::getElapsed </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns the elapsed time in seconds.</p>
<p>DELEGATED METHOD: This method delegates its call to the current audio node. It returns -1 if there is no active node or if this method is unsupported.</p>
<p>This method has no effect unless <a class="el" href="classcugl_1_1audio_1_1_audio_scheduler.html#a506e67f8f1f6027a1cb376150a1c111a">mark()</a> is called. All time is relative from the marked position.</p>
<p>This method is thread safe, and may be called outside the audio thread. However, the accuracy of the result on a non-paused audio source is subject to minor race conditions (e.g. you may set the time, but have it forwarded by the next window size without reading). In addition, some streaming formats are less accurate than others.</p>
<dl class="section return"><dt>Returns</dt><dd>the elapsed time in seconds. </dd></dl>

<p>Reimplemented from <a class="el" href="classcugl_1_1audio_1_1_audio_node.html#aaaadd50221be0af3531d647b00109fc3">cugl::audio::AudioNode</a>.</p>

</div>
</div>
<a id="ac166d89ac6a24fbe80dd915d4d1d3cd9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac166d89ac6a24fbe80dd915d4d1d3cd9">&#9670;&nbsp;</a></span>getLoops()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Sint32 cugl::audio::AudioScheduler::getLoops </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns number of loops remaining for the active audio node.</p>
<p>If the value is 0, then the audio node will be removed from the queue when it completes (as defined by <a class="el" href="classcugl_1_1audio_1_1_audio_node.html#a891ba93a6189f353c4b6fa893819001f">AudioNode#completed()</a>. A value greater than 0 will repeat that many times, assuming that the method <a class="el" href="classcugl_1_1audio_1_1_audio_node.html#a77780ab5151b4af69bddf55ed288ed3a">AudioNode#reset()</a> is implemented (a node that cannot be reset cannot be looped). Finally, a negative value will be played indefinitely, unless it is stopped or or the loop count is changed.</p>
<p>This method returns 0 if there is no active audio node</p>
<p>return true if the active audio node is looped. </p>

</div>
</div>
<a id="a1ce52c4cf180f1480c11dbcaf25e5c9c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1ce52c4cf180f1480c11dbcaf25e5c9c">&#9670;&nbsp;</a></span>getOverlap()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double cugl::audio::AudioScheduler::getOverlap </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns the overlap time in seconds.</p>
<p>The overlap time is the amount of time to cross-fade between a node on the queue and the next. It does not apply to looped nodes; nodes can never cross-fade with themselves.</p>
<p>The cross-fade is triggered when a node implements the method <a class="el" href="classcugl_1_1audio_1_1_audio_node.html#a715678edba83d3c178469fe4fbdc310d">AudioNode#getRemaining()</a>, and this value is less than or equal to the overlap. It does not trigger if that method is not supported. In addition, if a node is forced to complete before the normal time remaining, the overlap will not apply.</p>
<p>The overlap should be chosen with care. If the play length of an audio node is less than the overlap, the results are undefined.</p>
<dl class="section return"><dt>Returns</dt><dd>the overlap time in seconds. </dd></dl>

</div>
</div>
<a id="a1217cd39c75961f07f44e6248790bca8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1217cd39c75961f07f44e6248790bca8">&#9670;&nbsp;</a></span>getPosition()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual Sint64 cugl::audio::AudioScheduler::getPosition </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns the current frame position of this audio node.</p>
<p>DELEGATED METHOD: This method delegates its call to the current audio node. It returns -1 if there is no active node or if this method is unsupported.</p>
<p>This method is thread safe, and may be called outside the audio thread. However, the accuracy of the result on a non-paused audio source is subject to minor race conditions (e.g. you may set the time, but have it forwarded by the next window size without reading). In addition, some streaming formats are less accurate than others.</p>
<dl class="section return"><dt>Returns</dt><dd>the current frame position of this audio node. </dd></dl>

<p>Reimplemented from <a class="el" href="classcugl_1_1audio_1_1_audio_node.html#afcaf44a791f1d914b129ac71d917ed94">cugl::audio::AudioNode</a>.</p>

</div>
</div>
<a id="a30f5595158325bc77ab78f515a9cc96f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a30f5595158325bc77ab78f515a9cc96f">&#9670;&nbsp;</a></span>getTail()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::deque&lt;std::shared_ptr&lt;<a class="el" href="classcugl_1_1audio_1_1_audio_node.html">AudioNode</a>&gt; &gt; cugl::audio::AudioScheduler::getTail </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns all audio nodes waiting to be played.</p>
<p>This method only returns the nodes. It does not return any loop information.</p>
<dl class="section return"><dt>Returns</dt><dd>all audio nodes waiting to be played. </dd></dl>

</div>
</div>
<a id="a2796bb6fa222fb0a9f33ea4b5abc745e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2796bb6fa222fb0a9f33ea4b5abc745e">&#9670;&nbsp;</a></span>getTailSize()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Uint32 cugl::audio::AudioScheduler::getTailSize </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns the number audio nodes waiting to be played.</p>
<p>The currently playing audio is not included.</p>
<dl class="section return"><dt>Returns</dt><dd>the number audio nodes waiting to be played. </dd></dl>

</div>
</div>
<a id="a4ca72d4096931f1dcb65aa3ef484428c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4ca72d4096931f1dcb65aa3ef484428c">&#9670;&nbsp;</a></span>init() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool cugl::audio::AudioScheduler::init </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Initializes the scheduler with default stereo settings</p>
<p>The number of channels is two, for stereo output. The sample rate is the modern standard of 48000 HZ.</p>
<p>These values determine the buffer the structure for all <a class="el" href="classcugl_1_1audio_1_1_audio_scheduler.html#aa1dd7275d0eecc17c91b1c92b5b0c7e5">read</a> operations. In addition, they also detemine whether this node can serve as an input to other nodes in the audio graph.</p>
<dl class="section return"><dt>Returns</dt><dd>true if initialization was successful </dd></dl>

<p>Reimplemented from <a class="el" href="classcugl_1_1audio_1_1_audio_node.html#a3e69463a0e8146f6913fd09a460eea65">cugl::audio::AudioNode</a>.</p>

</div>
</div>
<a id="ac30e4c5cc7af3695915f1efe451d4b93"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac30e4c5cc7af3695915f1efe451d4b93">&#9670;&nbsp;</a></span>init() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool cugl::audio::AudioScheduler::init </td>
          <td>(</td>
          <td class="paramtype">Uint8&#160;</td>
          <td class="paramname"><em>channels</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Uint32&#160;</td>
          <td class="paramname"><em>rate</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Initializes the scheduler with the given number of channels and sample rate</p>
<p>These values determine the buffer the structure for all <a class="el" href="classcugl_1_1audio_1_1_audio_scheduler.html#aa1dd7275d0eecc17c91b1c92b5b0c7e5">read</a> operations. In addition, they also detemine whether this node can serve as an input to other nodes in the audio graph.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">channels</td><td>The number of audio channels </td></tr>
    <tr><td class="paramname">rate</td><td>The sample rate (frequency) in HZ</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if initialization was successful </dd></dl>

<p>Reimplemented from <a class="el" href="classcugl_1_1audio_1_1_audio_node.html#a514cc5603392dad94cff72296256b2ec">cugl::audio::AudioNode</a>.</p>

</div>
</div>
<a id="a666050b4ba6f6e0bca03560deca9f296"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a666050b4ba6f6e0bca03560deca9f296">&#9670;&nbsp;</a></span>isPlaying()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool cugl::audio::AudioScheduler::isPlaying </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns true if the scheduler has an active audio node</p>
<p>This method only checks if there is a current active node. This method may return true even if the node is paused.</p>
<p>return true if the scheduler has an active audio node </p>

</div>
</div>
<a id="a506e67f8f1f6027a1cb376150a1c111a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a506e67f8f1f6027a1cb376150a1c111a">&#9670;&nbsp;</a></span>mark()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool cugl::audio::AudioScheduler::mark </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Marks the current read position in the audio steam.</p>
<p>DELEGATED METHOD: This method delegates its call to the current audio node. It returns false if there is no active node or if this method is unsupported.</p>
<p>Once this method is called, the scheduler will mark the current audio node and buffer all subsequent audio nodes. It will create a secondary queue to prevent these nodes from being released. A call to the method <a class="el" href="classcugl_1_1audio_1_1_audio_scheduler.html#acf84cf1a4583763b6c14a73d9ff390d1">reset()</a> will return to the marked position of the current audio node and replay all subsequent audio nodes before returning to the audio queue.</p>
<p>This secondary queue will continue accumulating audio nodes until <a class="el" href="classcugl_1_1audio_1_1_audio_scheduler.html#af40aaa286b71f51c6ecd9a95d56bb61b">unmark()</a> is called. It is not recommended for a marks to remain indefinitely.</p>
<dl class="section return"><dt>Returns</dt><dd>true if the read position was marked. </dd></dl>

<p>Reimplemented from <a class="el" href="classcugl_1_1audio_1_1_audio_node.html#a93a80b1ab4063f84d2fc26d7e47c32c3">cugl::audio::AudioNode</a>.</p>

</div>
</div>
<a id="a353680159f8622ee8ecb532eed18d56b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a353680159f8622ee8ecb532eed18d56b">&#9670;&nbsp;</a></span>play()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void cugl::audio::AudioScheduler::play </td>
          <td>(</td>
          <td class="paramtype">const std::shared_ptr&lt; <a class="el" href="classcugl_1_1audio_1_1_audio_node.html">AudioNode</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>node</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Sint32&#160;</td>
          <td class="paramname"><em>loop</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Immediately schedules a new audio node for playback.</p>
<p>This method clears the queue and immediately schedules the node for the next audio render frame.</p>
<p>This audio node may be any satisfying class, though it is typically an instance of <a class="el" href="classcugl_1_1audio_1_1_audio_player.html">AudioPlayer</a>. Gain control is handled in the node itself (though the scheduler can add extra gain). The only new feature added is looping.</p>
<p>The loop value is an integer. If it is 0, the audio node will not be looped. If it is positive, it will loop the audio that many (additional) times. If it is negative, the audio node will be looped indefinitely until it is stopped.</p>
<p>If the user has provided an optional callback function, this will be called when the node is removed, either because it completed (defined by <a class="el" href="classcugl_1_1audio_1_1_audio_node.html#a891ba93a6189f353c4b6fa893819001f">AudioNode#completed()</a>) or is interrupted.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">node</td><td>The audio node for playback </td></tr>
    <tr><td class="paramname">loop</td><td>The number of times to loop the audio </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aa1dd7275d0eecc17c91b1c92b5b0c7e5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa1dd7275d0eecc17c91b1c92b5b0c7e5">&#9670;&nbsp;</a></span>read()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual Uint32 cugl::audio::AudioScheduler::read </td>
          <td>(</td>
          <td class="paramtype">float *&#160;</td>
          <td class="paramname"><em>buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Uint32&#160;</td>
          <td class="paramname"><em>frames</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Reads up to the specified number of frames into the given buffer</p>
<p>AUDIO THREAD ONLY: Users should never access this method directly. The only exception is when the user needs to create a custom subclass of this <a class="el" href="classcugl_1_1audio_1_1_audio_node.html">AudioNode</a>.</p>
<p>The buffer should have enough room to store frames * channels elements. The channels are interleaved into the output buffer.</p>
<p>This method will always forward the read position after reading. Reading again may return different data.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">buffer</td><td>The read buffer to store the results </td></tr>
    <tr><td class="paramname">frames</td><td>The maximum number of frames to read</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the actual number of frames read </dd></dl>

<p>Reimplemented from <a class="el" href="classcugl_1_1audio_1_1_audio_node.html#ad5c565e6fdf9ad91d7d9fbe2403eaab0">cugl::audio::AudioNode</a>.</p>

</div>
</div>
<a id="acf84cf1a4583763b6c14a73d9ff390d1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acf84cf1a4583763b6c14a73d9ff390d1">&#9670;&nbsp;</a></span>reset()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool cugl::audio::AudioScheduler::reset </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Resets the read position to the marked position of the audio stream.</p>
<p>DELEGATED METHOD: This method delegates its call to the current audio node. It returns false if there is no active node or if this method is unsupported.</p>
<p>This method returns the playback to the audio node and position set by a call to <a class="el" href="classcugl_1_1audio_1_1_audio_scheduler.html#a506e67f8f1f6027a1cb376150a1c111a">mark()</a>. If mark has not been called, this method has no effect.</p>
<dl class="section return"><dt>Returns</dt><dd>true if the read position was moved. </dd></dl>

<p>Reimplemented from <a class="el" href="classcugl_1_1audio_1_1_audio_node.html#a77780ab5151b4af69bddf55ed288ed3a">cugl::audio::AudioNode</a>.</p>

</div>
</div>
<a id="aba5c1ea00ad8b3a540b7afaba75f6303"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aba5c1ea00ad8b3a540b7afaba75f6303">&#9670;&nbsp;</a></span>setElapsed()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual double cugl::audio::AudioScheduler::setElapsed </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>time</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Sets the read position to the elapsed time in seconds.</p>
<p>DELEGATED METHOD: This method delegates its call to the current audio node. It returns -1 if there is no active node or if this method is unsupported.</p>
<p>This method has no effect unless <a class="el" href="classcugl_1_1audio_1_1_audio_scheduler.html#a506e67f8f1f6027a1cb376150a1c111a">mark()</a> is called. All time is relative from the marked position.</p>
<p>If the time is set beyond the bounds of the current node, the outcome will depend on the state of the audio queue. A looped node will simply loop the elapsed time. Otherwise, if this position causes the audio node to complete, it will continue to advance through the queue so long as this method (and <a class="el" href="classcugl_1_1audio_1_1_audio_node.html#a891ba93a6189f353c4b6fa893819001f">completed()</a>) is supported.</p>
<p>This method is thread safe, and may be called outside the audio thread. However, the accuracy of the result on a non-paused audio source is subject to minor race conditions (e.g. you may set the time, but have it forwarded by the next window size without reading). In addition, some streaming formats are less accurate than others.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">time</td><td>The elapsed time in seconds.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the new elapsed time in seconds. </dd></dl>

<p>Reimplemented from <a class="el" href="classcugl_1_1audio_1_1_audio_node.html#ab4d0cc9e5905ec34157b20df5ebe9980">cugl::audio::AudioNode</a>.</p>

</div>
</div>
<a id="a0e12cf61b267caa77cbb9cd20955b686"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0e12cf61b267caa77cbb9cd20955b686">&#9670;&nbsp;</a></span>setLoops()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void cugl::audio::AudioScheduler::setLoops </td>
          <td>(</td>
          <td class="paramtype">Sint32&#160;</td>
          <td class="paramname"><em>loop</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Sets number of loops remaining for the active audio node.</p>
<p>If the value is 0, then the audio node will be removed from the queue when it completes (as defined by <a class="el" href="classcugl_1_1audio_1_1_audio_node.html#a891ba93a6189f353c4b6fa893819001f">AudioNode#completed()</a>. A value greater than 0 will repeat that many times, assuming that the method <a class="el" href="classcugl_1_1audio_1_1_audio_node.html#a77780ab5151b4af69bddf55ed288ed3a">AudioNode#reset()</a> is implemented (a node that cannot be reset cannot be looped). Finally, a negative value will be played indefinitely, unless it is stopped or or the loop count is changed.</p>
<p>This method does nothing if there is no active audio node.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">loop</td><td>The number of times to loop the audio </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a3d56e326086c334697bf83438c2c5781"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3d56e326086c334697bf83438c2c5781">&#9670;&nbsp;</a></span>setOverlap()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void cugl::audio::AudioScheduler::setOverlap </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>time</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Sets the overlap time in seconds.</p>
<p>The overlap time is the amount of time to cross-fade between a node on the queue and the next. It does not apply to looped nodes; nodes can never cross-fade with themselves.</p>
<p>The cross-fade is triggered when a node implements the method <a class="el" href="classcugl_1_1audio_1_1_audio_node.html#a715678edba83d3c178469fe4fbdc310d">AudioNode#getRemaining()</a>, and this value is less than or equal to the overlap. It does not trigger if that method is not supported. In addition, if a node is forced to complete before the normal time remaining, the overlap will not apply.</p>
<p>The overlap should be chosen with care. If the play length of an audio node is less than the overlap, the results are undefined.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">time</td><td>The overlap time in seconds. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a79822765daf0103a86e0cd5e82ae45e9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a79822765daf0103a86e0cd5e82ae45e9">&#9670;&nbsp;</a></span>setPosition()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual Sint64 cugl::audio::AudioScheduler::setPosition </td>
          <td>(</td>
          <td class="paramtype">Uint32&#160;</td>
          <td class="paramname"><em>position</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Sets the current frame position of this audio node.</p>
<p>DELEGATED METHOD: This method delegates its call to the current audio node. It returns -1 if there is no active node or if this method is unsupported.</p>
<p>This method has no effect unless <a class="el" href="classcugl_1_1audio_1_1_audio_scheduler.html#a506e67f8f1f6027a1cb376150a1c111a">mark()</a> is called. All frame positions are relative from the marked position.</p>
<p>If the number of frames is set beyond the bounds of the current node, the outcome will depend on the state of the audio queue. A looped node will simply loop the given number of frames. Otherwise, if this position causes the audio node to complete, it will continue to advance through the queue so long as this method (and <a class="el" href="classcugl_1_1audio_1_1_audio_node.html#a891ba93a6189f353c4b6fa893819001f">completed()</a>) is supported.</p>
<p>This method is thread safe, and may be called outside the audio thread. However, the accuracy of the result on a non-paused audio source is subject to minor race conditions (e.g. you may set the time, but have it forwarded by the next window size without reading). In addition, some streaming formats are less accurate than others.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">position</td><td>the current frame position of this audio node.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the new frame position of this audio node. </dd></dl>

<p>Reimplemented from <a class="el" href="classcugl_1_1audio_1_1_audio_node.html#a2610a829200cb361388e2cd88e2a63d1">cugl::audio::AudioNode</a>.</p>

</div>
</div>
<a id="ac8feb43812b9a09873280edf46cf1047"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac8feb43812b9a09873280edf46cf1047">&#9670;&nbsp;</a></span>skip()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void cugl::audio::AudioScheduler::skip </td>
          <td>(</td>
          <td class="paramtype">Uint32&#160;</td>
          <td class="paramname"><em>n</em> = <code>0</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Skips forward to a future nodes in the queue.</p>
<p>The optional parameter n specifies the number of additional nodes to skip. If n is 0, it will just go the front element of the queue. Otherwise, it will skip to the n element after the head of the queue. If n is larger than the size of the queue, this is the same as <a class="el" href="classcugl_1_1audio_1_1_audio_scheduler.html#ab739e4385d3ecc9fb22a56b8ae5483e0">clear()</a>.</p>
<p>If the user has provided an optional callback function, this will be called for all of the nodes removed from the queue (as well as the current sound). The complete flag will be false, indicating that they were interrupted. </p>

</div>
</div>
<a id="ad5542008730767df3c16d7b132ed7740"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad5542008730767df3c16d7b132ed7740">&#9670;&nbsp;</a></span>trim()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void cugl::audio::AudioScheduler::trim </td>
          <td>(</td>
          <td class="paramtype">Sint32&#160;</td>
          <td class="paramname"><em>size</em> = <code>-1</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Empties the queue without stopping the current playback.</p>
<p>This method is useful when we want to clear the queue, but to smoothly fade-out the current playback. </p>

</div>
</div>
<a id="af40aaa286b71f51c6ecd9a95d56bb61b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af40aaa286b71f51c6ecd9a95d56bb61b">&#9670;&nbsp;</a></span>unmark()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool cugl::audio::AudioScheduler::unmark </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Clears the current marked position.</p>
<p>The method <a class="el" href="classcugl_1_1audio_1_1_audio_scheduler.html#a506e67f8f1f6027a1cb376150a1c111a">mark()</a> creates a second queue for buffering audio. This queue will continue accumulating audio nodes until this method is called.</p>
<p>This method has no effect if there is no current mark.</p>
<dl class="section return"><dt>Returns</dt><dd>true if the read position was cleared. </dd></dl>

<p>Reimplemented from <a class="el" href="classcugl_1_1audio_1_1_audio_node.html#acd6e08392fac32fce3f2ef0c76a71f70">cugl::audio::AudioNode</a>.</p>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>include/cugl/audio/graph/<a class="el" href="_c_u_audio_scheduler_8h_source.html">CUAudioScheduler.h</a></li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.1
</small></address>
</body>
</html>
