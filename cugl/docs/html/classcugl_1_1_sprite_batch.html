<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.9.1"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>CUGL 2.0: cugl::SpriteBatch Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">CUGL 2.0
   </div>
   <div id="projectbrief">Cornell University Game Library</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.1 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search','.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespacecugl.html">cugl</a></li><li class="navelem"><a class="el" href="classcugl_1_1_sprite_batch.html">SpriteBatch</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-static-methods">Static Public Member Functions</a> &#124;
<a href="classcugl_1_1_sprite_batch-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">cugl::SpriteBatch Class Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p><code>#include &lt;<a class="el" href="_c_u_sprite_batch_8h_source.html">CUSpriteBatch.h</a>&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:acd2b8d2c9ab34b5c03f32019d1f6872b"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1_sprite_batch.html#acd2b8d2c9ab34b5c03f32019d1f6872b">SpriteBatch</a> ()</td></tr>
<tr class="separator:acd2b8d2c9ab34b5c03f32019d1f6872b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae9a3434a113d7eadc5ce10194fa6d4b1"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1_sprite_batch.html#ae9a3434a113d7eadc5ce10194fa6d4b1">~SpriteBatch</a> ()</td></tr>
<tr class="separator:ae9a3434a113d7eadc5ce10194fa6d4b1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a241abb9a7e9c1f3d06a6a0b519ce56cf"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1_sprite_batch.html#a241abb9a7e9c1f3d06a6a0b519ce56cf">dispose</a> ()</td></tr>
<tr class="separator:a241abb9a7e9c1f3d06a6a0b519ce56cf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5370fa1d9e46913ae2845173231481f9"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1_sprite_batch.html#a5370fa1d9e46913ae2845173231481f9">init</a> ()</td></tr>
<tr class="separator:a5370fa1d9e46913ae2845173231481f9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a72a8f45ef09781f145752cb9b60b444b"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1_sprite_batch.html#a72a8f45ef09781f145752cb9b60b444b">init</a> (const std::shared_ptr&lt; <a class="el" href="classcugl_1_1_shader.html">Shader</a> &gt; &amp;shader)</td></tr>
<tr class="separator:a72a8f45ef09781f145752cb9b60b444b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac14e11a9542a2524a16d50ead5d67c31"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1_sprite_batch.html#ac14e11a9542a2524a16d50ead5d67c31">init</a> (unsigned int capacity)</td></tr>
<tr class="separator:ac14e11a9542a2524a16d50ead5d67c31"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a37d87c1dfb92d15463e9152c8438ed71"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1_sprite_batch.html#a37d87c1dfb92d15463e9152c8438ed71">init</a> (unsigned int capacity, const std::shared_ptr&lt; <a class="el" href="classcugl_1_1_shader.html">Shader</a> &gt; &amp;shader)</td></tr>
<tr class="separator:a37d87c1dfb92d15463e9152c8438ed71"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4a8f3118b1f150366871ba5ce01be4d7"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1_sprite_batch.html#a4a8f3118b1f150366871ba5ce01be4d7">isReady</a> () const</td></tr>
<tr class="separator:a4a8f3118b1f150366871ba5ce01be4d7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7a9481417eff55b2916d3a6b7bfa4695"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1_sprite_batch.html#a7a9481417eff55b2916d3a6b7bfa4695">isDrawing</a> () const</td></tr>
<tr class="separator:a7a9481417eff55b2916d3a6b7bfa4695"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2ccb078d512f27346c1f6cf7a1886508"><td class="memItemLeft" align="right" valign="top">unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1_sprite_batch.html#a2ccb078d512f27346c1f6cf7a1886508">getVerticesDrawn</a> () const</td></tr>
<tr class="separator:a2ccb078d512f27346c1f6cf7a1886508"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7939e483780df6fc49f8567896408ab7"><td class="memItemLeft" align="right" valign="top">unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1_sprite_batch.html#a7939e483780df6fc49f8567896408ab7">getCallsMade</a> () const</td></tr>
<tr class="separator:a7939e483780df6fc49f8567896408ab7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a12742b5bd9a4536e33d239db9255d4b5"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1_sprite_batch.html#a12742b5bd9a4536e33d239db9255d4b5">setShader</a> (const std::shared_ptr&lt; <a class="el" href="classcugl_1_1_shader.html">Shader</a> &gt; &amp;shader)</td></tr>
<tr class="separator:a12742b5bd9a4536e33d239db9255d4b5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a13675f4d638c0f35d840ae3ea273988d"><td class="memItemLeft" align="right" valign="top">const std::shared_ptr&lt; <a class="el" href="classcugl_1_1_shader.html">Shader</a> &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1_sprite_batch.html#a13675f4d638c0f35d840ae3ea273988d">getShader</a> () const</td></tr>
<tr class="separator:a13675f4d638c0f35d840ae3ea273988d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5b2156df91bce4fcf1dfbcdee8d15148"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1_sprite_batch.html#a5b2156df91bce4fcf1dfbcdee8d15148">setColor</a> (const <a class="el" href="classcugl_1_1_color4f.html">Color4f</a> color)</td></tr>
<tr class="separator:a5b2156df91bce4fcf1dfbcdee8d15148"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac7c525abd47a4979221a0de722f812f9"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classcugl_1_1_color4f.html">Color4f</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1_sprite_batch.html#ac7c525abd47a4979221a0de722f812f9">getColor</a> () const</td></tr>
<tr class="separator:ac7c525abd47a4979221a0de722f812f9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a223ec040a1ea222e00ad113168bee32f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1_sprite_batch.html#a223ec040a1ea222e00ad113168bee32f">setPerspective</a> (const <a class="el" href="classcugl_1_1_mat4.html">Mat4</a> &amp;perspective)</td></tr>
<tr class="separator:a223ec040a1ea222e00ad113168bee32f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4e1f897aa822536533115f2255cdbf0b"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classcugl_1_1_mat4.html">Mat4</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1_sprite_batch.html#a4e1f897aa822536533115f2255cdbf0b">getPerspective</a> () const</td></tr>
<tr class="separator:a4e1f897aa822536533115f2255cdbf0b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4dec0c947f5bbbe0a63eefeb3456ab04"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1_sprite_batch.html#a4dec0c947f5bbbe0a63eefeb3456ab04">setTexture</a> (const std::shared_ptr&lt; <a class="el" href="classcugl_1_1_texture.html">Texture</a> &gt; &amp;texture)</td></tr>
<tr class="separator:a4dec0c947f5bbbe0a63eefeb3456ab04"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad635085d9d5a04c94ecc894a51d77385"><td class="memItemLeft" align="right" valign="top">const std::shared_ptr&lt; <a class="el" href="classcugl_1_1_texture.html">Texture</a> &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1_sprite_batch.html#ad635085d9d5a04c94ecc894a51d77385">getTexture</a> () const</td></tr>
<tr class="separator:ad635085d9d5a04c94ecc894a51d77385"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa1e48a524829cf2679ce6f2290d9691c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1_sprite_batch.html#aa1e48a524829cf2679ce6f2290d9691c">setGradient</a> (const std::shared_ptr&lt; <a class="el" href="classcugl_1_1_gradient.html">Gradient</a> &gt; &amp;gradient)</td></tr>
<tr class="separator:aa1e48a524829cf2679ce6f2290d9691c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a80fc0d03c6d4c7091fdbfe20f9e666ea"><td class="memItemLeft" align="right" valign="top">std::shared_ptr&lt; <a class="el" href="classcugl_1_1_gradient.html">Gradient</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1_sprite_batch.html#a80fc0d03c6d4c7091fdbfe20f9e666ea">getGradient</a> () const</td></tr>
<tr class="separator:a80fc0d03c6d4c7091fdbfe20f9e666ea"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acdd0523479adc622d52093297d0f030b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1_sprite_batch.html#acdd0523479adc622d52093297d0f030b">setScissor</a> (const std::shared_ptr&lt; <a class="el" href="classcugl_1_1_scissor.html">Scissor</a> &gt; &amp;scissor)</td></tr>
<tr class="separator:acdd0523479adc622d52093297d0f030b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afd812d1b07452383e161cbfef22cfb6e"><td class="memItemLeft" align="right" valign="top">std::shared_ptr&lt; <a class="el" href="classcugl_1_1_scissor.html">Scissor</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1_sprite_batch.html#afd812d1b07452383e161cbfef22cfb6e">getScissor</a> () const</td></tr>
<tr class="separator:afd812d1b07452383e161cbfef22cfb6e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3c1eb99b5196d5dbff63c0bba1fd6f5e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1_sprite_batch.html#a3c1eb99b5196d5dbff63c0bba1fd6f5e">setBlendFunc</a> (GLenum srcFactor, GLenum dstFactor)</td></tr>
<tr class="separator:a3c1eb99b5196d5dbff63c0bba1fd6f5e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aef0bcfe75ec48b57641cc6316f2a1887"><td class="memItemLeft" align="right" valign="top">GLenum&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1_sprite_batch.html#aef0bcfe75ec48b57641cc6316f2a1887">getSourceBlendFactor</a> () const</td></tr>
<tr class="separator:aef0bcfe75ec48b57641cc6316f2a1887"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa8023e5960915cbff51f07c1c4b8ab3c"><td class="memItemLeft" align="right" valign="top">GLenum&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1_sprite_batch.html#aa8023e5960915cbff51f07c1c4b8ab3c">getDestinationBlendFactor</a> () const</td></tr>
<tr class="separator:aa8023e5960915cbff51f07c1c4b8ab3c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac0113bb43b31702ad5a0cd2817db6938"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1_sprite_batch.html#ac0113bb43b31702ad5a0cd2817db6938">setBlendEquation</a> (GLenum equation)</td></tr>
<tr class="separator:ac0113bb43b31702ad5a0cd2817db6938"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaa55a44f97f484e1f392d3575e81bd30"><td class="memItemLeft" align="right" valign="top">GLenum&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1_sprite_batch.html#aaa55a44f97f484e1f392d3575e81bd30">getBlendEquation</a> () const</td></tr>
<tr class="separator:aaa55a44f97f484e1f392d3575e81bd30"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aae8122c3968b8b467829b1f4d608119c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1_sprite_batch.html#aae8122c3968b8b467829b1f4d608119c">setDepthFunc</a> (GLenum function)</td></tr>
<tr class="separator:aae8122c3968b8b467829b1f4d608119c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aecd4f422594c13b12abeb9b50289c920"><td class="memItemLeft" align="right" valign="top">GLenum&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1_sprite_batch.html#aecd4f422594c13b12abeb9b50289c920">getDepthFunc</a> () const</td></tr>
<tr class="separator:aecd4f422594c13b12abeb9b50289c920"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9a26ee7729cb03c643b79bdea85eb721"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1_sprite_batch.html#a9a26ee7729cb03c643b79bdea85eb721">setDepth</a> (float depth)</td></tr>
<tr class="separator:a9a26ee7729cb03c643b79bdea85eb721"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae98c4f47f5309c06f98b78007dff0c8d"><td class="memItemLeft" align="right" valign="top">float&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1_sprite_batch.html#ae98c4f47f5309c06f98b78007dff0c8d">getDepth</a> () const</td></tr>
<tr class="separator:ae98c4f47f5309c06f98b78007dff0c8d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ace282bea0b90c0a37780da66f2cfd593"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1_sprite_batch.html#ace282bea0b90c0a37780da66f2cfd593">setBlurStep</a> (GLuint step)</td></tr>
<tr class="separator:ace282bea0b90c0a37780da66f2cfd593"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a97e3cf5929abccb46cfaacaeb02a2a83"><td class="memItemLeft" align="right" valign="top">GLuint&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1_sprite_batch.html#a97e3cf5929abccb46cfaacaeb02a2a83">getBlurStep</a> () const</td></tr>
<tr class="separator:a97e3cf5929abccb46cfaacaeb02a2a83"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a631a3759f253a59c79000f0736792dcf"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1_sprite_batch.html#a631a3759f253a59c79000f0736792dcf">begin</a> ()</td></tr>
<tr class="separator:a631a3759f253a59c79000f0736792dcf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af57f31767c1e3dd4c1bda07a01348aca"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1_sprite_batch.html#af57f31767c1e3dd4c1bda07a01348aca">begin</a> (const <a class="el" href="classcugl_1_1_mat4.html">Mat4</a> &amp;perspective)</td></tr>
<tr class="separator:af57f31767c1e3dd4c1bda07a01348aca"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa19d39209e70a6be006c2371de0c63a1"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1_sprite_batch.html#aa19d39209e70a6be006c2371de0c63a1">end</a> ()</td></tr>
<tr class="separator:aa19d39209e70a6be006c2371de0c63a1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad4865921fb83cef24981dba2c1799934"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1_sprite_batch.html#ad4865921fb83cef24981dba2c1799934">flush</a> ()</td></tr>
<tr class="separator:ad4865921fb83cef24981dba2c1799934"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abdd11c656e840789ab480139cf2a2069"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1_sprite_batch.html#abdd11c656e840789ab480139cf2a2069">fill</a> (<a class="el" href="classcugl_1_1_rect.html">Rect</a> rect)</td></tr>
<tr class="separator:abdd11c656e840789ab480139cf2a2069"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a95e4e47a8cb66d188ca49553d4696fad"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1_sprite_batch.html#a95e4e47a8cb66d188ca49553d4696fad">fill</a> (const <a class="el" href="classcugl_1_1_rect.html">Rect</a> rect, const <a class="el" href="classcugl_1_1_vec2.html">Vec2</a> offset)</td></tr>
<tr class="separator:a95e4e47a8cb66d188ca49553d4696fad"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae2ff2006ee69e3a5f63976582fec8f38"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1_sprite_batch.html#ae2ff2006ee69e3a5f63976582fec8f38">fill</a> (const <a class="el" href="classcugl_1_1_rect.html">Rect</a> rect, const <a class="el" href="classcugl_1_1_vec2.html">Vec2</a> origin, const <a class="el" href="classcugl_1_1_vec2.html">Vec2</a> scale, float angle, const <a class="el" href="classcugl_1_1_vec2.html">Vec2</a> offset)</td></tr>
<tr class="separator:ae2ff2006ee69e3a5f63976582fec8f38"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a06c5090bd9377a0b48b265b1d42bab96"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1_sprite_batch.html#a06c5090bd9377a0b48b265b1d42bab96">fill</a> (const <a class="el" href="classcugl_1_1_rect.html">Rect</a> rect, const <a class="el" href="classcugl_1_1_vec2.html">Vec2</a> origin, const <a class="el" href="classcugl_1_1_mat4.html">Mat4</a> &amp;transform)</td></tr>
<tr class="separator:a06c5090bd9377a0b48b265b1d42bab96"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa29b9d75dd9fbc971eeef37b4d5bafc5"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1_sprite_batch.html#aa29b9d75dd9fbc971eeef37b4d5bafc5">fill</a> (const <a class="el" href="classcugl_1_1_poly2.html">Poly2</a> &amp;poly)</td></tr>
<tr class="separator:aa29b9d75dd9fbc971eeef37b4d5bafc5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0d9f7ee60fade972db0575ed3005e1f9"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1_sprite_batch.html#a0d9f7ee60fade972db0575ed3005e1f9">fill</a> (const <a class="el" href="classcugl_1_1_poly2.html">Poly2</a> &amp;poly, const <a class="el" href="classcugl_1_1_vec2.html">Vec2</a> offset)</td></tr>
<tr class="separator:a0d9f7ee60fade972db0575ed3005e1f9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4abfc7ac4c0742684b105afd3611b304"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1_sprite_batch.html#a4abfc7ac4c0742684b105afd3611b304">fill</a> (const <a class="el" href="classcugl_1_1_poly2.html">Poly2</a> &amp;poly, const <a class="el" href="classcugl_1_1_vec2.html">Vec2</a> origin, const <a class="el" href="classcugl_1_1_vec2.html">Vec2</a> scale, float angle, const <a class="el" href="classcugl_1_1_vec2.html">Vec2</a> offset)</td></tr>
<tr class="separator:a4abfc7ac4c0742684b105afd3611b304"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a54b0b437487a095cf42c9804777ad2bc"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1_sprite_batch.html#a54b0b437487a095cf42c9804777ad2bc">fill</a> (const <a class="el" href="classcugl_1_1_poly2.html">Poly2</a> &amp;poly, const <a class="el" href="classcugl_1_1_vec2.html">Vec2</a> origin, const <a class="el" href="classcugl_1_1_mat4.html">Mat4</a> &amp;transform)</td></tr>
<tr class="separator:a54b0b437487a095cf42c9804777ad2bc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af107824ef2b801505d0f5e9ed1d74481"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1_sprite_batch.html#af107824ef2b801505d0f5e9ed1d74481">fill</a> (const <a class="el" href="classcugl_1_1_mesh.html">Mesh</a>&lt; <a class="el" href="classcugl_1_1_sprite_vertex2.html">SpriteVertex2</a> &gt; &amp;mesh, const <a class="el" href="classcugl_1_1_mat4.html">Mat4</a> &amp;transform, bool tint=true)</td></tr>
<tr class="separator:af107824ef2b801505d0f5e9ed1d74481"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a21e16d3ccc3af8d8423406403e81e5e1"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1_sprite_batch.html#a21e16d3ccc3af8d8423406403e81e5e1">fill</a> (const <a class="el" href="classcugl_1_1_mesh.html">Mesh</a>&lt; <a class="el" href="classcugl_1_1_sprite_vertex3.html">SpriteVertex3</a> &gt; &amp;mesh, const <a class="el" href="classcugl_1_1_mat4.html">Mat4</a> &amp;transform, bool tint=true)</td></tr>
<tr class="separator:a21e16d3ccc3af8d8423406403e81e5e1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa5037e3fcab54229cb4126d505e3c08d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1_sprite_batch.html#aa5037e3fcab54229cb4126d505e3c08d">outline</a> (const <a class="el" href="classcugl_1_1_rect.html">Rect</a> rect)</td></tr>
<tr class="separator:aa5037e3fcab54229cb4126d505e3c08d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0c479285bf7da3b90f2d68e3831f5d7b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1_sprite_batch.html#a0c479285bf7da3b90f2d68e3831f5d7b">outline</a> (const <a class="el" href="classcugl_1_1_rect.html">Rect</a> rect, const <a class="el" href="classcugl_1_1_vec2.html">Vec2</a> offset)</td></tr>
<tr class="separator:a0c479285bf7da3b90f2d68e3831f5d7b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a96948ca8110e3cfde4831d79c72227cf"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1_sprite_batch.html#a96948ca8110e3cfde4831d79c72227cf">outline</a> (const <a class="el" href="classcugl_1_1_rect.html">Rect</a> rect, const <a class="el" href="classcugl_1_1_vec2.html">Vec2</a> origin, const <a class="el" href="classcugl_1_1_vec2.html">Vec2</a> scale, float angle, const <a class="el" href="classcugl_1_1_vec2.html">Vec2</a> offset)</td></tr>
<tr class="separator:a96948ca8110e3cfde4831d79c72227cf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1bf0fcb14c014433e03e4eb6570641bd"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1_sprite_batch.html#a1bf0fcb14c014433e03e4eb6570641bd">outline</a> (const <a class="el" href="classcugl_1_1_rect.html">Rect</a> rect, const <a class="el" href="classcugl_1_1_vec2.html">Vec2</a> origin, const <a class="el" href="classcugl_1_1_mat4.html">Mat4</a> &amp;transform)</td></tr>
<tr class="separator:a1bf0fcb14c014433e03e4eb6570641bd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2f40e476e271b1b77649584f3e220393"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1_sprite_batch.html#a2f40e476e271b1b77649584f3e220393">outline</a> (const <a class="el" href="classcugl_1_1_poly2.html">Poly2</a> &amp;poly)</td></tr>
<tr class="separator:a2f40e476e271b1b77649584f3e220393"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a71c8e126ff7005b894c1605d50f700ff"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1_sprite_batch.html#a71c8e126ff7005b894c1605d50f700ff">outline</a> (const <a class="el" href="classcugl_1_1_poly2.html">Poly2</a> &amp;poly, const <a class="el" href="classcugl_1_1_vec2.html">Vec2</a> offset)</td></tr>
<tr class="separator:a71c8e126ff7005b894c1605d50f700ff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2e4934be576d47f250f682cbd3958631"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1_sprite_batch.html#a2e4934be576d47f250f682cbd3958631">outline</a> (const <a class="el" href="classcugl_1_1_poly2.html">Poly2</a> &amp;poly, const <a class="el" href="classcugl_1_1_vec2.html">Vec2</a> origin, const <a class="el" href="classcugl_1_1_vec2.html">Vec2</a> scale, float angle, const <a class="el" href="classcugl_1_1_vec2.html">Vec2</a> offset)</td></tr>
<tr class="separator:a2e4934be576d47f250f682cbd3958631"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7a4903a85f26ebcd87fe51947ccbbf31"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1_sprite_batch.html#a7a4903a85f26ebcd87fe51947ccbbf31">outline</a> (const <a class="el" href="classcugl_1_1_poly2.html">Poly2</a> &amp;poly, const <a class="el" href="classcugl_1_1_vec2.html">Vec2</a> origin, const <a class="el" href="classcugl_1_1_mat4.html">Mat4</a> &amp;transform)</td></tr>
<tr class="separator:a7a4903a85f26ebcd87fe51947ccbbf31"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a824550d9feb56f7c9440a0d92621ac96"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1_sprite_batch.html#a824550d9feb56f7c9440a0d92621ac96">outline</a> (const <a class="el" href="classcugl_1_1_mesh.html">Mesh</a>&lt; <a class="el" href="classcugl_1_1_sprite_vertex2.html">SpriteVertex2</a> &gt; &amp;mesh, const <a class="el" href="classcugl_1_1_mat4.html">Mat4</a> &amp;transform, bool tint=true)</td></tr>
<tr class="separator:a824550d9feb56f7c9440a0d92621ac96"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a095740cad8cb02821fc291647cc6a948"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1_sprite_batch.html#a095740cad8cb02821fc291647cc6a948">outline</a> (const <a class="el" href="classcugl_1_1_mesh.html">Mesh</a>&lt; <a class="el" href="classcugl_1_1_sprite_vertex3.html">SpriteVertex3</a> &gt; &amp;mesh, const <a class="el" href="classcugl_1_1_mat4.html">Mat4</a> &amp;transform, bool tint=true)</td></tr>
<tr class="separator:a095740cad8cb02821fc291647cc6a948"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8e6485358863058537ce1b61cbb6b994"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1_sprite_batch.html#a8e6485358863058537ce1b61cbb6b994">draw</a> (const std::shared_ptr&lt; <a class="el" href="classcugl_1_1_texture.html">Texture</a> &gt; &amp;texture, const <a class="el" href="classcugl_1_1_vec2.html">Vec2</a> position)</td></tr>
<tr class="separator:a8e6485358863058537ce1b61cbb6b994"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aac0563cb6e5b9abdff42da87a71d518b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1_sprite_batch.html#aac0563cb6e5b9abdff42da87a71d518b">draw</a> (const std::shared_ptr&lt; <a class="el" href="classcugl_1_1_texture.html">Texture</a> &gt; &amp;texture, const <a class="el" href="classcugl_1_1_color4f.html">Color4f</a> color, const <a class="el" href="classcugl_1_1_vec2.html">Vec2</a> position)</td></tr>
<tr class="separator:aac0563cb6e5b9abdff42da87a71d518b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a732ca7b7c06a917c372deb860037888e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1_sprite_batch.html#a732ca7b7c06a917c372deb860037888e">draw</a> (const std::shared_ptr&lt; <a class="el" href="classcugl_1_1_texture.html">Texture</a> &gt; &amp;texture, const <a class="el" href="classcugl_1_1_rect.html">Rect</a> bounds)</td></tr>
<tr class="separator:a732ca7b7c06a917c372deb860037888e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a48f55c01e3ce12800c33d02442cb2ff3"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1_sprite_batch.html#a48f55c01e3ce12800c33d02442cb2ff3">draw</a> (const std::shared_ptr&lt; <a class="el" href="classcugl_1_1_texture.html">Texture</a> &gt; &amp;texture, const <a class="el" href="classcugl_1_1_color4f.html">Color4f</a> color, const <a class="el" href="classcugl_1_1_rect.html">Rect</a> bounds)</td></tr>
<tr class="separator:a48f55c01e3ce12800c33d02442cb2ff3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0cb5b3390ce9988303753ee398fbdb30"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1_sprite_batch.html#a0cb5b3390ce9988303753ee398fbdb30">draw</a> (const std::shared_ptr&lt; <a class="el" href="classcugl_1_1_texture.html">Texture</a> &gt; &amp;texture, const <a class="el" href="classcugl_1_1_vec2.html">Vec2</a> origin, const <a class="el" href="classcugl_1_1_vec2.html">Vec2</a> scale, float angle, const <a class="el" href="classcugl_1_1_vec2.html">Vec2</a> offset)</td></tr>
<tr class="separator:a0cb5b3390ce9988303753ee398fbdb30"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8d90915ecbe445b31337d8dc5f508b64"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1_sprite_batch.html#a8d90915ecbe445b31337d8dc5f508b64">draw</a> (const std::shared_ptr&lt; <a class="el" href="classcugl_1_1_texture.html">Texture</a> &gt; &amp;texture, const <a class="el" href="classcugl_1_1_color4f.html">Color4f</a> color, const <a class="el" href="classcugl_1_1_vec2.html">Vec2</a> origin, const <a class="el" href="classcugl_1_1_vec2.html">Vec2</a> scale, float angle, const <a class="el" href="classcugl_1_1_vec2.html">Vec2</a> offset)</td></tr>
<tr class="separator:a8d90915ecbe445b31337d8dc5f508b64"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a46c148faf961ac88ae619dd1bbd9874e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1_sprite_batch.html#a46c148faf961ac88ae619dd1bbd9874e">draw</a> (const std::shared_ptr&lt; <a class="el" href="classcugl_1_1_texture.html">Texture</a> &gt; &amp;texture, const <a class="el" href="classcugl_1_1_rect.html">Rect</a> bounds, const <a class="el" href="classcugl_1_1_vec2.html">Vec2</a> origin, const <a class="el" href="classcugl_1_1_vec2.html">Vec2</a> scale, float angle, const <a class="el" href="classcugl_1_1_vec2.html">Vec2</a> offset)</td></tr>
<tr class="separator:a46c148faf961ac88ae619dd1bbd9874e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae6bd1c0f794dcd7d08135efe67976ad5"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1_sprite_batch.html#ae6bd1c0f794dcd7d08135efe67976ad5">draw</a> (const std::shared_ptr&lt; <a class="el" href="classcugl_1_1_texture.html">Texture</a> &gt; &amp;texture, const <a class="el" href="classcugl_1_1_color4f.html">Color4f</a> color, const <a class="el" href="classcugl_1_1_rect.html">Rect</a> bounds, const <a class="el" href="classcugl_1_1_vec2.html">Vec2</a> origin, const <a class="el" href="classcugl_1_1_vec2.html">Vec2</a> scale, float angle, const <a class="el" href="classcugl_1_1_vec2.html">Vec2</a> offset)</td></tr>
<tr class="separator:ae6bd1c0f794dcd7d08135efe67976ad5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5e8f72cf2562e3d6ba906edda20469d1"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1_sprite_batch.html#a5e8f72cf2562e3d6ba906edda20469d1">draw</a> (const std::shared_ptr&lt; <a class="el" href="classcugl_1_1_texture.html">Texture</a> &gt; &amp;texture, const <a class="el" href="classcugl_1_1_vec2.html">Vec2</a> origin, const <a class="el" href="classcugl_1_1_mat4.html">Mat4</a> &amp;transform)</td></tr>
<tr class="separator:a5e8f72cf2562e3d6ba906edda20469d1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5fba174640feb73e7404da814fbefded"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1_sprite_batch.html#a5fba174640feb73e7404da814fbefded">draw</a> (const std::shared_ptr&lt; <a class="el" href="classcugl_1_1_texture.html">Texture</a> &gt; &amp;texture, const <a class="el" href="classcugl_1_1_color4f.html">Color4f</a> color, const <a class="el" href="classcugl_1_1_vec2.html">Vec2</a> origin, const <a class="el" href="classcugl_1_1_mat4.html">Mat4</a> &amp;transform)</td></tr>
<tr class="separator:a5fba174640feb73e7404da814fbefded"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a53a08f78e86b76bd5c0594f543a78880"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1_sprite_batch.html#a53a08f78e86b76bd5c0594f543a78880">draw</a> (const std::shared_ptr&lt; <a class="el" href="classcugl_1_1_texture.html">Texture</a> &gt; &amp;texture, const <a class="el" href="classcugl_1_1_rect.html">Rect</a> bounds, const <a class="el" href="classcugl_1_1_vec2.html">Vec2</a> origin, const <a class="el" href="classcugl_1_1_mat4.html">Mat4</a> &amp;transform)</td></tr>
<tr class="separator:a53a08f78e86b76bd5c0594f543a78880"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa53c850015fc267210c361764ec957ab"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1_sprite_batch.html#aa53c850015fc267210c361764ec957ab">draw</a> (const std::shared_ptr&lt; <a class="el" href="classcugl_1_1_texture.html">Texture</a> &gt; &amp;texture, const <a class="el" href="classcugl_1_1_color4f.html">Color4f</a> color, const <a class="el" href="classcugl_1_1_rect.html">Rect</a> bounds, const <a class="el" href="classcugl_1_1_vec2.html">Vec2</a> origin, const <a class="el" href="classcugl_1_1_mat4.html">Mat4</a> &amp;transform)</td></tr>
<tr class="separator:aa53c850015fc267210c361764ec957ab"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3ba91859d3bf7a0fcd458a15ce109f9b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1_sprite_batch.html#a3ba91859d3bf7a0fcd458a15ce109f9b">draw</a> (const std::shared_ptr&lt; <a class="el" href="classcugl_1_1_texture.html">Texture</a> &gt; &amp;texture, const <a class="el" href="classcugl_1_1_poly2.html">Poly2</a> &amp;poly, const <a class="el" href="classcugl_1_1_vec2.html">Vec2</a> offset)</td></tr>
<tr class="separator:a3ba91859d3bf7a0fcd458a15ce109f9b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afe62f876282af968e99295119c11360b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1_sprite_batch.html#afe62f876282af968e99295119c11360b">draw</a> (const std::shared_ptr&lt; <a class="el" href="classcugl_1_1_texture.html">Texture</a> &gt; &amp;texture, const <a class="el" href="classcugl_1_1_color4f.html">Color4f</a> color, const <a class="el" href="classcugl_1_1_poly2.html">Poly2</a> &amp;poly, const <a class="el" href="classcugl_1_1_vec2.html">Vec2</a> offset)</td></tr>
<tr class="separator:afe62f876282af968e99295119c11360b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5aa9a46a51ecdff27d2b9c01b08ab3b2"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1_sprite_batch.html#a5aa9a46a51ecdff27d2b9c01b08ab3b2">draw</a> (const std::shared_ptr&lt; <a class="el" href="classcugl_1_1_texture.html">Texture</a> &gt; &amp;texture, const <a class="el" href="classcugl_1_1_poly2.html">Poly2</a> &amp;poly, const <a class="el" href="classcugl_1_1_vec2.html">Vec2</a> origin, const <a class="el" href="classcugl_1_1_vec2.html">Vec2</a> scale, float angle, const <a class="el" href="classcugl_1_1_vec2.html">Vec2</a> offset)</td></tr>
<tr class="separator:a5aa9a46a51ecdff27d2b9c01b08ab3b2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a677883e3796806fd2750e9f2713d123c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1_sprite_batch.html#a677883e3796806fd2750e9f2713d123c">draw</a> (const std::shared_ptr&lt; <a class="el" href="classcugl_1_1_texture.html">Texture</a> &gt; &amp;texture, const <a class="el" href="classcugl_1_1_color4f.html">Color4f</a> color, const <a class="el" href="classcugl_1_1_poly2.html">Poly2</a> &amp;poly, const <a class="el" href="classcugl_1_1_vec2.html">Vec2</a> origin, const <a class="el" href="classcugl_1_1_vec2.html">Vec2</a> scale, float angle, const <a class="el" href="classcugl_1_1_vec2.html">Vec2</a> offset)</td></tr>
<tr class="separator:a677883e3796806fd2750e9f2713d123c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad7d43cce263cf35b497ebd43d89f110e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1_sprite_batch.html#ad7d43cce263cf35b497ebd43d89f110e">draw</a> (const std::shared_ptr&lt; <a class="el" href="classcugl_1_1_texture.html">Texture</a> &gt; &amp;texture, const <a class="el" href="classcugl_1_1_poly2.html">Poly2</a> &amp;poly, const <a class="el" href="classcugl_1_1_vec2.html">Vec2</a> origin, const <a class="el" href="classcugl_1_1_mat4.html">Mat4</a> &amp;transform)</td></tr>
<tr class="separator:ad7d43cce263cf35b497ebd43d89f110e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6a654b13a69aa3d8aa06ff945e38c684"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1_sprite_batch.html#a6a654b13a69aa3d8aa06ff945e38c684">draw</a> (const std::shared_ptr&lt; <a class="el" href="classcugl_1_1_texture.html">Texture</a> &gt; &amp;texture, const <a class="el" href="classcugl_1_1_color4f.html">Color4f</a> color, const <a class="el" href="classcugl_1_1_poly2.html">Poly2</a> &amp;poly, const <a class="el" href="classcugl_1_1_vec2.html">Vec2</a> origin, const <a class="el" href="classcugl_1_1_mat4.html">Mat4</a> &amp;transform)</td></tr>
<tr class="separator:a6a654b13a69aa3d8aa06ff945e38c684"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-static-methods"></a>
Static Public Member Functions</h2></td></tr>
<tr class="memitem:a668bcfcf2bb45136717251a662bc0711"><td class="memItemLeft" align="right" valign="top">static std::shared_ptr&lt; <a class="el" href="classcugl_1_1_sprite_batch.html">SpriteBatch</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1_sprite_batch.html#a668bcfcf2bb45136717251a662bc0711">alloc</a> ()</td></tr>
<tr class="separator:a668bcfcf2bb45136717251a662bc0711"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7381141ce3679b865681c867cada849b"><td class="memItemLeft" align="right" valign="top">static std::shared_ptr&lt; <a class="el" href="classcugl_1_1_sprite_batch.html">SpriteBatch</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1_sprite_batch.html#a7381141ce3679b865681c867cada849b">alloc</a> (const std::shared_ptr&lt; <a class="el" href="classcugl_1_1_shader.html">Shader</a> &gt; &amp;shader)</td></tr>
<tr class="separator:a7381141ce3679b865681c867cada849b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab4e57475eb54f204f5887d13af6c4909"><td class="memItemLeft" align="right" valign="top">static std::shared_ptr&lt; <a class="el" href="classcugl_1_1_sprite_batch.html">SpriteBatch</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1_sprite_batch.html#ab4e57475eb54f204f5887d13af6c4909">alloc</a> (unsigned int capacity)</td></tr>
<tr class="separator:ab4e57475eb54f204f5887d13af6c4909"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4aa088e2934003d0deda14d621dee9cb"><td class="memItemLeft" align="right" valign="top">static std::shared_ptr&lt; <a class="el" href="classcugl_1_1_sprite_batch.html">SpriteBatch</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1_sprite_batch.html#a4aa088e2934003d0deda14d621dee9cb">alloc</a> (unsigned int capacity, const std::shared_ptr&lt; <a class="el" href="classcugl_1_1_shader.html">Shader</a> &gt; &amp;shader)</td></tr>
<tr class="separator:a4aa088e2934003d0deda14d621dee9cb"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>This class is a sprite batch for drawing 2d graphics.</p>
<p>A sprite batch gathers together sprites and draws them as a single mesh whenever possible. However this sprite batch is different from a classic sprite batch (from XNA or LibGDX) in that it provides a complete 2d graphics pipeline supporting both solid shapes and outlines, with texture, gradient, and scissor mask support.</p>
<p>This sprite batch is capable of drawing with an active texture. In that case, the shape will be drawn with a solid color. If no color has been specified, the default color is white. Outlines use the same texturing rules that solids do. There is also support for a simple, limited radius blur effect on textures.</p>
<p>Color gradient support is provided by the <a class="el" href="classcugl_1_1_gradient.html">Gradient</a> class. All gradients will be tinted by the current color (so the color should be reset to white before using a gradient).</p>
<p><a class="el" href="classcugl_1_1_scissor.html">Scissor</a> masks are supported by the <a class="el" href="classcugl_1_1_scissor.html">Scissor</a> class. This is useful for constraining shapes to an internal window. A scissor mask must be a transformed rectangle; it cannot mask with arbitrary polygons.</p>
<p>Drawing only occurs when the methods <a class="el" href="classcugl_1_1_sprite_batch.html#ad4865921fb83cef24981dba2c1799934">flush</a> or <a class="el" href="classcugl_1_1_sprite_batch.html#aa19d39209e70a6be006c2371de0c63a1">end</a> are called. Because loading vertices into a <a class="el" href="classcugl_1_1_vertex_buffer.html">VertexBuffer</a> is an expensive operation, this sprite batch attempts to minimize this as much as possible. Even texture switches are batched. However, it is still true that using a single texture atlas can significantly improve drawing speed.</p>
<p>A review of this class shows that there are a lot of redundant drawing methods. The scene graphs only use the <a class="el" href="classcugl_1_1_mesh.html">Mesh</a> methods. This goal has been to make this class more accessible to students familiar with classic sprite batches found in LibGDX or XNA.</p>
<p>It is possible to swap out the shader for this class with another one. Any shader for this class should support <a class="el" href="classcugl_1_1_sprite_vertex3.html">SpriteVertex3</a> as its vertex data. If you need additional vertex information, such as normals, you should create a new class. It should also have a uniform for the perspective matrix, texture, and drawing type (type 0). Support for gradients and scissors occur via a uniform block that is provides the data in the order scissor then gradient. See SpriteShader.frag for more information. </p>
</div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="acd2b8d2c9ab34b5c03f32019d1f6872b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acd2b8d2c9ab34b5c03f32019d1f6872b">&#9670;&nbsp;</a></span>SpriteBatch()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">cugl::SpriteBatch::SpriteBatch </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Creates a degenerate sprite batch with no buffers.</p>
<p>You must initialize the buffer before using it. </p>

</div>
</div>
<a id="ae9a3434a113d7eadc5ce10194fa6d4b1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae9a3434a113d7eadc5ce10194fa6d4b1">&#9670;&nbsp;</a></span>~SpriteBatch()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">cugl::SpriteBatch::~SpriteBatch </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Deletes the sprite batch, disposing all resources </p>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="a668bcfcf2bb45136717251a662bc0711"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a668bcfcf2bb45136717251a662bc0711">&#9670;&nbsp;</a></span>alloc() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static std::shared_ptr&lt;<a class="el" href="classcugl_1_1_sprite_batch.html">SpriteBatch</a>&gt; cugl::SpriteBatch::alloc </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns a new sprite batch with the default vertex capacity.</p>
<p>The default vertex capacity is 8192 vertices and 8192*3 = 24576 indices. If the mesh exceeds these values, the sprite batch will flush before before continuing to draw. Similarly uniform buffer is initialized with 512 buffer positions. This means that the uniform buffer is comparable in memory size to the vertices, but only allows 512 gradient or scissor mask context switches before the sprite batch must flush. If you wish to increase (or decrease) the capacity, use the alternate allocator.</p>
<p>The sprite batch begins with no active texture, and the color white. The perspective matrix is the identity.</p>
<dl class="section return"><dt>Returns</dt><dd>a new sprite batch with the default vertex capacity. </dd></dl>

</div>
</div>
<a id="a7381141ce3679b865681c867cada849b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7381141ce3679b865681c867cada849b">&#9670;&nbsp;</a></span>alloc() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static std::shared_ptr&lt;<a class="el" href="classcugl_1_1_sprite_batch.html">SpriteBatch</a>&gt; cugl::SpriteBatch::alloc </td>
          <td>(</td>
          <td class="paramtype">const std::shared_ptr&lt; <a class="el" href="classcugl_1_1_shader.html">Shader</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>shader</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns a new sprite batch with the default vertex capacity and given shader</p>
<p>The default vertex capacity is 8192 vertices and 8192*3 = 24576 indices. If the mesh exceeds these values, the sprite batch will flush before before continuing to draw. Similarly uniform buffer is initialized with 512 buffer positions. This means that the uniform buffer is comparable in memory size to the vertices, but only allows 512 gradient or scissor mask context switches before the sprite batch must flush. If you wish to increase (or decrease) the capacity, use the alternate allocator.</p>
<p>The sprite batch begins with no active texture, and the color white. The perspective matrix is the identity.</p>
<p>See the class description for the properties of a valid shader.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">shader</td><td>The shader to use for this spritebatch</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a new sprite batch with the default vertex capacity and given shader </dd></dl>

</div>
</div>
<a id="ab4e57475eb54f204f5887d13af6c4909"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab4e57475eb54f204f5887d13af6c4909">&#9670;&nbsp;</a></span>alloc() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static std::shared_ptr&lt;<a class="el" href="classcugl_1_1_sprite_batch.html">SpriteBatch</a>&gt; cugl::SpriteBatch::alloc </td>
          <td>(</td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>capacity</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns a new sprite batch with the given vertex capacity.</p>
<p>The index capacity will be 3 times the vertex capacity. The maximum number of possible indices is the maximum size_t, so the vertex size must be a third that. In addition, the sprite batch will allocate 1/16 of the vertex capacity for uniform blocks (for gradients and scissor masks). This means that the uniform buffer is comparable in memory size to the vertices while still allowing a reasonably high rate of change for quads and regularly shaped sprites.</p>
<p>If the mesh exceeds the capacity, the sprite batch will flush before before continuing to draw. You should tune your system to have the appropriate capacity. To small a capacity will cause the system to thrash. However, too large a capacity could stall on memory transfers.</p>
<p>The sprite batch begins with the default blank texture, and color white. The perspective matrix is the identity.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">capacity</td><td>The vertex capacity of this spritebatch</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a new sprite batch with the given vertex capacity. </dd></dl>

</div>
</div>
<a id="a4aa088e2934003d0deda14d621dee9cb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4aa088e2934003d0deda14d621dee9cb">&#9670;&nbsp;</a></span>alloc() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static std::shared_ptr&lt;<a class="el" href="classcugl_1_1_sprite_batch.html">SpriteBatch</a>&gt; cugl::SpriteBatch::alloc </td>
          <td>(</td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>capacity</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::shared_ptr&lt; <a class="el" href="classcugl_1_1_shader.html">Shader</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>shader</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns a new sprite batch with the given vertex capacity and shader</p>
<p>The index capacity will be 3 times the vertex capacity. The maximum number of possible indices is the maximum size_t, so the vertex size must be a third that. In addition, the sprite batch will allocate 1/16 of the vertex capacity for uniform blocks (for gradients and scissor masks). This means that the uniform buffer is comparable in memory size to the vertices while still allowing a reasonably high rate of change for quads and regularly shaped sprites.</p>
<p>If the mesh exceeds the capacity, the sprite batch will flush before before continuing to draw. You should tune your system to have the appropriate capacity. To small a capacity will cause the system to thrash. However, too large a capacity could stall on memory transfers.</p>
<p>The sprite batch begins with the default blank texture, and color white. The perspective matrix is the identity.</p>
<p>See the class description for the properties of a valid shader.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">capacity</td><td>The vertex capacity of this spritebatch </td></tr>
    <tr><td class="paramname">shader</td><td>The shader to use for this spritebatch</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a new sprite batch with the given vertex capacity and shader </dd></dl>

</div>
</div>
<a id="a631a3759f253a59c79000f0736792dcf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a631a3759f253a59c79000f0736792dcf">&#9670;&nbsp;</a></span>begin() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void cugl::SpriteBatch::begin </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Starts drawing with the current perspective matrix.</p>
<p>This call will disable depth buffer writing. It enables blending and texturing. You must call either <a class="el" href="classcugl_1_1_sprite_batch.html#ad4865921fb83cef24981dba2c1799934">flush</a> or <a class="el" href="classcugl_1_1_sprite_batch.html#aa19d39209e70a6be006c2371de0c63a1">end</a> to complete drawing.</p>
<p>Calling this method will reset the vertex and OpenGL call counters to 0. </p>

</div>
</div>
<a id="af57f31767c1e3dd4c1bda07a01348aca"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af57f31767c1e3dd4c1bda07a01348aca">&#9670;&nbsp;</a></span>begin() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void cugl::SpriteBatch::begin </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classcugl_1_1_mat4.html">Mat4</a> &amp;&#160;</td>
          <td class="paramname"><em>perspective</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Starts drawing with the given perspective matrix.</p>
<p>This call will disable depth buffer writing. It enables blending and texturing. You must call either <a class="el" href="classcugl_1_1_sprite_batch.html#ad4865921fb83cef24981dba2c1799934">flush</a> or <a class="el" href="classcugl_1_1_sprite_batch.html#aa19d39209e70a6be006c2371de0c63a1">end</a> to complete drawing.</p>
<p>Calling this method will reset the vertex and OpenGL call counters to 0.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">perspective</td><td>The perspective matrix to draw with. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a241abb9a7e9c1f3d06a6a0b519ce56cf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a241abb9a7e9c1f3d06a6a0b519ce56cf">&#9670;&nbsp;</a></span>dispose()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void cugl::SpriteBatch::dispose </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Deletes the vertex buffers and resets all attributes.</p>
<p>You must reinitialize the sprite batch to use it. </p>

</div>
</div>
<a id="afe62f876282af968e99295119c11360b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afe62f876282af968e99295119c11360b">&#9670;&nbsp;</a></span>draw() <span class="overload">[1/18]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void cugl::SpriteBatch::draw </td>
          <td>(</td>
          <td class="paramtype">const std::shared_ptr&lt; <a class="el" href="classcugl_1_1_texture.html">Texture</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>texture</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classcugl_1_1_color4f.html">Color4f</a>&#160;</td>
          <td class="paramname"><em>color</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classcugl_1_1_poly2.html">Poly2</a> &amp;&#160;</td>
          <td class="paramname"><em>poly</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classcugl_1_1_vec2.html">Vec2</a>&#160;</td>
          <td class="paramname"><em>offset</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Draws the tinted, textured polygon at the given position</p>
<p>This is a convenience method that calls the appropriate fill method. It sets both the texture and color (removing the previous active values). It then draws the polygon, offset by the given value.</p>
<p>The polygon tesselation will be determined by the indices in poly. If the polygon has not been triangulated (by one of the triangulation factories <a class="el" href="classcugl_1_1_simple_triangulator.html">SimpleTriangulator</a> or <a class="el" href="classcugl_1_1_complex_triangulator.html">ComplexTriangulator</a>, it may not draw properly.</p>
<p>The vertex coordinates will be determined by polygon vertex position. A horizontal position x has texture coordinate x/texture.width. A vertical coordinate has texture coordinate 1-y/texture.height. As a result, a rectangular polygon that has the same dimensions as the texture is the same as simply drawing the texture.</p>
<p>One way to think of the polygon is as a "cookie cutter". Treat the polygon coordinates as pixel coordinates in the texture filed, and use that to determine how the texture fills the polygon. This may make the polygon larger than you like in order to get the appropriate texturing. You should use one of the transform methods to fix this.</p>
<p>If depth testing is on, all vertices will be the current depth.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">texture</td><td>The new active texture </td></tr>
    <tr><td class="paramname">color</td><td>The new active color </td></tr>
    <tr><td class="paramname">poly</td><td>The polygon to texture </td></tr>
    <tr><td class="paramname">offset</td><td>The polygon offset </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a6a654b13a69aa3d8aa06ff945e38c684"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6a654b13a69aa3d8aa06ff945e38c684">&#9670;&nbsp;</a></span>draw() <span class="overload">[2/18]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void cugl::SpriteBatch::draw </td>
          <td>(</td>
          <td class="paramtype">const std::shared_ptr&lt; <a class="el" href="classcugl_1_1_texture.html">Texture</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>texture</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classcugl_1_1_color4f.html">Color4f</a>&#160;</td>
          <td class="paramname"><em>color</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classcugl_1_1_poly2.html">Poly2</a> &amp;&#160;</td>
          <td class="paramname"><em>poly</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classcugl_1_1_vec2.html">Vec2</a>&#160;</td>
          <td class="paramname"><em>origin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classcugl_1_1_mat4.html">Mat4</a> &amp;&#160;</td>
          <td class="paramname"><em>transform</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Draws the tinted, textured polygon transformed by the given matrix</p>
<p>This is a convenience method that calls the appropriate fill method. It sets both the texture and color (removing the previous active values). It then draws the polygon, translated by the given matrix.</p>
<p>The polygon will transformed by the given matrix. The transform will be applied assuming the given origin, which is specified relative to the origin of the polygon (not world coordinates). Hence this origin is essentially the pixel coordinate of the texture (see below) to assign as the origin of this transform.</p>
<p>The polygon tesselation will be determined by the indices in poly. If the polygon has not been triangulated (by one of the triangulation factories <a class="el" href="classcugl_1_1_simple_triangulator.html">SimpleTriangulator</a> or <a class="el" href="classcugl_1_1_complex_triangulator.html">ComplexTriangulator</a>, it may not draw properly.</p>
<p>The vertex coordinates will be determined by polygon vertex position. A horizontal position x has texture coordinate x/texture.width. A vertical coordinate has texture coordinate 1-y/texture.height. As a result, a rectangular polygon that has the same dimensions as the texture is the same as simply drawing the texture.</p>
<p>One way to think of the polygon is as a "cookie cutter". Treat the polygon coordinates as pixel coordinates in the texture filed, and use that to determine how the texture fills the polygon. This may make the polygon larger than you like in order to get the appropriate texturing. You should use one of the transform methods to fix this.</p>
<p>If depth testing is on, all vertices will be the current depth.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">texture</td><td>The new active texture </td></tr>
    <tr><td class="paramname">color</td><td>The new active color </td></tr>
    <tr><td class="paramname">poly</td><td>The polygon to texture </td></tr>
    <tr><td class="paramname">origin</td><td>The image origin in pixel space </td></tr>
    <tr><td class="paramname">transform</td><td>The coordinate transform </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a677883e3796806fd2750e9f2713d123c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a677883e3796806fd2750e9f2713d123c">&#9670;&nbsp;</a></span>draw() <span class="overload">[3/18]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void cugl::SpriteBatch::draw </td>
          <td>(</td>
          <td class="paramtype">const std::shared_ptr&lt; <a class="el" href="classcugl_1_1_texture.html">Texture</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>texture</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classcugl_1_1_color4f.html">Color4f</a>&#160;</td>
          <td class="paramname"><em>color</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classcugl_1_1_poly2.html">Poly2</a> &amp;&#160;</td>
          <td class="paramname"><em>poly</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classcugl_1_1_vec2.html">Vec2</a>&#160;</td>
          <td class="paramname"><em>origin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classcugl_1_1_vec2.html">Vec2</a>&#160;</td>
          <td class="paramname"><em>scale</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>angle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classcugl_1_1_vec2.html">Vec2</a>&#160;</td>
          <td class="paramname"><em>offset</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Draws the tinted, textured polygon transformed by the given parameters</p>
<p>This is a convenience method that calls the appropriate fill method. It sets both the texture and color (removing the previous active values). It then draws the polygon, translated by the given parameters.</p>
<p>The polygon will be scaled first, then rotated, and finally offset by the given position. Rotation is measured in radians and is counter clockwise from the x-axis. Rotation will be about the provided origin, which is specified relative to the origin of the polygon (not world coordinates). Hence this origin is essentially the pixel coordinate of the texture (see below) to assign as the rotational center.</p>
<p>The polygon tesselation will be determined by the indices in poly. If the polygon has not been triangulated (by one of the triangulation factories <a class="el" href="classcugl_1_1_simple_triangulator.html">SimpleTriangulator</a> or <a class="el" href="classcugl_1_1_complex_triangulator.html">ComplexTriangulator</a>, it may not draw properly.</p>
<p>The vertex coordinates will be determined by polygon vertex position. A horizontal position x has texture coordinate x/texture.width. A vertical coordinate has texture coordinate 1-y/texture.height. As a result, a rectangular polygon that has the same dimensions as the texture is the same as simply drawing the texture.</p>
<p>One way to think of the polygon is as a "cookie cutter". Treat the polygon coordinates as pixel coordinates in the texture filed, and use that to determine how the texture fills the polygon. This may make the polygon larger than you like in order to get the appropriate texturing. You should use one of the transform methods to fix this.</p>
<p>If depth testing is on, all vertices will be the current depth.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">texture</td><td>The new active texture </td></tr>
    <tr><td class="paramname">color</td><td>The new active color </td></tr>
    <tr><td class="paramname">poly</td><td>The polygon to texture </td></tr>
    <tr><td class="paramname">origin</td><td>The image origin in pixel space </td></tr>
    <tr><td class="paramname">scale</td><td>The amount to scale the polygon </td></tr>
    <tr><td class="paramname">angle</td><td>The amount to rotate the polygon </td></tr>
    <tr><td class="paramname">offset</td><td>The polygon offset in world coordinates </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a48f55c01e3ce12800c33d02442cb2ff3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a48f55c01e3ce12800c33d02442cb2ff3">&#9670;&nbsp;</a></span>draw() <span class="overload">[4/18]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void cugl::SpriteBatch::draw </td>
          <td>(</td>
          <td class="paramtype">const std::shared_ptr&lt; <a class="el" href="classcugl_1_1_texture.html">Texture</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>texture</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classcugl_1_1_color4f.html">Color4f</a>&#160;</td>
          <td class="paramname"><em>color</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classcugl_1_1_rect.html">Rect</a>&#160;</td>
          <td class="paramname"><em>bounds</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Draws the tinted texture at the given position</p>
<p>This is a convenience method that calls the appropriate fill method. It sets both the texture and color (removing the previous active values). It then draws the specified rectangle filled with the texture.</p>
<p>If depth testing is on, all vertices will be the current depth.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">texture</td><td>The new active texture </td></tr>
    <tr><td class="paramname">color</td><td>The new active color </td></tr>
    <tr><td class="paramname">bounds</td><td>The rectangle to texture </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aa53c850015fc267210c361764ec957ab"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa53c850015fc267210c361764ec957ab">&#9670;&nbsp;</a></span>draw() <span class="overload">[5/18]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void cugl::SpriteBatch::draw </td>
          <td>(</td>
          <td class="paramtype">const std::shared_ptr&lt; <a class="el" href="classcugl_1_1_texture.html">Texture</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>texture</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classcugl_1_1_color4f.html">Color4f</a>&#160;</td>
          <td class="paramname"><em>color</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classcugl_1_1_rect.html">Rect</a>&#160;</td>
          <td class="paramname"><em>bounds</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classcugl_1_1_vec2.html">Vec2</a>&#160;</td>
          <td class="paramname"><em>origin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classcugl_1_1_mat4.html">Mat4</a> &amp;&#160;</td>
          <td class="paramname"><em>transform</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Draws the tinted texture transformed by the matrix</p>
<p>This is a convenience method that calls the appropriate fill method. It sets both the texture and color (removing the previous active values). It fills the specified rectangle with the texture, transformed by the given matrix.</p>
<p>The transform will be applied assuming the given image origin, which is specified in texture pixel coordinates (e.g from the bottom left corner).</p>
<p>If depth testing is on, all vertices will be the current depth.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">texture</td><td>The new active texture </td></tr>
    <tr><td class="paramname">color</td><td>The new active color </td></tr>
    <tr><td class="paramname">bounds</td><td>The rectangle to texture </td></tr>
    <tr><td class="paramname">origin</td><td>The image origin in pixel space </td></tr>
    <tr><td class="paramname">transform</td><td>The coordinate transform </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ae6bd1c0f794dcd7d08135efe67976ad5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae6bd1c0f794dcd7d08135efe67976ad5">&#9670;&nbsp;</a></span>draw() <span class="overload">[6/18]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void cugl::SpriteBatch::draw </td>
          <td>(</td>
          <td class="paramtype">const std::shared_ptr&lt; <a class="el" href="classcugl_1_1_texture.html">Texture</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>texture</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classcugl_1_1_color4f.html">Color4f</a>&#160;</td>
          <td class="paramname"><em>color</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classcugl_1_1_rect.html">Rect</a>&#160;</td>
          <td class="paramname"><em>bounds</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classcugl_1_1_vec2.html">Vec2</a>&#160;</td>
          <td class="paramname"><em>origin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classcugl_1_1_vec2.html">Vec2</a>&#160;</td>
          <td class="paramname"><em>scale</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>angle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classcugl_1_1_vec2.html">Vec2</a>&#160;</td>
          <td class="paramname"><em>offset</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Draws the tinted texture transformed by the given parameters</p>
<p>This is a convenience method that calls the appropriate fill method. It sets both the texture and color (removing the previous active values). It fills the specified rectangle with the texture.</p>
<p>The rectangle will be scaled first, then rotated, and finally offset by the given position. Rotation is measured in radians and is counter clockwise from the x-axis. Rotation will be about the provided origin, which is specified relative to the origin of the rectangle (not world coordinates). So to spin about the center, the origin should be width/2, height/2 of the rectangle.</p>
<p>The texture will fill the entire rectangle before being transformed. <a class="el" href="classcugl_1_1_texture.html">Texture</a> coordinate (0,1) will at the bottom left corner identified by rect,origin. To draw only part of a texture, use a subtexture to fill the rectangle with the region [minS,maxS]x[min,maxT]. Alternatively, you can use a <a class="el" href="classcugl_1_1_poly2.html">Poly2</a> for more fine-tuned control.</p>
<p>If depth testing is on, all vertices will be the current depth.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">texture</td><td>The new active texture </td></tr>
    <tr><td class="paramname">color</td><td>The new active color </td></tr>
    <tr><td class="paramname">bounds</td><td>The rectangle to texture </td></tr>
    <tr><td class="paramname">origin</td><td>The image origin in pixel space </td></tr>
    <tr><td class="paramname">scale</td><td>The amount to scale the texture </td></tr>
    <tr><td class="paramname">angle</td><td>The amount to rotate the texture </td></tr>
    <tr><td class="paramname">offset</td><td>The rectangle offset in world coordinates </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a5fba174640feb73e7404da814fbefded"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5fba174640feb73e7404da814fbefded">&#9670;&nbsp;</a></span>draw() <span class="overload">[7/18]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void cugl::SpriteBatch::draw </td>
          <td>(</td>
          <td class="paramtype">const std::shared_ptr&lt; <a class="el" href="classcugl_1_1_texture.html">Texture</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>texture</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classcugl_1_1_color4f.html">Color4f</a>&#160;</td>
          <td class="paramname"><em>color</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classcugl_1_1_vec2.html">Vec2</a>&#160;</td>
          <td class="paramname"><em>origin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classcugl_1_1_mat4.html">Mat4</a> &amp;&#160;</td>
          <td class="paramname"><em>transform</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Draws the tinted texture transformed by the matrix</p>
<p>This is a convenience method that calls the appropriate fill method. It sets both the texture and color (removing the previous active values). It then draws a texture-sized rectangle centered at the given origin, and transformed by the given matrix.</p>
<p>The transform will be applied assuming the given image origin, which is specified in texture pixel coordinates (e.g from the bottom left corner).</p>
<p>If depth testing is on, all vertices will be the current depth.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">texture</td><td>The new active texture </td></tr>
    <tr><td class="paramname">color</td><td>The new active color </td></tr>
    <tr><td class="paramname">origin</td><td>The image origin in pixel space </td></tr>
    <tr><td class="paramname">transform</td><td>The coordinate transform </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a8d90915ecbe445b31337d8dc5f508b64"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8d90915ecbe445b31337d8dc5f508b64">&#9670;&nbsp;</a></span>draw() <span class="overload">[8/18]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void cugl::SpriteBatch::draw </td>
          <td>(</td>
          <td class="paramtype">const std::shared_ptr&lt; <a class="el" href="classcugl_1_1_texture.html">Texture</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>texture</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classcugl_1_1_color4f.html">Color4f</a>&#160;</td>
          <td class="paramname"><em>color</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classcugl_1_1_vec2.html">Vec2</a>&#160;</td>
          <td class="paramname"><em>origin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classcugl_1_1_vec2.html">Vec2</a>&#160;</td>
          <td class="paramname"><em>scale</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>angle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classcugl_1_1_vec2.html">Vec2</a>&#160;</td>
          <td class="paramname"><em>offset</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Draws the tinted texture transformed by the given parameters</p>
<p>This is a convenience method that calls the appropriate fill method. It sets both the texture and color (removing the previous active values). It then draws a texture-sized rectangle centered at the given origin, and transformed by the given parameters.</p>
<p>The rectangle will be scaled first, then rotated, and finally offset by the given position. Rotation is measured in radians and is counter clockwise from the x-axis. Rotation will be about the provided origin, which is specified in texture pixel coordinates (e.g from the bottom left corner).</p>
<p>If depth testing is on, all vertices will be the current depth.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">texture</td><td>The new active texture </td></tr>
    <tr><td class="paramname">color</td><td>The new active color </td></tr>
    <tr><td class="paramname">origin</td><td>The image origin in pixel space </td></tr>
    <tr><td class="paramname">scale</td><td>The amount to scale the texture </td></tr>
    <tr><td class="paramname">angle</td><td>The amount to rotate the texture </td></tr>
    <tr><td class="paramname">offset</td><td>The texture offset in world coordinates </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aac0563cb6e5b9abdff42da87a71d518b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aac0563cb6e5b9abdff42da87a71d518b">&#9670;&nbsp;</a></span>draw() <span class="overload">[9/18]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void cugl::SpriteBatch::draw </td>
          <td>(</td>
          <td class="paramtype">const std::shared_ptr&lt; <a class="el" href="classcugl_1_1_texture.html">Texture</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>texture</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classcugl_1_1_color4f.html">Color4f</a>&#160;</td>
          <td class="paramname"><em>color</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classcugl_1_1_vec2.html">Vec2</a>&#160;</td>
          <td class="paramname"><em>position</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Draws the tinted texture at the given position</p>
<p>This is a convenience method that calls the appropriate fill method. It sets both the texture and color (removing the previous active values). <br  />
 It then draws a rectangle of the size of the texture, with bottom left corner at the given position.</p>
<p>If depth testing is on, all vertices will be the current depth.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">texture</td><td>The new active texture </td></tr>
    <tr><td class="paramname">color</td><td>The new active color </td></tr>
    <tr><td class="paramname">position</td><td>The bottom left corner of the texture </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a3ba91859d3bf7a0fcd458a15ce109f9b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3ba91859d3bf7a0fcd458a15ce109f9b">&#9670;&nbsp;</a></span>draw() <span class="overload">[10/18]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void cugl::SpriteBatch::draw </td>
          <td>(</td>
          <td class="paramtype">const std::shared_ptr&lt; <a class="el" href="classcugl_1_1_texture.html">Texture</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>texture</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classcugl_1_1_poly2.html">Poly2</a> &amp;&#160;</td>
          <td class="paramname"><em>poly</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classcugl_1_1_vec2.html">Vec2</a>&#160;</td>
          <td class="paramname"><em>offset</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Draws the textured polygon (without tint) at the given position</p>
<p>This is a convenience method that calls the appropriate fill method. It sets both the texture and color (removing the previous active values). It then draws the polygon, offset by the given value.</p>
<p>The polygon tesselation will be determined by the indices in poly. If the polygon has not been triangulated (by one of the triangulation factories <a class="el" href="classcugl_1_1_simple_triangulator.html">SimpleTriangulator</a> or <a class="el" href="classcugl_1_1_complex_triangulator.html">ComplexTriangulator</a>, it may not draw properly.</p>
<p>The vertex coordinates will be determined by polygon vertex position. A horizontal position x has texture coordinate x/texture.width. A vertical coordinate has texture coordinate 1-y/texture.height. As a result, a rectangular polygon that has the same dimensions as the texture is the same as simply drawing the texture.</p>
<p>One way to think of the polygon is as a "cookie cutter". Treat the polygon coordinates as pixel coordinates in the texture filed, and use that to determine how the texture fills the polygon. This may make the polygon larger than you like in order to get the appropriate texturing. You should use one of the transform methods to fix this.</p>
<p>If depth testing is on, all vertices will be the current depth.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">texture</td><td>The new active texture </td></tr>
    <tr><td class="paramname">poly</td><td>The polygon to texture </td></tr>
    <tr><td class="paramname">offset</td><td>The polygon offset </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ad7d43cce263cf35b497ebd43d89f110e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad7d43cce263cf35b497ebd43d89f110e">&#9670;&nbsp;</a></span>draw() <span class="overload">[11/18]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void cugl::SpriteBatch::draw </td>
          <td>(</td>
          <td class="paramtype">const std::shared_ptr&lt; <a class="el" href="classcugl_1_1_texture.html">Texture</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>texture</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classcugl_1_1_poly2.html">Poly2</a> &amp;&#160;</td>
          <td class="paramname"><em>poly</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classcugl_1_1_vec2.html">Vec2</a>&#160;</td>
          <td class="paramname"><em>origin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classcugl_1_1_mat4.html">Mat4</a> &amp;&#160;</td>
          <td class="paramname"><em>transform</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Draws the textured polygon (without tint) transformed by the given matrix</p>
<p>This is a convenience method that calls the appropriate fill method. It sets both the texture and color (removing the previous active values). It then draws the polygon, translated by the given matrix.</p>
<p>The polygon will transformed by the given matrix. The transform will be applied assuming the given origin, which is specified relative to the origin of the polygon (not world coordinates). Hence this origin is essentially the pixel coordinate of the texture (see below) to assign as the origin of this transform.</p>
<p>The polygon tesselation will be determined by the indices in poly. If the polygon has not been triangulated (by one of the triangulation factories <a class="el" href="classcugl_1_1_simple_triangulator.html">SimpleTriangulator</a> or <a class="el" href="classcugl_1_1_complex_triangulator.html">ComplexTriangulator</a>, it may not draw properly.</p>
<p>The vertex coordinates will be determined by polygon vertex position. A horizontal position x has texture coordinate x/texture.width. A vertical coordinate has texture coordinate 1-y/texture.height. As a result, a rectangular polygon that has the same dimensions as the texture is the same as simply drawing the texture.</p>
<p>One way to think of the polygon is as a "cookie cutter". Treat the polygon coordinates as pixel coordinates in the texture filed, and use that to determine how the texture fills the polygon. This may make the polygon larger than you like in order to get the appropriate texturing. You should use one of the transform methods to fix this.</p>
<p>If depth testing is on, all vertices will be the current depth.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">texture</td><td>The new active texture </td></tr>
    <tr><td class="paramname">poly</td><td>The polygon to texture </td></tr>
    <tr><td class="paramname">origin</td><td>The image origin in pixel space </td></tr>
    <tr><td class="paramname">transform</td><td>The coordinate transform </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a5aa9a46a51ecdff27d2b9c01b08ab3b2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5aa9a46a51ecdff27d2b9c01b08ab3b2">&#9670;&nbsp;</a></span>draw() <span class="overload">[12/18]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void cugl::SpriteBatch::draw </td>
          <td>(</td>
          <td class="paramtype">const std::shared_ptr&lt; <a class="el" href="classcugl_1_1_texture.html">Texture</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>texture</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classcugl_1_1_poly2.html">Poly2</a> &amp;&#160;</td>
          <td class="paramname"><em>poly</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classcugl_1_1_vec2.html">Vec2</a>&#160;</td>
          <td class="paramname"><em>origin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classcugl_1_1_vec2.html">Vec2</a>&#160;</td>
          <td class="paramname"><em>scale</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>angle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classcugl_1_1_vec2.html">Vec2</a>&#160;</td>
          <td class="paramname"><em>offset</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Draws the textured polygon (without tint) transformed by the given parameters</p>
<p>This is a convenience method that calls the appropriate fill method. It sets both the texture and color (removing the previous active values). It then draws the polygon, transformed by the given parameters.</p>
<p>The polygon will be scaled first, then rotated, and finally offset by the given position. Rotation is measured in radians and is counter clockwise from the x-axis. Rotation will be about the provided origin, which is specified relative to the origin of the polygon (not world coordinates). Hence this origin is essentially the pixel coordinate of the texture (see below) to assign as the rotational center.</p>
<p>The polygon tesselation will be determined by the indices in poly. If the polygon has not been triangulated (by one of the triangulation factories <a class="el" href="classcugl_1_1_simple_triangulator.html">SimpleTriangulator</a> or <a class="el" href="classcugl_1_1_complex_triangulator.html">ComplexTriangulator</a>, it may not draw properly.</p>
<p>The vertex coordinates will be determined by polygon vertex position. A horizontal position x has texture coordinate x/texture.width. A vertical coordinate has texture coordinate 1-y/texture.height. As a result, a rectangular polygon that has the same dimensions as the texture is the same as simply drawing the texture.</p>
<p>One way to think of the polygon is as a "cookie cutter". Treat the polygon coordinates as pixel coordinates in the texture filed, and use that to determine how the texture fills the polygon. This may make the polygon larger than you like in order to get the appropriate texturing. You should use one of the transform methods to fix this.</p>
<p>If depth testing is on, all vertices will be the current depth.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">texture</td><td>The new active texture </td></tr>
    <tr><td class="paramname">poly</td><td>The polygon to texture </td></tr>
    <tr><td class="paramname">origin</td><td>The image origin in pixel space </td></tr>
    <tr><td class="paramname">scale</td><td>The amount to scale the polygon </td></tr>
    <tr><td class="paramname">angle</td><td>The amount to rotate the polygon </td></tr>
    <tr><td class="paramname">offset</td><td>The polygon offset in world coordinates </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a732ca7b7c06a917c372deb860037888e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a732ca7b7c06a917c372deb860037888e">&#9670;&nbsp;</a></span>draw() <span class="overload">[13/18]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void cugl::SpriteBatch::draw </td>
          <td>(</td>
          <td class="paramtype">const std::shared_ptr&lt; <a class="el" href="classcugl_1_1_texture.html">Texture</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>texture</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classcugl_1_1_rect.html">Rect</a>&#160;</td>
          <td class="paramname"><em>bounds</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Draws the texture (without tint) inside the given bounds</p>
<p>This is a convenience method that calls the appropriate fill method. It sets both the texture and color (removing the previous active values). It then draws the specified rectangle filled with the texture.</p>
<p>If depth testing is on, all vertices will be the current depth.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">texture</td><td>The new active texture </td></tr>
    <tr><td class="paramname">bounds</td><td>The rectangle to texture </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a53a08f78e86b76bd5c0594f543a78880"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a53a08f78e86b76bd5c0594f543a78880">&#9670;&nbsp;</a></span>draw() <span class="overload">[14/18]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void cugl::SpriteBatch::draw </td>
          <td>(</td>
          <td class="paramtype">const std::shared_ptr&lt; <a class="el" href="classcugl_1_1_texture.html">Texture</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>texture</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classcugl_1_1_rect.html">Rect</a>&#160;</td>
          <td class="paramname"><em>bounds</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classcugl_1_1_vec2.html">Vec2</a>&#160;</td>
          <td class="paramname"><em>origin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classcugl_1_1_mat4.html">Mat4</a> &amp;&#160;</td>
          <td class="paramname"><em>transform</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Draws the texture (without tint) transformed by the matrix</p>
<p>This is a convenience method that calls the appropriate fill method. It sets both the texture and color (removing the previous active values). It fills the specified rectangle with the texture, transformed by the given matrix.</p>
<p>The transform will be applied assuming the given image origin, which is specified in texture pixel coordinates (e.g from the bottom left corner).</p>
<p>If depth testing is on, all vertices will be the current depth.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">texture</td><td>The new active texture </td></tr>
    <tr><td class="paramname">bounds</td><td>The rectangle to texture </td></tr>
    <tr><td class="paramname">origin</td><td>The image origin in pixel space </td></tr>
    <tr><td class="paramname">transform</td><td>The coordinate transform </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a46c148faf961ac88ae619dd1bbd9874e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a46c148faf961ac88ae619dd1bbd9874e">&#9670;&nbsp;</a></span>draw() <span class="overload">[15/18]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void cugl::SpriteBatch::draw </td>
          <td>(</td>
          <td class="paramtype">const std::shared_ptr&lt; <a class="el" href="classcugl_1_1_texture.html">Texture</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>texture</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classcugl_1_1_rect.html">Rect</a>&#160;</td>
          <td class="paramname"><em>bounds</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classcugl_1_1_vec2.html">Vec2</a>&#160;</td>
          <td class="paramname"><em>origin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classcugl_1_1_vec2.html">Vec2</a>&#160;</td>
          <td class="paramname"><em>scale</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>angle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classcugl_1_1_vec2.html">Vec2</a>&#160;</td>
          <td class="paramname"><em>offset</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Draws the texture (without tint) transformed by the given parameters</p>
<p>This is a convenience method that calls the appropriate fill method. It sets both the texture and color (removing the previous active values). It fills the specified rectangle with the texture.</p>
<p>The rectangle will be scaled first, then rotated, and finally offset by the given position. Rotation is measured in radians and is counter clockwise from the x-axis. Rotation will be about the provided origin, which is specified relative to the origin of the rectangle (not world coordinates). So to spin about the center, the origin should be width/2, height/2 of the rectangle.</p>
<p>The texture will fill the entire rectangle before being transformed. <a class="el" href="classcugl_1_1_texture.html">Texture</a> coordinate (0,1) will at the bottom left corner identified by rect,origin. To draw only part of a texture, use a subtexture to fill the rectangle with the region [minS,maxS]x[min,maxT]. Alternatively, you can use a <a class="el" href="classcugl_1_1_poly2.html">Poly2</a> for more fine-tuned control.</p>
<p>If depth testing is on, all vertices will be the current depth.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">texture</td><td>The new active texture </td></tr>
    <tr><td class="paramname">bounds</td><td>The rectangle to texture </td></tr>
    <tr><td class="paramname">origin</td><td>The image origin in pixel space </td></tr>
    <tr><td class="paramname">scale</td><td>The amount to scale the texture </td></tr>
    <tr><td class="paramname">angle</td><td>The amount to rotate the texture </td></tr>
    <tr><td class="paramname">offset</td><td>The rectangle offset in world coordinates </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a5e8f72cf2562e3d6ba906edda20469d1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5e8f72cf2562e3d6ba906edda20469d1">&#9670;&nbsp;</a></span>draw() <span class="overload">[16/18]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void cugl::SpriteBatch::draw </td>
          <td>(</td>
          <td class="paramtype">const std::shared_ptr&lt; <a class="el" href="classcugl_1_1_texture.html">Texture</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>texture</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classcugl_1_1_vec2.html">Vec2</a>&#160;</td>
          <td class="paramname"><em>origin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classcugl_1_1_mat4.html">Mat4</a> &amp;&#160;</td>
          <td class="paramname"><em>transform</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Draws the texture (without tint) transformed by the matrix</p>
<p>This is a convenience method that calls the appropriate fill method. It sets both the texture and color (removing the previous active values). It then draws a texture-sized rectangle centered at the given origin, and transformed by the given matrix.</p>
<p>The transform will be applied assuming the given image origin, which is specified in texture pixel coordinates (e.g from the bottom left corner).</p>
<p>If depth testing is on, all vertices will be the current depth.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">texture</td><td>The new active texture </td></tr>
    <tr><td class="paramname">origin</td><td>The image origin in pixel space </td></tr>
    <tr><td class="paramname">transform</td><td>The coordinate transform </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a0cb5b3390ce9988303753ee398fbdb30"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0cb5b3390ce9988303753ee398fbdb30">&#9670;&nbsp;</a></span>draw() <span class="overload">[17/18]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void cugl::SpriteBatch::draw </td>
          <td>(</td>
          <td class="paramtype">const std::shared_ptr&lt; <a class="el" href="classcugl_1_1_texture.html">Texture</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>texture</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classcugl_1_1_vec2.html">Vec2</a>&#160;</td>
          <td class="paramname"><em>origin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classcugl_1_1_vec2.html">Vec2</a>&#160;</td>
          <td class="paramname"><em>scale</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>angle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classcugl_1_1_vec2.html">Vec2</a>&#160;</td>
          <td class="paramname"><em>offset</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Draws the texture (without tint) transformed by the given parameters</p>
<p>This is a convenience method that calls the appropriate fill method. It sets both the texture and color (removing the previous active values). It then draws a texture-sized rectangle centered at the given origin, and transformed by the given parameters.</p>
<p>The rectangle will be scaled first, then rotated, and finally offset by the given position. Rotation is measured in radians and is counter clockwise from the x-axis. Rotation will be about the provided origin, which is specified in texture pixel coordinates (e.g from the bottom left corner).</p>
<p>If depth testing is on, all vertices will be the current depth.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">texture</td><td>The new active texture </td></tr>
    <tr><td class="paramname">origin</td><td>The image origin in pixel space </td></tr>
    <tr><td class="paramname">scale</td><td>The amount to scale the texture </td></tr>
    <tr><td class="paramname">angle</td><td>The amount to rotate the texture </td></tr>
    <tr><td class="paramname">offset</td><td>The texture offset in world coordinates </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a8e6485358863058537ce1b61cbb6b994"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8e6485358863058537ce1b61cbb6b994">&#9670;&nbsp;</a></span>draw() <span class="overload">[18/18]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void cugl::SpriteBatch::draw </td>
          <td>(</td>
          <td class="paramtype">const std::shared_ptr&lt; <a class="el" href="classcugl_1_1_texture.html">Texture</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>texture</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classcugl_1_1_vec2.html">Vec2</a>&#160;</td>
          <td class="paramname"><em>position</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Draws the texture (without tint) at the given position</p>
<p>This is a convenience method that calls the appropriate fill method. It sets both the texture and color (removing the previous active values). It then draws a rectangle of the size of the texture, with bottom left corner at the given position.</p>
<p>If depth testing is on, all vertices will be the current depth.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">texture</td><td>The new active texture </td></tr>
    <tr><td class="paramname">position</td><td>The bottom left corner of the texture </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aa19d39209e70a6be006c2371de0c63a1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa19d39209e70a6be006c2371de0c63a1">&#9670;&nbsp;</a></span>end()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void cugl::SpriteBatch::end </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Completes the drawing pass for this sprite batch, flushing the buffer.</p>
<p>This method enables depth writes and disables blending and texturing. It must always be called after a call to <a class="el" href="classcugl_1_1_sprite_batch.html#a631a3759f253a59c79000f0736792dcf">begin</a>. </p>

</div>
</div>
<a id="af107824ef2b801505d0f5e9ed1d74481"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af107824ef2b801505d0f5e9ed1d74481">&#9670;&nbsp;</a></span>fill() <span class="overload">[1/10]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void cugl::SpriteBatch::fill </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classcugl_1_1_mesh.html">Mesh</a>&lt; <a class="el" href="classcugl_1_1_sprite_vertex2.html">SpriteVertex2</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>mesh</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classcugl_1_1_mat4.html">Mat4</a> &amp;&#160;</td>
          <td class="paramname"><em>transform</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>tint</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Fills the given mesh with the current texture and/or gradient.</p>
<p>This method provides more fine tuned control over texture coordinates that the other fill methods. The texture no longer needs to be drawn uniformly over the shape. The transform will be applied to the vertex positions directly in world space. If depth testing is on, all vertices will be the current depth.</p>
<p>The triangulation will be determined by the mesh indices. If necessary, these can be generated via one of the triangulation factories <a class="el" href="classcugl_1_1_simple_triangulator.html">SimpleTriangulator</a> or <a class="el" href="classcugl_1_1_complex_triangulator.html">ComplexTriangulator</a>.</p>
<p>The mesh vertices use their own color values. However, if tint is true, these values will be tinted (i.e. multiplied) by the current active color.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">mesh</td><td>The sprite mesh </td></tr>
    <tr><td class="paramname">transform</td><td>The coordinate transform </td></tr>
    <tr><td class="paramname">tint</td><td>Whether to tint with the active color </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a21e16d3ccc3af8d8423406403e81e5e1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a21e16d3ccc3af8d8423406403e81e5e1">&#9670;&nbsp;</a></span>fill() <span class="overload">[2/10]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void cugl::SpriteBatch::fill </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classcugl_1_1_mesh.html">Mesh</a>&lt; <a class="el" href="classcugl_1_1_sprite_vertex3.html">SpriteVertex3</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>mesh</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classcugl_1_1_mat4.html">Mat4</a> &amp;&#160;</td>
          <td class="paramname"><em>transform</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>tint</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Fills the given mesh with the current texture and/or gradient.</p>
<p>This method provides more fine tuned control over texture coordinates that the other fill methods. The texture no longer needs to be drawn uniformly over the shape. The transform will be applied to the vertex positions directly in world space. This method will use the depth of each vertex and ignore the sprite batch depth</p>
<p>The triangulation will be determined by the mesh indices. If necessary, these can be generated via one of the triangulation factories <a class="el" href="classcugl_1_1_simple_triangulator.html">SimpleTriangulator</a> or <a class="el" href="classcugl_1_1_complex_triangulator.html">ComplexTriangulator</a>.</p>
<p>The mesh vertices use their own color values. However, if tint is true, these values will be tinted (i.e. multiplied) by the current active color.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">mesh</td><td>The sprite mesh </td></tr>
    <tr><td class="paramname">transform</td><td>The coordinate transform </td></tr>
    <tr><td class="paramname">tint</td><td>Whether to tint with the active color </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aa29b9d75dd9fbc971eeef37b4d5bafc5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa29b9d75dd9fbc971eeef37b4d5bafc5">&#9670;&nbsp;</a></span>fill() <span class="overload">[3/10]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void cugl::SpriteBatch::fill </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classcugl_1_1_poly2.html">Poly2</a> &amp;&#160;</td>
          <td class="paramname"><em>poly</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Draws the given polygon filled with the current color and texture.</p>
<p>The polygon tesselation will be determined by the indices in poly. If the polygon has not been triangulated (by one of the triangulation factories <a class="el" href="classcugl_1_1_simple_triangulator.html">SimpleTriangulator</a> or <a class="el" href="classcugl_1_1_complex_triangulator.html">ComplexTriangulator</a>, it may not draw properly.</p>
<p>The vertex coordinates will be determined by polygon vertex position. A horizontal position x has texture coordinate x/texture.width. A vertical coordinate has texture coordinate 1-y/texture.height. As a result, a rectangular polygon that has the same dimensions as the texture is the same as simply drawing the texture. <br  />
</p>
<p>One way to think of the polygon is as a "cookie cutter". Treat the polygon coordinates as pixel coordinates in the texture file, and use that to determine how the texture fills the polygon. This may make the polygon larger than you like in order to get the appropriate texturing. You should use one of the transform methods to fix this.</p>
<p>If depth testing is on, all vertices will be the current depth.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">poly</td><td>The polygon to draw </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a0d9f7ee60fade972db0575ed3005e1f9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0d9f7ee60fade972db0575ed3005e1f9">&#9670;&nbsp;</a></span>fill() <span class="overload">[4/10]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void cugl::SpriteBatch::fill </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classcugl_1_1_poly2.html">Poly2</a> &amp;&#160;</td>
          <td class="paramname"><em>poly</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classcugl_1_1_vec2.html">Vec2</a>&#160;</td>
          <td class="paramname"><em>offset</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Draws the given polygon filled with the current color and texture.</p>
<p>The polygon will be offset by the given position.</p>
<p>The polygon tesselation will be determined by the indices in poly. If the polygon has not been triangulated (by one of the triangulation factories <a class="el" href="classcugl_1_1_simple_triangulator.html">SimpleTriangulator</a> or <a class="el" href="classcugl_1_1_complex_triangulator.html">ComplexTriangulator</a>, it may not draw properly.</p>
<p>The vertex coordinates will be determined by polygon vertex position. A horizontal position x has texture coordinate x/texture.width. A vertical coordinate has texture coordinate 1-y/texture.height. As a result, a rectangular polygon that has the same dimensions as the texture is the same as simply drawing the texture.</p>
<p>One way to think of the polygon is as a "cookie cutter". Treat the polygon coordinates as pixel coordinates in the texture file, and use that to determine how the texture fills the polygon. This may make the polygon larger than you like in order to get the appropriate texturing. You should use one of the transform methods to fix this.</p>
<p>If depth testing is on, all vertices will be the current depth.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">poly</td><td>The polygon to draw </td></tr>
    <tr><td class="paramname">offset</td><td>The polygon offset </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a54b0b437487a095cf42c9804777ad2bc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a54b0b437487a095cf42c9804777ad2bc">&#9670;&nbsp;</a></span>fill() <span class="overload">[5/10]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void cugl::SpriteBatch::fill </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classcugl_1_1_poly2.html">Poly2</a> &amp;&#160;</td>
          <td class="paramname"><em>poly</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classcugl_1_1_vec2.html">Vec2</a>&#160;</td>
          <td class="paramname"><em>origin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classcugl_1_1_mat4.html">Mat4</a> &amp;&#160;</td>
          <td class="paramname"><em>transform</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Draws the given polygon filled with the current color and texture.</p>
<p>The polygon will transformed by the given matrix. The transform will be applied assuming the given origin, which is specified relative to the origin of the polygon (not world coordinates). Hence this origin is essentially the pixel coordinate of the texture (see below) to assign as the origin of this transform.</p>
<p>The polygon tesselation will be determined by the indices in poly. If the polygon has not been triangulated (by one of the triangulation factories <a class="el" href="classcugl_1_1_simple_triangulator.html">SimpleTriangulator</a> or <a class="el" href="classcugl_1_1_complex_triangulator.html">ComplexTriangulator</a>, it may not draw properly.</p>
<p>The vertex coordinates will be determined by polygon vertex position. A horizontal position x has texture coordinate x/texture.width. A vertical coordinate has texture coordinate 1-y/texture.height. As a result, a rectangular polygon that has the same dimensions as the texture is the same as simply drawing the texture.</p>
<p>One way to think of the polygon is as a "cookie cutter". Treat the polygon coordinates as pixel coordinates in the texture file, and use that to determine how the texture fills the polygon. This may make the polygon larger than you like in order to get the appropriate texturing. You should use one of the transform methods to fix this.</p>
<p>If depth testing is on, all vertices will be the current depth.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">poly</td><td>The polygon to draw </td></tr>
    <tr><td class="paramname">origin</td><td>The image origin in pixel space </td></tr>
    <tr><td class="paramname">transform</td><td>The coordinate transform </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a4abfc7ac4c0742684b105afd3611b304"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4abfc7ac4c0742684b105afd3611b304">&#9670;&nbsp;</a></span>fill() <span class="overload">[6/10]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void cugl::SpriteBatch::fill </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classcugl_1_1_poly2.html">Poly2</a> &amp;&#160;</td>
          <td class="paramname"><em>poly</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classcugl_1_1_vec2.html">Vec2</a>&#160;</td>
          <td class="paramname"><em>origin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classcugl_1_1_vec2.html">Vec2</a>&#160;</td>
          <td class="paramname"><em>scale</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>angle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classcugl_1_1_vec2.html">Vec2</a>&#160;</td>
          <td class="paramname"><em>offset</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Draws the given polygon filled with the current color and texture.</p>
<p>The polygon will be scaled first, then rotated, and finally offset by the given position. Rotation is measured in radians and is counter clockwise from the x-axis. Rotation will be about the provided origin, which is specified relative to the origin of the polygon (not world coordinates). Hence this origin is essentially the pixel coordinate of the texture (see below) to assign as the rotational center.</p>
<p>The polygon tesselation will be determined by the indices in poly. If the polygon has not been triangulated (by one of the triangulation factories <a class="el" href="classcugl_1_1_simple_triangulator.html">SimpleTriangulator</a> or <a class="el" href="classcugl_1_1_complex_triangulator.html">ComplexTriangulator</a>, it may not draw properly.</p>
<p>The vertex coordinates will be determined by polygon vertex position. A horizontal position x has texture coordinate x/texture.width. A vertical coordinate has texture coordinate 1-y/texture.height. As a result, a rectangular polygon that has the same dimensions as the texture is the same as simply drawing the texture.</p>
<p>One way to think of the polygon is as a "cookie cutter". Treat the polygon coordinates as pixel coordinates in the texture file, and use that to determine how the texture fills the polygon. This may make the polygon larger than you like in order to get the appropriate texturing. You should use one of the transform methods to fix this.</p>
<p>If depth testing is on, all vertices will be the current depth.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">poly</td><td>The polygon to draw </td></tr>
    <tr><td class="paramname">origin</td><td>The image origin in pixel space </td></tr>
    <tr><td class="paramname">scale</td><td>The amount to scale the polygon </td></tr>
    <tr><td class="paramname">angle</td><td>The amount to rotate the polygon </td></tr>
    <tr><td class="paramname">offset</td><td>The polygon offset in world coordinates </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a95e4e47a8cb66d188ca49553d4696fad"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a95e4e47a8cb66d188ca49553d4696fad">&#9670;&nbsp;</a></span>fill() <span class="overload">[7/10]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void cugl::SpriteBatch::fill </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classcugl_1_1_rect.html">Rect</a>&#160;</td>
          <td class="paramname"><em>rect</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classcugl_1_1_vec2.html">Vec2</a>&#160;</td>
          <td class="paramname"><em>offset</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Draws the given rectangle filled with the current color and texture.</p>
<p>The texture will fill the entire rectangle with texture coordinate (0,1) at the bottom left corner identified by rect,origin. To draw only part of a texture, use a subtexture to fill the rectangle with the region [minS,maxS]x[min,maxT]. Alternatively, you can use a <a class="el" href="classcugl_1_1_poly2.html">Poly2</a> for more fine-tuned control.</p>
<p>If depth testing is on, all vertices will be the current depth.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">rect</td><td>The rectangle to draw </td></tr>
    <tr><td class="paramname">offset</td><td>The rectangle offset </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a06c5090bd9377a0b48b265b1d42bab96"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a06c5090bd9377a0b48b265b1d42bab96">&#9670;&nbsp;</a></span>fill() <span class="overload">[8/10]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void cugl::SpriteBatch::fill </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classcugl_1_1_rect.html">Rect</a>&#160;</td>
          <td class="paramname"><em>rect</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classcugl_1_1_vec2.html">Vec2</a>&#160;</td>
          <td class="paramname"><em>origin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classcugl_1_1_mat4.html">Mat4</a> &amp;&#160;</td>
          <td class="paramname"><em>transform</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Draws the given rectangle filled with the current color and texture.</p>
<p>The rectangle will transformed by the given matrix. The transform will be applied assuming the given origin, which is specified relative to the origin of the rectangle (not world coordinates). So to apply the transform to the center of the rectangle, the origin should be width/2, height/2 of the rectangle.</p>
<p>The texture will fill the entire rectangle with texture coordinate (0,1) at the bottom left corner identified by rect,origin. To draw only part of a texture, use a subtexture to fill the rectangle with the region [minS,maxS]x[min,maxT]. Alternatively, you can use a <a class="el" href="classcugl_1_1_poly2.html">Poly2</a> for more fine-tuned control.</p>
<p>If depth testing is on, all vertices will be the current depth.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">rect</td><td>The rectangle to draw </td></tr>
    <tr><td class="paramname">origin</td><td>The rotational offset in the rectangle </td></tr>
    <tr><td class="paramname">transform</td><td>The coordinate transform </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ae2ff2006ee69e3a5f63976582fec8f38"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae2ff2006ee69e3a5f63976582fec8f38">&#9670;&nbsp;</a></span>fill() <span class="overload">[9/10]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void cugl::SpriteBatch::fill </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classcugl_1_1_rect.html">Rect</a>&#160;</td>
          <td class="paramname"><em>rect</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classcugl_1_1_vec2.html">Vec2</a>&#160;</td>
          <td class="paramname"><em>origin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classcugl_1_1_vec2.html">Vec2</a>&#160;</td>
          <td class="paramname"><em>scale</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>angle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classcugl_1_1_vec2.html">Vec2</a>&#160;</td>
          <td class="paramname"><em>offset</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Draws the given rectangle filled with the current color and texture.</p>
<p>The rectangle will be scaled first, then rotated, and finally offset by the given position. Rotation is measured in radians and is counter clockwise from the x-axis. Rotation will be about the provided origin, which is specified relative to the origin of the rectangle (not world coordinates). So to spin about the center, the origin should be width/2, height/2 of the rectangle.</p>
<p>The texture will fill the entire rectangle before being transformed. <a class="el" href="classcugl_1_1_texture.html">Texture</a> coordinate (0,1) will at the bottom left corner identified by rect,origin. To draw only part of a texture, use a subtexture to fill the rectangle with the region [minS,maxS]x[min,maxT]. Alternatively, you can use a <a class="el" href="classcugl_1_1_poly2.html">Poly2</a> for more fine-tuned control.</p>
<p>If depth testing is on, all vertices will be the current depth.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">rect</td><td>The rectangle to draw </td></tr>
    <tr><td class="paramname">origin</td><td>The rotational offset in the rectangle </td></tr>
    <tr><td class="paramname">scale</td><td>The amount to scale the rectangle </td></tr>
    <tr><td class="paramname">angle</td><td>The amount to rotate the rectangle </td></tr>
    <tr><td class="paramname">offset</td><td>The rectangle offset in world coordinates </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="abdd11c656e840789ab480139cf2a2069"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abdd11c656e840789ab480139cf2a2069">&#9670;&nbsp;</a></span>fill() <span class="overload">[10/10]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void cugl::SpriteBatch::fill </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classcugl_1_1_rect.html">Rect</a>&#160;</td>
          <td class="paramname"><em>rect</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Draws the given rectangle filled with the current color and texture.</p>
<p>The texture will fill the entire rectangle with texture coordinate (0,1) at the bottom left corner identified by rect,origin. To draw only part of a texture, use a subtexture to fill the rectangle with the region [minS,maxS]x[min,maxT]. Alternatively, you can use a <a class="el" href="classcugl_1_1_poly2.html">Poly2</a> for more fine-tuned control.</p>
<p>If depth testing is on, all vertices will be the current depth.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">rect</td><td>The rectangle to draw </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ad4865921fb83cef24981dba2c1799934"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad4865921fb83cef24981dba2c1799934">&#9670;&nbsp;</a></span>flush()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void cugl::SpriteBatch::flush </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Flushes the current mesh without completing the drawing pass.</p>
<p>This method is called whenever you change any attribute other than color mid-pass. It prevents the attribute change from retoactively affecting previuosly drawn shapes. </p>

</div>
</div>
<a id="aaa55a44f97f484e1f392d3575e81bd30"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaa55a44f97f484e1f392d3575e81bd30">&#9670;&nbsp;</a></span>getBlendEquation()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">GLenum cugl::SpriteBatch::getBlendEquation </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns the blending equation for this sprite batch</p>
<p>By default this value is GL_FUNC_ADD. For other options, see </p><pre class="fragment"> https://www.opengl.org/sdk/docs/man/html/glBlendEquation.xhtml
</pre> <dl class="section return"><dt>Returns</dt><dd>the blending equation for this sprite batch </dd></dl>

</div>
</div>
<a id="a97e3cf5929abccb46cfaacaeb02a2a83"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a97e3cf5929abccb46cfaacaeb02a2a83">&#9670;&nbsp;</a></span>getBlurStep()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">GLuint cugl::SpriteBatch::getBlurStep </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns the blur step in pixels (0 if there is no blurring).</p>
<p>This sprite batch supports a simple 9-step blur. The blur samples from the center pixel and 8 other pixels around it in a box. The blur step is the number of pixels away to sample. So a 1-step blur samples from the immediate neighbor pixels. On most textures a 5-step blur has very noticeable affects.</p>
<p>This is not a full-featured Gaussian blur. In particular, large step values will start to produce a pixellation effect. But it can produce acceptable blur effects with little cost to performance. It is especially ideal for font-blur effects on font atlases.</p>
<p>Setting this value to 0 will disable texture blurring. This value is 0 by default.</p>
<dl class="section return"><dt>Returns</dt><dd>the blur step in pixels (0 if there is no blurring). </dd></dl>

</div>
</div>
<a id="a7939e483780df6fc49f8567896408ab7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7939e483780df6fc49f8567896408ab7">&#9670;&nbsp;</a></span>getCallsMade()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">unsigned int cugl::SpriteBatch::getCallsMade </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns the number of OpenGL calls in the latest pass (so far).</p>
<p>This value will be reset to 0 whenever <a class="el" href="classcugl_1_1_sprite_batch.html#a631a3759f253a59c79000f0736792dcf">begin()</a> is called.</p>
<dl class="section return"><dt>Returns</dt><dd>the number of OpenGL calls in the latest pass (so far). </dd></dl>

</div>
</div>
<a id="ac7c525abd47a4979221a0de722f812f9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac7c525abd47a4979221a0de722f812f9">&#9670;&nbsp;</a></span>getColor()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classcugl_1_1_color4f.html">Color4f</a> cugl::SpriteBatch::getColor </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns the active color of this sprite batch</p>
<p>All subsequent shapes and outlines drawn by this sprite batch will be tinted by this color. This color is white by default.</p>
<dl class="section return"><dt>Returns</dt><dd>the active color of this sprite batch </dd></dl>

</div>
</div>
<a id="ae98c4f47f5309c06f98b78007dff0c8d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae98c4f47f5309c06f98b78007dff0c8d">&#9670;&nbsp;</a></span>getDepth()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">float cugl::SpriteBatch::getDepth </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns the current depth of this sprite batch.</p>
<p>The depth value is appended to all 2d shapes drawn by this sprite batch. If depth testing is enabled, this can allow the sprite batch to draw shapes out of order. This value is 0 by default.</p>
<dl class="section return"><dt>Returns</dt><dd>the current depth of this sprite batch. </dd></dl>

</div>
</div>
<a id="aecd4f422594c13b12abeb9b50289c920"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aecd4f422594c13b12abeb9b50289c920">&#9670;&nbsp;</a></span>getDepthFunc()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">GLenum cugl::SpriteBatch::getDepthFunc </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns the depth testing function for this sprite batch</p>
<p>By default this value is GL_ALWAYS, disabling all depth testing. For other options, see </p><pre class="fragment"> https://www.opengl.org/sdk/docs/man/html/glDepthFunc.xhtml
</pre> <dl class="section return"><dt>Returns</dt><dd>the depth testing function for this sprite batch </dd></dl>

</div>
</div>
<a id="aa8023e5960915cbff51f07c1c4b8ab3c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa8023e5960915cbff51f07c1c4b8ab3c">&#9670;&nbsp;</a></span>getDestinationBlendFactor()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">GLenum cugl::SpriteBatch::getDestinationBlendFactor </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns the destination blending factor</p>
<p>By default this value is GL_ONE_MINUS_SRC_ALPHA. For other options, see </p><pre class="fragment"> https://www.opengl.org/sdk/docs/man/html/glBlendFunc.xhtml
</pre> <dl class="section return"><dt>Returns</dt><dd>the destination blending factor </dd></dl>

</div>
</div>
<a id="a80fc0d03c6d4c7091fdbfe20f9e666ea"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a80fc0d03c6d4c7091fdbfe20f9e666ea">&#9670;&nbsp;</a></span>getGradient()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::shared_ptr&lt;<a class="el" href="classcugl_1_1_gradient.html">Gradient</a>&gt; cugl::SpriteBatch::getGradient </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns the active gradient of this sprite batch</p>
<p>Gradients may be used in the place of (and together with) colors. Gradients are applied textures, and use the first two attrbutes of the color attribute in <a class="el" href="classcugl_1_1_sprite_vertex2.html">SpriteVertex2</a> as texture coordinates. The last two coordinates (z and w) can used for minor feather adjustments in linear gradients (for smooth stroke effects).</p>
<p>If this value is nullptr, then no gradient is active. In that case, the color vertex attribute will be interpretted as normal (e.g. a traditional color vector). This value is nullptr by default.</p>
<p>All gradients are tinted by the active color. Unless you explicitly want this tinting, you should set the active color to white before drawing with an active gradient.</p>
<p>This method returns a copy of the internal gradient. Changes to this object have no effect on the sprite batch.</p>
<dl class="section return"><dt>Returns</dt><dd>The active gradient for this sprite batch </dd></dl>

</div>
</div>
<a id="a4e1f897aa822536533115f2255cdbf0b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4e1f897aa822536533115f2255cdbf0b">&#9670;&nbsp;</a></span>getPerspective()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classcugl_1_1_mat4.html">Mat4</a>&amp; cugl::SpriteBatch::getPerspective </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns the active perspective matrix of this sprite batch</p>
<p>The perspective matrix is the combined modelview-projection from the camera. By default, this is the identity matrix.</p>
<dl class="section return"><dt>Returns</dt><dd>the active perspective matrix of this sprite batch </dd></dl>

</div>
</div>
<a id="afd812d1b07452383e161cbfef22cfb6e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afd812d1b07452383e161cbfef22cfb6e">&#9670;&nbsp;</a></span>getScissor()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::shared_ptr&lt;<a class="el" href="classcugl_1_1_scissor.html">Scissor</a>&gt; cugl::SpriteBatch::getScissor </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns the active scissor mask of this sprite batch</p>
<p><a class="el" href="classcugl_1_1_scissor.html">Scissor</a> masks may be combined with all types of drawing (colors, textures, and gradients). They are specified in the same coordinate system as <a class="el" href="classcugl_1_1_sprite_batch.html#a4e1f897aa822536533115f2255cdbf0b">getPerspective</a>.</p>
<p>If this value is nullptr, then no scissor mask is active. This value is nullptr by default.</p>
<p>This method returns a copy of the internal scissor. Changes to this object have no effect on the sprite batch.</p>
<dl class="section return"><dt>Returns</dt><dd>The active scissor mask for this sprite batch </dd></dl>

</div>
</div>
<a id="a13675f4d638c0f35d840ae3ea273988d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a13675f4d638c0f35d840ae3ea273988d">&#9670;&nbsp;</a></span>getShader()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const std::shared_ptr&lt;<a class="el" href="classcugl_1_1_shader.html">Shader</a>&gt;&amp; cugl::SpriteBatch::getShader </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns the shader for this sprite batch</p>
<p>This value may NOT be changed during a drawing pass. See the class description for the properties of a valid shader.</p>
<dl class="section return"><dt>Returns</dt><dd>the shader for this sprite batch </dd></dl>

</div>
</div>
<a id="aef0bcfe75ec48b57641cc6316f2a1887"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aef0bcfe75ec48b57641cc6316f2a1887">&#9670;&nbsp;</a></span>getSourceBlendFactor()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">GLenum cugl::SpriteBatch::getSourceBlendFactor </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns the source blending factor</p>
<p>By default this value is GL_SRC_ALPHA. For other options, see </p><pre class="fragment"> https://www.opengl.org/sdk/docs/man/html/glBlendFunc.xhtml
</pre> <dl class="section return"><dt>Returns</dt><dd>the source blending factor </dd></dl>

</div>
</div>
<a id="ad635085d9d5a04c94ecc894a51d77385"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad635085d9d5a04c94ecc894a51d77385">&#9670;&nbsp;</a></span>getTexture()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const std::shared_ptr&lt;<a class="el" href="classcugl_1_1_texture.html">Texture</a>&gt;&amp; cugl::SpriteBatch::getTexture </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns the active texture of this sprite batch</p>
<p>All subsequent shapes and outlines drawn by this sprite batch will use this texture. If the value is nullptr, all shapes and outlines will be drawn with a solid color instead. This value is nullptr by default.</p>
<dl class="section return"><dt>Returns</dt><dd>the active texture of this sprite batch </dd></dl>

</div>
</div>
<a id="a2ccb078d512f27346c1f6cf7a1886508"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2ccb078d512f27346c1f6cf7a1886508">&#9670;&nbsp;</a></span>getVerticesDrawn()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">unsigned int cugl::SpriteBatch::getVerticesDrawn </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns the number of vertices drawn in the latest pass (so far).</p>
<p>This value will be reset to 0 whenever <a class="el" href="classcugl_1_1_sprite_batch.html#a631a3759f253a59c79000f0736792dcf">begin()</a> is called.</p>
<dl class="section return"><dt>Returns</dt><dd>the number of vertices drawn in the latest pass (so far). </dd></dl>

</div>
</div>
<a id="a5370fa1d9e46913ae2845173231481f9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5370fa1d9e46913ae2845173231481f9">&#9670;&nbsp;</a></span>init() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool cugl::SpriteBatch::init </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Initializes a sprite batch with the default vertex capacity.</p>
<p>The default vertex capacity is 8192 vertices and 8192*3 = 24576 indices. If the mesh exceeds these values, the sprite batch will flush before before continuing to draw. Similarly uniform buffer is initialized with 512 buffer positions. This means that the uniform buffer is comparable in memory size to the vertices, but only allows 512 gradient or scissor mask context switches before the sprite batch must flush. If you wish to increase (or decrease) the capacity, use the alternate initializer.</p>
<p>The sprite batch begins with no active texture, and the color white. The perspective matrix is the identity.</p>
<dl class="section return"><dt>Returns</dt><dd>true if initialization was successful. </dd></dl>

</div>
</div>
<a id="a72a8f45ef09781f145752cb9b60b444b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a72a8f45ef09781f145752cb9b60b444b">&#9670;&nbsp;</a></span>init() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool cugl::SpriteBatch::init </td>
          <td>(</td>
          <td class="paramtype">const std::shared_ptr&lt; <a class="el" href="classcugl_1_1_shader.html">Shader</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>shader</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Initializes a sprite batch with the default vertex capacity and given shader</p>
<p>The default vertex capacity is 8192 vertices and 8192*3 = 24576 indices. If the mesh exceeds these values, the sprite batch will flush before before continuing to draw. Similarly uniform buffer is initialized with 512 buffer positions. This means that the uniform buffer is comparable in memory size to the vertices, but only allows 512 gradient or scissor mask context switches before the sprite batch must flush. If you wish to increase (or decrease) the capacity, use the alternate initializer.</p>
<p>The sprite batch begins with no active texture, and the color white. The perspective matrix is the identity.</p>
<p>See the class description for the properties of a valid shader.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">shader</td><td>The shader to use for this spritebatch</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if initialization was successful. </dd></dl>

</div>
</div>
<a id="ac14e11a9542a2524a16d50ead5d67c31"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac14e11a9542a2524a16d50ead5d67c31">&#9670;&nbsp;</a></span>init() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool cugl::SpriteBatch::init </td>
          <td>(</td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>capacity</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Initializes a sprite batch with the given vertex capacity.</p>
<p>The index capacity will be 3 times the vertex capacity. The maximum number of possible indices is the maximum size_t, so the vertex size must be a third that. In addition, the sprite batch will allocate 1/16 of the vertex capacity for uniform blocks (for gradients and scissor masks). This means that the uniform buffer is comparable in memory size to the vertices while still allowing a reasonably high rate of change for quads and regularly shaped sprites.</p>
<p>If the mesh exceeds the capacity, the sprite batch will flush before before continuing to draw. You should tune your system to have the appropriate capacity. To small a capacity will cause the system to thrash. However, too large a capacity could stall on memory transfers.</p>
<p>The sprite batch begins with no active texture, and the color white. The perspective matrix is the identity.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">capacity</td><td>The vertex capacity of this spritebatch</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if initialization was successful. </dd></dl>

</div>
</div>
<a id="a37d87c1dfb92d15463e9152c8438ed71"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a37d87c1dfb92d15463e9152c8438ed71">&#9670;&nbsp;</a></span>init() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool cugl::SpriteBatch::init </td>
          <td>(</td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>capacity</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::shared_ptr&lt; <a class="el" href="classcugl_1_1_shader.html">Shader</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>shader</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Initializes a sprite batch with the given vertex capacity and shader</p>
<p>The index capacity will be 3 times the vertex capacity. The maximum number of possible indices is the maximum size_t, so the vertex size must be a third that. In addition, the sprite batch will allocate 1/16 of the vertex capacity for uniform blocks (for gradients and scissor masks). This means that the uniform buffer is comparable in memory size to the vertices while still allowing a reasonably high rate of change for quads and regularly shaped sprites.</p>
<p>If the mesh exceeds the capacity, the sprite batch will flush before before continuing to draw. You should tune your system to have the appropriate capacity. To small a capacity will cause the system to thrash. However, too large a capacity could stall on memory transfers.</p>
<p>The sprite batch begins with no active texture, and the color white. The perspective matrix is the identity.</p>
<p>See the class description for the properties of a valid shader.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">capacity</td><td>The vertex capacity of this spritebatch </td></tr>
    <tr><td class="paramname">shader</td><td>The shader to use for this spritebatch</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if initialization was successful. </dd></dl>

</div>
</div>
<a id="a7a9481417eff55b2916d3a6b7bfa4695"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7a9481417eff55b2916d3a6b7bfa4695">&#9670;&nbsp;</a></span>isDrawing()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool cugl::SpriteBatch::isDrawing </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns whether this sprite batch is actively drawing.</p>
<p>A sprite batch is in use if <a class="el" href="classcugl_1_1_sprite_batch.html#a631a3759f253a59c79000f0736792dcf">begin()</a> has been called without the requisite <a class="el" href="classcugl_1_1_sprite_batch.html#aa19d39209e70a6be006c2371de0c63a1">end()</a> to flush the pipeline.</p>
<dl class="section return"><dt>Returns</dt><dd>whether this sprite batch is actively drawing. </dd></dl>

</div>
</div>
<a id="a4a8f3118b1f150366871ba5ce01be4d7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4a8f3118b1f150366871ba5ce01be4d7">&#9670;&nbsp;</a></span>isReady()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool cugl::SpriteBatch::isReady </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns true if this sprite batch has been initialized and is ready for use.</p>
<dl class="section return"><dt>Returns</dt><dd>true if this sprite batch has been initialized and is ready for use. </dd></dl>

</div>
</div>
<a id="a824550d9feb56f7c9440a0d92621ac96"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a824550d9feb56f7c9440a0d92621ac96">&#9670;&nbsp;</a></span>outline() <span class="overload">[1/10]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void cugl::SpriteBatch::outline </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classcugl_1_1_mesh.html">Mesh</a>&lt; <a class="el" href="classcugl_1_1_sprite_vertex2.html">SpriteVertex2</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>mesh</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classcugl_1_1_mat4.html">Mat4</a> &amp;&#160;</td>
          <td class="paramname"><em>transform</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>tint</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Outlines the given mesh with the current texture and/or gradient.</p>
<p>This method provides more fine tuned control over texture coordinates that the other fill methods. The texture no longer needs to be drawn uniformly over the shape. The transform will be applied to the vertex positions directly in world space. If depth testing is on, all vertices will be the current depth.</p>
<p>The triangulation will be determined by the mesh indices. If necessary, these can be generated via one of the triangulation factories <a class="el" href="classcugl_1_1_simple_triangulator.html">SimpleTriangulator</a> or <a class="el" href="classcugl_1_1_complex_triangulator.html">ComplexTriangulator</a>.</p>
<p>The mesh vertices use their own color values. However, if tint is true, these values will be tinted (i.e. multiplied) by the current active color.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">mesh</td><td>The sprite mesh </td></tr>
    <tr><td class="paramname">transform</td><td>The coordinate transform </td></tr>
    <tr><td class="paramname">tint</td><td>Whether to tint with the active color </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a095740cad8cb02821fc291647cc6a948"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a095740cad8cb02821fc291647cc6a948">&#9670;&nbsp;</a></span>outline() <span class="overload">[2/10]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void cugl::SpriteBatch::outline </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classcugl_1_1_mesh.html">Mesh</a>&lt; <a class="el" href="classcugl_1_1_sprite_vertex3.html">SpriteVertex3</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>mesh</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classcugl_1_1_mat4.html">Mat4</a> &amp;&#160;</td>
          <td class="paramname"><em>transform</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>tint</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Outlines the given mesh with the current texture and/or gradient.</p>
<p>This method provides more fine tuned control over texture coordinates that the other fill methods. The texture no longer needs to be drawn uniformly over the shape. The transform will be applied to the vertex positions directly in world space. This method will use the depth of each vertex and ignore the sprite batch depth</p>
<p>The triangulation will be determined by the mesh indices. If necessary, these can be generated via one of the triangulation factories <a class="el" href="classcugl_1_1_simple_triangulator.html">SimpleTriangulator</a> or <a class="el" href="classcugl_1_1_complex_triangulator.html">ComplexTriangulator</a>.</p>
<p>The mesh vertices use their own color values. However, if tint is true, these values will be tinted (i.e. multiplied) by the current active color.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">mesh</td><td>The sprite mesh </td></tr>
    <tr><td class="paramname">transform</td><td>The coordinate transform </td></tr>
    <tr><td class="paramname">tint</td><td>Whether to tint with the active color </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a2f40e476e271b1b77649584f3e220393"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2f40e476e271b1b77649584f3e220393">&#9670;&nbsp;</a></span>outline() <span class="overload">[3/10]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void cugl::SpriteBatch::outline </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classcugl_1_1_poly2.html">Poly2</a> &amp;&#160;</td>
          <td class="paramname"><em>poly</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Outlines the given polygon with the current color and texture.</p>
<p>The polygon path will be determined by the indices in poly. The indices should be a multiple of two, preferably generated by the factories <a class="el" href="classcugl_1_1_poly_factory.html">PolyFactory</a> or <a class="el" href="classcugl_1_1_poly_spline_factory.html">PolySplineFactory</a>.</p>
<p>The drawing will be a wireframe of a polygon, but the lines are textured. The vertex coordinates will be determined by polygon vertex position. A horizontal position x has texture coordinate x/texture.width. A vertical coordinate has texture coordinate 1-y/texture.height. As a result, a rectangular polygon that has the same dimensions as the texture is the same as simply outlines the rectangle.</p>
<p>One way to think of the polygon is as a "cookie cutter". Treat the polygon coordinates as pixel coordinates in the texture file, and use that to determine how the texture fills the polygon. This may make the polygon larger than you like in order to get the appropriate texturing. You should use one of the transform methods to fix this.</p>
<p>If depth testing is on, all vertices will be the current depth.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">poly</td><td>The polygon to outline </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a71c8e126ff7005b894c1605d50f700ff"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a71c8e126ff7005b894c1605d50f700ff">&#9670;&nbsp;</a></span>outline() <span class="overload">[4/10]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void cugl::SpriteBatch::outline </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classcugl_1_1_poly2.html">Poly2</a> &amp;&#160;</td>
          <td class="paramname"><em>poly</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classcugl_1_1_vec2.html">Vec2</a>&#160;</td>
          <td class="paramname"><em>offset</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Outlines the given polygon with the current color and texture.</p>
<p>The polygon will be offset by the given position.</p>
<p>The polygon path will be determined by the indices in poly. The indices should be a multiple of two, preferably generated by the factories <a class="el" href="classcugl_1_1_poly_factory.html">PolyFactory</a> or <a class="el" href="classcugl_1_1_poly_spline_factory.html">PolySplineFactory</a>.</p>
<p>The drawing will be a wireframe of a polygon, but the lines are textured. The vertex coordinates will be determined by polygon vertex position. A horizontal position x has texture coordinate x/texture.width. A vertical coordinate has texture coordinate 1-y/texture.height. As a result, a rectangular polygon that has the same dimensions as the texture is the same as simply outlines the rectangle.</p>
<p>One way to think of the polygon is as a "cookie cutter". Treat the polygon coordinates as pixel coordinates in the texture file, and use that to determine how the texture fills the polygon. This may make the polygon larger than you like in order to get the appropriate texturing. You should use one of the transform methods to fix this.</p>
<p>If depth testing is on, all vertices will be the current depth.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">poly</td><td>The polygon to outline </td></tr>
    <tr><td class="paramname">offset</td><td>The polygon offset </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a7a4903a85f26ebcd87fe51947ccbbf31"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7a4903a85f26ebcd87fe51947ccbbf31">&#9670;&nbsp;</a></span>outline() <span class="overload">[5/10]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void cugl::SpriteBatch::outline </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classcugl_1_1_poly2.html">Poly2</a> &amp;&#160;</td>
          <td class="paramname"><em>poly</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classcugl_1_1_vec2.html">Vec2</a>&#160;</td>
          <td class="paramname"><em>origin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classcugl_1_1_mat4.html">Mat4</a> &amp;&#160;</td>
          <td class="paramname"><em>transform</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Outlines the given polygon with the current color and texture.</p>
<p>The polygon will transformed by the given matrix. The transform will be applied assuming the given origin, which is specified relative to the origin of the polygon (not world coordinates). Hence this origin is essentially the pixel coordinate of the texture (see below) to assign as the origin of this transform.</p>
<p>The polygon path will be determined by the indices in poly. The indices should be a multiple of two, preferably generated by the factories <a class="el" href="classcugl_1_1_poly_factory.html">PolyFactory</a> or <a class="el" href="classcugl_1_1_poly_spline_factory.html">PolySplineFactory</a>.</p>
<p>The drawing will be a wireframe of a polygon, but the lines are textured. The vertex coordinates will be determined by polygon vertex position. A horizontal position x has texture coordinate x/texture.width. A vertical coordinate has texture coordinate 1-y/texture.height. As a result, a rectangular polygon that has the same dimensions as the texture is the same as simply outlines the rectangle.</p>
<p>One way to think of the polygon is as a "cookie cutter". Treat the polygon coordinates as pixel coordinates in the texture filed, and use that to determine how the texture fills the polygon. This may make the polygon larger than you like in order to get the appropriate texturing. You should use one of the transform methods to fix this.</p>
<p>If depth testing is on, all vertices will be the current depth.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">poly</td><td>The polygon to outline </td></tr>
    <tr><td class="paramname">origin</td><td>The image origin in pixel space </td></tr>
    <tr><td class="paramname">transform</td><td>The coordinate transform </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a2e4934be576d47f250f682cbd3958631"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2e4934be576d47f250f682cbd3958631">&#9670;&nbsp;</a></span>outline() <span class="overload">[6/10]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void cugl::SpriteBatch::outline </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classcugl_1_1_poly2.html">Poly2</a> &amp;&#160;</td>
          <td class="paramname"><em>poly</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classcugl_1_1_vec2.html">Vec2</a>&#160;</td>
          <td class="paramname"><em>origin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classcugl_1_1_vec2.html">Vec2</a>&#160;</td>
          <td class="paramname"><em>scale</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>angle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classcugl_1_1_vec2.html">Vec2</a>&#160;</td>
          <td class="paramname"><em>offset</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Outlines the given polygon with the current color and texture.</p>
<p>The polygon will be scaled first, then rotated, and finally offset by the given position. Rotation is measured in radians and is counter clockwise from the x-axis. Rotation will be about the provided origin, which is specified relative to the origin of the polygon (not world coordinates). Hence this origin is essentially the pixel coordinate of the texture (see below) to assign as the rotational center.</p>
<p>The polygon path will be determined by the indices in poly. The indices should be a multiple of two, preferably generated by the factories <a class="el" href="classcugl_1_1_poly_factory.html">PolyFactory</a> or <a class="el" href="classcugl_1_1_poly_spline_factory.html">PolySplineFactory</a>.</p>
<p>The drawing will be a wireframe of a polygon, but the lines are textured. The vertex coordinates will be determined by polygon vertex position. A horizontal position x has texture coordinate x/texture.width. A vertical coordinate has texture coordinate 1-y/texture.height. As a result, a rectangular polygon that has the same dimensions as the texture is the same as simply outlines the rectangle.</p>
<p>One way to think of the polygon is as a "cookie cutter". Treat the polygon coordinates as pixel coordinates in the texture file, and use that to determine how the texture fills the polygon. This may make the polygon larger than you like in order to get the appropriate texturing. You should use one of the transform methods to fix this.</p>
<p>If depth testing is on, all vertices will be the current depth.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">poly</td><td>The polygon to outline </td></tr>
    <tr><td class="paramname">origin</td><td>The image origin in pixel space </td></tr>
    <tr><td class="paramname">scale</td><td>The amount to scale the polygon </td></tr>
    <tr><td class="paramname">angle</td><td>The amount to rotate the polygon </td></tr>
    <tr><td class="paramname">offset</td><td>The polygon offset in world coordinates </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aa5037e3fcab54229cb4126d505e3c08d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa5037e3fcab54229cb4126d505e3c08d">&#9670;&nbsp;</a></span>outline() <span class="overload">[7/10]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void cugl::SpriteBatch::outline </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classcugl_1_1_rect.html">Rect</a>&#160;</td>
          <td class="paramname"><em>rect</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Outlines the given rectangle with the current color and texture.</p>
<p>The drawing will be a wireframe of a rectangle. The wireframe will be textured with <a class="el" href="classcugl_1_1_texture.html">Texture</a> coordinate (0,1) at the bottom left corner identified by rect,origin. The remaining edges will correspond to the edges of the texture. To draw only part of a texture, use a subtexture to outline the edges with [minS,maxS]x[min,maxT]. Alternatively, you can use a <a class="el" href="classcugl_1_1_poly2.html">Poly2</a> for more fine-tuned control.</p>
<p>If depth testing is on, all vertices will be the current depth.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">rect</td><td>The rectangle to outline </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a0c479285bf7da3b90f2d68e3831f5d7b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0c479285bf7da3b90f2d68e3831f5d7b">&#9670;&nbsp;</a></span>outline() <span class="overload">[8/10]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void cugl::SpriteBatch::outline </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classcugl_1_1_rect.html">Rect</a>&#160;</td>
          <td class="paramname"><em>rect</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classcugl_1_1_vec2.html">Vec2</a>&#160;</td>
          <td class="paramname"><em>offset</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Outlines the given rectangle with the current color and texture.</p>
<p>The drawing will be a wireframe of a rectangle. The wireframe will be textured with <a class="el" href="classcugl_1_1_texture.html">Texture</a> coordinate (0,1) at the bottom left corner identified by rect,origin. The remaining edges will correspond to the edges of the texture. To draw only part of a texture, use a subtexture to outline the edges with [minS,maxS]x[min,maxT]. Alternatively, you can use a <a class="el" href="classcugl_1_1_poly2.html">Poly2</a> for more fine-tuned control.</p>
<p>If depth testing is on, all vertices will be the current depth.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">rect</td><td>The rectangle to outline </td></tr>
    <tr><td class="paramname">offset</td><td>The rectangle offset </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a1bf0fcb14c014433e03e4eb6570641bd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1bf0fcb14c014433e03e4eb6570641bd">&#9670;&nbsp;</a></span>outline() <span class="overload">[9/10]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void cugl::SpriteBatch::outline </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classcugl_1_1_rect.html">Rect</a>&#160;</td>
          <td class="paramname"><em>rect</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classcugl_1_1_vec2.html">Vec2</a>&#160;</td>
          <td class="paramname"><em>origin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classcugl_1_1_mat4.html">Mat4</a> &amp;&#160;</td>
          <td class="paramname"><em>transform</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Outlines the given rectangle with the current color and texture.</p>
<p>The rectangle will transformed by the given matrix. The transform will be applied assuming the given origin, which is specified relative to the origin of the rectangle (not world coordinates). So to apply the transform to the center of the rectangle, the origin should be width/2, height/2 of the rectangle.</p>
<p>The drawing will be a wireframe of a rectangle. The wireframe will be textured with <a class="el" href="classcugl_1_1_texture.html">Texture</a> coordinate (0,1) at the bottom left corner identified by rect,origin. The remaining edges will correspond to the edges of the texture. To draw only part of a texture, use a subtexture to outline the edges with [minS,maxS]x[min,maxT]. Alternatively, you can use a <a class="el" href="classcugl_1_1_poly2.html">Poly2</a> for more fine-tuned control.</p>
<p>If depth testing is on, all vertices will be the current depth.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">rect</td><td>The rectangle to outline </td></tr>
    <tr><td class="paramname">origin</td><td>The rotational offset in the rectangle </td></tr>
    <tr><td class="paramname">transform</td><td>The coordinate transform </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a96948ca8110e3cfde4831d79c72227cf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a96948ca8110e3cfde4831d79c72227cf">&#9670;&nbsp;</a></span>outline() <span class="overload">[10/10]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void cugl::SpriteBatch::outline </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classcugl_1_1_rect.html">Rect</a>&#160;</td>
          <td class="paramname"><em>rect</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classcugl_1_1_vec2.html">Vec2</a>&#160;</td>
          <td class="paramname"><em>origin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classcugl_1_1_vec2.html">Vec2</a>&#160;</td>
          <td class="paramname"><em>scale</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>angle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classcugl_1_1_vec2.html">Vec2</a>&#160;</td>
          <td class="paramname"><em>offset</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Outlines the given rectangle with the current color and texture.</p>
<p>The rectangle will be scaled first, then rotated, and finally offset by the given position. Rotation is measured in radians and is counter clockwise from the x-axis. Rotation will be about the provided origin, which is specified relative to the origin of the rectangle (not world coordinates). So to spin about the center, the origin should be width/2, height/2 of the rectangle.</p>
<p>The drawing will be a wireframe of a rectangle. The wireframe will be textured with <a class="el" href="classcugl_1_1_texture.html">Texture</a> coordinate (0,1) at the bottom left corner identified by rect,origin. The remaining edges will correspond to the edges of the texture. To draw only part of a texture, use a subtexture to outline the edges with [minS,maxS]x[min,maxT]. Alternatively, you can use a <a class="el" href="classcugl_1_1_poly2.html">Poly2</a> for more fine-tuned control.</p>
<p>If depth testing is on, all vertices will be the current depth.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">rect</td><td>The rectangle to outline </td></tr>
    <tr><td class="paramname">origin</td><td>The rotational offset in the rectangle </td></tr>
    <tr><td class="paramname">scale</td><td>The amount to scale the rectangle </td></tr>
    <tr><td class="paramname">angle</td><td>The amount to rotate the rectangle </td></tr>
    <tr><td class="paramname">offset</td><td>The rectangle offset in world coordinates </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ac0113bb43b31702ad5a0cd2817db6938"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac0113bb43b31702ad5a0cd2817db6938">&#9670;&nbsp;</a></span>setBlendEquation()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void cugl::SpriteBatch::setBlendEquation </td>
          <td>(</td>
          <td class="paramtype">GLenum&#160;</td>
          <td class="paramname"><em>equation</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Sets the blending equation for this sprite batch</p>
<p>The enum must be a standard ones supported by OpenGL. See </p><pre class="fragment"> https://www.opengl.org/sdk/docs/man/html/glBlendEquation.xhtml
</pre><p> However, this setter does not do any error checking to verify that the input is valid. By default, the equation is GL_FUNC_ADD.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">equation</td><td>Specifies how source and destination colors are combined </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a3c1eb99b5196d5dbff63c0bba1fd6f5e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3c1eb99b5196d5dbff63c0bba1fd6f5e">&#9670;&nbsp;</a></span>setBlendFunc()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void cugl::SpriteBatch::setBlendFunc </td>
          <td>(</td>
          <td class="paramtype">GLenum&#160;</td>
          <td class="paramname"><em>srcFactor</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">GLenum&#160;</td>
          <td class="paramname"><em>dstFactor</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Sets the blending function for this sprite batch</p>
<p>The enums are the standard ones supported by OpenGL. See </p><pre class="fragment"> https://www.opengl.org/sdk/docs/man/html/glBlendFunc.xhtml
</pre><p> However, this setter does not do any error checking to verify that the enums are valid. By default, srcFactor is GL_SRC_ALPHA while dstFactor is GL_ONE_MINUS_SRC_ALPHA. This corresponds to non-premultiplied alpha blending.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">srcFactor</td><td>Specifies how the source blending factors are computed </td></tr>
    <tr><td class="paramname">dstFactor</td><td>Specifies how the destination blending factors are computed. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ace282bea0b90c0a37780da66f2cfd593"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ace282bea0b90c0a37780da66f2cfd593">&#9670;&nbsp;</a></span>setBlurStep()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void cugl::SpriteBatch::setBlurStep </td>
          <td>(</td>
          <td class="paramtype">GLuint&#160;</td>
          <td class="paramname"><em>step</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Sets the blur step in pixels (0 if there is no blurring).</p>
<p>This sprite batch supports a simple 9-step blur. The blur samples from the center pixel and 8 other pixels around it in a box. The blur step is the number of pixels away to sample. So a 1-step blur samples from the immediate neighbor pixels. On most textures a 5-step blur has very noticeable affects.</p>
<p>This is not a full-featured Gaussian blur. In particular, large step values will start to produce a pixellation effect. But it can produce acceptable blur effects with little cost to performance. It is especially ideal for font-blur effects on font atlases.</p>
<p>Setting this value to 0 will disable texture blurring. This value is 0 by default.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">step</td><td>The blur step in pixels </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a5b2156df91bce4fcf1dfbcdee8d15148"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5b2156df91bce4fcf1dfbcdee8d15148">&#9670;&nbsp;</a></span>setColor()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void cugl::SpriteBatch::setColor </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classcugl_1_1_color4f.html">Color4f</a>&#160;</td>
          <td class="paramname"><em>color</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Sets the active color of this sprite batch</p>
<p>All subsequent shapes and outlines drawn by this sprite batch will be tinted by this color. This color is white by default.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">color</td><td>The active color for this sprite batch </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a9a26ee7729cb03c643b79bdea85eb721"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9a26ee7729cb03c643b79bdea85eb721">&#9670;&nbsp;</a></span>setDepth()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void cugl::SpriteBatch::setDepth </td>
          <td>(</td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>depth</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Sets the current depth of this sprite batch.</p>
<p>The depth value is appended to all 2d shapes drawn by this sprite batch. If depth testing is enabled, this can allow the sprite batch to draw shapes out of order. This value is 0 by default.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">depth</td><td>The current depth of this sprite batch. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aae8122c3968b8b467829b1f4d608119c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aae8122c3968b8b467829b1f4d608119c">&#9670;&nbsp;</a></span>setDepthFunc()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void cugl::SpriteBatch::setDepthFunc </td>
          <td>(</td>
          <td class="paramtype">GLenum&#160;</td>
          <td class="paramname"><em>function</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Sets the depth testing function for this sprite batch</p>
<p>The enum must be a standard ones supported by OpenGL. See </p><pre class="fragment"> https://www.opengl.org/sdk/docs/man/html/glDepthFunc.xhtml
</pre><p> However, this setter does not do any error checking to verify that the input is valid.</p>
<p>To disable depth testing, set the function to GL_ALWAYS. GL_ALWAYS is the initial default value.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">function</td><td>Specifies how to accept fragments by depth value </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aa1e48a524829cf2679ce6f2290d9691c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa1e48a524829cf2679ce6f2290d9691c">&#9670;&nbsp;</a></span>setGradient()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void cugl::SpriteBatch::setGradient </td>
          <td>(</td>
          <td class="paramtype">const std::shared_ptr&lt; <a class="el" href="classcugl_1_1_gradient.html">Gradient</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>gradient</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Sets the active gradient of this sprite batch</p>
<p>Gradients may be used in the place of (and together with) colors. Gradients are applied textures, and use the first two attrbutes of the color attribute in <a class="el" href="classcugl_1_1_sprite_vertex2.html">SpriteVertex2</a> as texture coordinates. The last two coordinates (z and w) can used for minor feather adjustments in linear gradients (for smooth stroke effects).</p>
<p>If this value is nullptr, then no gradient is active. In that case, the color vertex attribute will be interpretted as normal (e.g. a traditional color vector). This value is nullptr by default.</p>
<p>All gradients are tinted by the active color. Unless you explicitly want this tinting, you should set the active color to white before drawing with an active gradient.</p>
<p>This method acquires a copy of the gradient. Changes to the original gradient after calling this method have no effect.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">gradient</td><td>The active gradient for this sprite batch </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a223ec040a1ea222e00ad113168bee32f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a223ec040a1ea222e00ad113168bee32f">&#9670;&nbsp;</a></span>setPerspective()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void cugl::SpriteBatch::setPerspective </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classcugl_1_1_mat4.html">Mat4</a> &amp;&#160;</td>
          <td class="paramname"><em>perspective</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Sets the active perspective matrix of this sprite batch</p>
<p>The perspective matrix is the combined modelview-projection from the camera. By default, this is the identity matrix.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">perspective</td><td>The active perspective matrix for this sprite batch </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="acdd0523479adc622d52093297d0f030b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acdd0523479adc622d52093297d0f030b">&#9670;&nbsp;</a></span>setScissor()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void cugl::SpriteBatch::setScissor </td>
          <td>(</td>
          <td class="paramtype">const std::shared_ptr&lt; <a class="el" href="classcugl_1_1_scissor.html">Scissor</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>scissor</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Sets the active scissor mask of this sprite batch</p>
<p><a class="el" href="classcugl_1_1_scissor.html">Scissor</a> masks may be combined with all types of drawing (colors, textures, and gradients). They are specified in the same coordinate system as <a class="el" href="classcugl_1_1_sprite_batch.html#a4e1f897aa822536533115f2255cdbf0b">getPerspective</a>.</p>
<p>If this value is nullptr, then no scissor mask is active. This value is nullptr by default.</p>
<p>This method acquires a copy of the scissor. Changes to the original scissor mask after calling this method have no effect.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">scissor</td><td>The active scissor mask for this sprite batch </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a12742b5bd9a4536e33d239db9255d4b5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a12742b5bd9a4536e33d239db9255d4b5">&#9670;&nbsp;</a></span>setShader()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void cugl::SpriteBatch::setShader </td>
          <td>(</td>
          <td class="paramtype">const std::shared_ptr&lt; <a class="el" href="classcugl_1_1_shader.html">Shader</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>shader</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Sets the shader for this sprite batch</p>
<p>This value may NOT be changed during a drawing pass. See the class description for the properties of a valid shader.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">shader</td><td>The active color for this sprite batch </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a4dec0c947f5bbbe0a63eefeb3456ab04"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4dec0c947f5bbbe0a63eefeb3456ab04">&#9670;&nbsp;</a></span>setTexture()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void cugl::SpriteBatch::setTexture </td>
          <td>(</td>
          <td class="paramtype">const std::shared_ptr&lt; <a class="el" href="classcugl_1_1_texture.html">Texture</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>texture</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Sets the active texture of this sprite batch</p>
<p>All subsequent shapes and outlines drawn by this sprite batch will use this texture. If the value is nullptr, all shapes and outlines will be draw with a solid color instead. This value is nullptr by default.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">texture</td><td>The active texture for this sprite batch </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>include/cugl/render/<a class="el" href="_c_u_sprite_batch_8h_source.html">CUSpriteBatch.h</a></li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.1
</small></address>
</body>
</html>
