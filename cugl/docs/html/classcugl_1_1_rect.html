<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.9.1"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>CUGL 2.0: cugl::Rect Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">CUGL 2.0
   </div>
   <div id="projectbrief">Cornell University Game Library</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.1 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search','.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespacecugl.html">cugl</a></li><li class="navelem"><a class="el" href="classcugl_1_1_rect.html">Rect</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-attribs">Public Attributes</a> &#124;
<a href="#pub-static-attribs">Static Public Attributes</a> &#124;
<a href="#friends">Friends</a> &#124;
<a href="classcugl_1_1_rect-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">cugl::Rect Class Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p><code>#include &lt;<a class="el" href="_c_u_rect_8h_source.html">CURect.h</a>&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:ae2e554ca518aebdb84caea2c6e506889"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1_rect.html#ae2e554ca518aebdb84caea2c6e506889">Rect</a> ()</td></tr>
<tr class="separator:ae2e554ca518aebdb84caea2c6e506889"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab1b707021f50d68a1734c78e5ba8a249"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1_rect.html#ab1b707021f50d68a1734c78e5ba8a249">Rect</a> (float x, float y, float width, float height)</td></tr>
<tr class="separator:ab1b707021f50d68a1734c78e5ba8a249"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a797929231697d957432555f98a5d97eb"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1_rect.html#a797929231697d957432555f98a5d97eb">Rect</a> (float *array)</td></tr>
<tr class="separator:a797929231697d957432555f98a5d97eb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a16e0223b39fafd893ff049b92410b5b3"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1_rect.html#a16e0223b39fafd893ff049b92410b5b3">Rect</a> (const <a class="el" href="classcugl_1_1_vec2.html">Vec2</a> pos, const <a class="el" href="classcugl_1_1_size.html">Size</a> dimen)</td></tr>
<tr class="separator:a16e0223b39fafd893ff049b92410b5b3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a64404c88ab17545bac6a59b8653a39d1"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1_rect.html#a64404c88ab17545bac6a59b8653a39d1">Rect</a> (const <a class="el" href="classcugl_1_1_rect.html">Rect</a> &amp;rect)</td></tr>
<tr class="separator:a64404c88ab17545bac6a59b8653a39d1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2bd9aa6cc25c56b13ff146a2df4f558d"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1_rect.html#a2bd9aa6cc25c56b13ff146a2df4f558d">Rect</a> (const <a class="el" href="classcugl_1_1_rect.html">Rect</a> &amp;&amp;rect)</td></tr>
<tr class="separator:a2bd9aa6cc25c56b13ff146a2df4f558d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a617646f173594ce0884d6554d0982a20"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classcugl_1_1_rect.html">Rect</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1_rect.html#a617646f173594ce0884d6554d0982a20">operator=</a> (const <a class="el" href="classcugl_1_1_rect.html">Rect</a> &amp;other)</td></tr>
<tr class="separator:a617646f173594ce0884d6554d0982a20"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a28888db224ac5e165b2b47a63907476a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classcugl_1_1_rect.html">Rect</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1_rect.html#a28888db224ac5e165b2b47a63907476a">operator=</a> (const <a class="el" href="classcugl_1_1_rect.html">Rect</a> &amp;&amp;other)</td></tr>
<tr class="separator:a28888db224ac5e165b2b47a63907476a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4d2d1a262d1b5a45d2acd8aa27268a57"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classcugl_1_1_rect.html">Rect</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1_rect.html#a4d2d1a262d1b5a45d2acd8aa27268a57">operator=</a> (const float *array)</td></tr>
<tr class="separator:a4d2d1a262d1b5a45d2acd8aa27268a57"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1bb518c79e126297ed8dc1522d171322"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classcugl_1_1_rect.html">Rect</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1_rect.html#a1bb518c79e126297ed8dc1522d171322">set</a> (float x, float y, float width, float height)</td></tr>
<tr class="separator:a1bb518c79e126297ed8dc1522d171322"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac09f1a65d0f78b011efc48d47ab1df5f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classcugl_1_1_rect.html">Rect</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1_rect.html#ac09f1a65d0f78b011efc48d47ab1df5f">set</a> (const float *array)</td></tr>
<tr class="separator:ac09f1a65d0f78b011efc48d47ab1df5f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad7eef24a78f8682405c07c080b68859b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classcugl_1_1_rect.html">Rect</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1_rect.html#ad7eef24a78f8682405c07c080b68859b">set</a> (const <a class="el" href="classcugl_1_1_vec2.html">Vec2</a> pos, const <a class="el" href="classcugl_1_1_size.html">Size</a> dimen)</td></tr>
<tr class="separator:ad7eef24a78f8682405c07c080b68859b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a47ca4509267a79f9ad5b812d45e3e3b6"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classcugl_1_1_rect.html">Rect</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1_rect.html#a47ca4509267a79f9ad5b812d45e3e3b6">set</a> (const <a class="el" href="classcugl_1_1_rect.html">Rect</a> &amp;other)</td></tr>
<tr class="separator:a47ca4509267a79f9ad5b812d45e3e3b6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5ab49d71586a65c2d962ca690e5c0316"><td class="memItemLeft" align="right" valign="top">float&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1_rect.html#a5ab49d71586a65c2d962ca690e5c0316">getMinX</a> () const</td></tr>
<tr class="separator:a5ab49d71586a65c2d962ca690e5c0316"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0c2f842b441bd2ea524d4ca5b2e1e0b7"><td class="memItemLeft" align="right" valign="top">float&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1_rect.html#a0c2f842b441bd2ea524d4ca5b2e1e0b7">getMidX</a> () const</td></tr>
<tr class="separator:a0c2f842b441bd2ea524d4ca5b2e1e0b7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac389c5568f3ec9ed6c7e6753c3013bc5"><td class="memItemLeft" align="right" valign="top">float&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1_rect.html#ac389c5568f3ec9ed6c7e6753c3013bc5">getMaxX</a> () const</td></tr>
<tr class="separator:ac389c5568f3ec9ed6c7e6753c3013bc5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1f768e5eb4f2238a6c283261027d9acd"><td class="memItemLeft" align="right" valign="top">float&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1_rect.html#a1f768e5eb4f2238a6c283261027d9acd">getMinY</a> () const</td></tr>
<tr class="separator:a1f768e5eb4f2238a6c283261027d9acd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af7f143d2faea2ceab609b422ac085062"><td class="memItemLeft" align="right" valign="top">float&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1_rect.html#af7f143d2faea2ceab609b422ac085062">getMidY</a> () const</td></tr>
<tr class="separator:af7f143d2faea2ceab609b422ac085062"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a57de3d09215e9b8e965222517620e950"><td class="memItemLeft" align="right" valign="top">float&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1_rect.html#a57de3d09215e9b8e965222517620e950">getMaxY</a> () const</td></tr>
<tr class="separator:a57de3d09215e9b8e965222517620e950"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a88d643bfe0eaad58bbec55e4c2d70c4f"><td class="memItemLeft" align="right" valign="top">float&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1_rect.html#a88d643bfe0eaad58bbec55e4c2d70c4f">isDegenerate</a> () const</td></tr>
<tr class="separator:a88d643bfe0eaad58bbec55e4c2d70c4f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4d9f00296d915bf4c2230280cec6db99"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1_rect.html#a4d9f00296d915bf4c2230280cec6db99">operator==</a> (const <a class="el" href="classcugl_1_1_rect.html">Rect</a> rect) const</td></tr>
<tr class="separator:a4d9f00296d915bf4c2230280cec6db99"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7a7d4d96f5b517462ebbd5c953ba76b9"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1_rect.html#a7a7d4d96f5b517462ebbd5c953ba76b9">operator!=</a> (const <a class="el" href="classcugl_1_1_rect.html">Rect</a> rect) const</td></tr>
<tr class="separator:a7a7d4d96f5b517462ebbd5c953ba76b9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2741d5ad28d816b7ff4c193c0ff64b7a"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1_rect.html#a2741d5ad28d816b7ff4c193c0ff64b7a">equals</a> (const <a class="el" href="classcugl_1_1_rect.html">Rect</a> rect, float variance=5.0e-4f) const</td></tr>
<tr class="separator:a2741d5ad28d816b7ff4c193c0ff64b7a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ace2c5235b60c5064b1104e7e989598cc"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1_rect.html#ace2c5235b60c5064b1104e7e989598cc">operator&lt;=</a> (const <a class="el" href="classcugl_1_1_rect.html">Rect</a> rect) const</td></tr>
<tr class="separator:ace2c5235b60c5064b1104e7e989598cc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adfdafde79197420b30a8d221b89a1fd8"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1_rect.html#adfdafde79197420b30a8d221b89a1fd8">operator&lt;</a> (const <a class="el" href="classcugl_1_1_rect.html">Rect</a> rect) const</td></tr>
<tr class="separator:adfdafde79197420b30a8d221b89a1fd8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af075c774b56a45268e6bf8ddb4cf40a8"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1_rect.html#af075c774b56a45268e6bf8ddb4cf40a8">operator&gt;=</a> (const <a class="el" href="classcugl_1_1_rect.html">Rect</a> rect) const</td></tr>
<tr class="separator:af075c774b56a45268e6bf8ddb4cf40a8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6b18c7034936bd55067bb9ffeaffe623"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1_rect.html#a6b18c7034936bd55067bb9ffeaffe623">operator&gt;</a> (const <a class="el" href="classcugl_1_1_rect.html">Rect</a> rect) const</td></tr>
<tr class="separator:a6b18c7034936bd55067bb9ffeaffe623"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adeb28a7dd36edf38288ecee4ff1aaca5"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1_rect.html#adeb28a7dd36edf38288ecee4ff1aaca5">inside</a> (const <a class="el" href="classcugl_1_1_rect.html">Rect</a> rect) const</td></tr>
<tr class="separator:adeb28a7dd36edf38288ecee4ff1aaca5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a670cddafe1b4bd7ded122c57c814aa21"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1_rect.html#a670cddafe1b4bd7ded122c57c814aa21">contains</a> (const <a class="el" href="classcugl_1_1_rect.html">Rect</a> rect) const</td></tr>
<tr class="separator:a670cddafe1b4bd7ded122c57c814aa21"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a86a012843b44b01777b193b90f8408f9"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1_rect.html#a86a012843b44b01777b193b90f8408f9">touches</a> (const <a class="el" href="classcugl_1_1_vec2.html">Vec2</a> point) const</td></tr>
<tr class="separator:a86a012843b44b01777b193b90f8408f9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4809129897780e0f4dfddb94a588534d"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1_rect.html#a4809129897780e0f4dfddb94a588534d">contains</a> (const <a class="el" href="classcugl_1_1_vec2.html">Vec2</a> point) const</td></tr>
<tr class="separator:a4809129897780e0f4dfddb94a588534d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adeb4a2a517299ef28d57c2c0da8087dc"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1_rect.html#adeb4a2a517299ef28d57c2c0da8087dc">contains</a> (const <a class="el" href="classcugl_1_1_vec2.html">Vec2</a> center, float radius) const</td></tr>
<tr class="separator:adeb4a2a517299ef28d57c2c0da8087dc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3ea0683b5368e69e67a6ea90330f5fca"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1_rect.html#a3ea0683b5368e69e67a6ea90330f5fca">doesIntersect</a> (const <a class="el" href="classcugl_1_1_rect.html">Rect</a> rect) const</td></tr>
<tr class="separator:a3ea0683b5368e69e67a6ea90330f5fca"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8ca7b042672337c3374af2389b15c8ab"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1_rect.html#a8ca7b042672337c3374af2389b15c8ab">doesIntersect</a> (const <a class="el" href="classcugl_1_1_vec2.html">Vec2</a> center, float radius) const</td></tr>
<tr class="separator:a8ca7b042672337c3374af2389b15c8ab"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a92657408615c2e7585595303cd91336c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classcugl_1_1_rect.html">Rect</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1_rect.html#a92657408615c2e7585595303cd91336c">operator+=</a> (const <a class="el" href="classcugl_1_1_rect.html">Rect</a> rect)</td></tr>
<tr class="separator:a92657408615c2e7585595303cd91336c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab3e66a2be478b2608a224cbfce57ee20"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classcugl_1_1_rect.html">Rect</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1_rect.html#ab3e66a2be478b2608a224cbfce57ee20">operator+=</a> (const <a class="el" href="classcugl_1_1_vec2.html">Vec2</a> vec)</td></tr>
<tr class="separator:ab3e66a2be478b2608a224cbfce57ee20"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad33a6c7417a97c6271b1b9707d6a29ab"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classcugl_1_1_rect.html">Rect</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1_rect.html#ad33a6c7417a97c6271b1b9707d6a29ab">operator-=</a> (const <a class="el" href="classcugl_1_1_vec2.html">Vec2</a> vec)</td></tr>
<tr class="separator:ad33a6c7417a97c6271b1b9707d6a29ab"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a63216dc69d543d6f67caeaad3bca13b1"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classcugl_1_1_rect.html">Rect</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1_rect.html#a63216dc69d543d6f67caeaad3bca13b1">operator*=</a> (float <a class="el" href="classcugl_1_1_rect.html#a872252960bcb53d2ed8aba02ca38acd2">scale</a>)</td></tr>
<tr class="separator:a63216dc69d543d6f67caeaad3bca13b1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af918b6f3de7abc3dc20e23619a43dffb"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classcugl_1_1_rect.html">Rect</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1_rect.html#af918b6f3de7abc3dc20e23619a43dffb">operator*=</a> (const <a class="el" href="classcugl_1_1_vec2.html">Vec2</a> <a class="el" href="classcugl_1_1_rect.html#a872252960bcb53d2ed8aba02ca38acd2">scale</a>)</td></tr>
<tr class="separator:af918b6f3de7abc3dc20e23619a43dffb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7c48b11fafbb9691fbdff5e7e79b7457"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classcugl_1_1_rect.html">Rect</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1_rect.html#a7c48b11fafbb9691fbdff5e7e79b7457">operator*=</a> (const <a class="el" href="classcugl_1_1_affine2.html">Affine2</a> &amp;transform)</td></tr>
<tr class="separator:a7c48b11fafbb9691fbdff5e7e79b7457"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0e91f416a0d5a25b7c3d8423119b7c02"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classcugl_1_1_rect.html">Rect</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1_rect.html#a0e91f416a0d5a25b7c3d8423119b7c02">operator*=</a> (const <a class="el" href="classcugl_1_1_mat4.html">Mat4</a> &amp;transform)</td></tr>
<tr class="separator:a0e91f416a0d5a25b7c3d8423119b7c02"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a12de08db5b162e3e31cca3d3866d0fa2"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classcugl_1_1_rect.html">Rect</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1_rect.html#a12de08db5b162e3e31cca3d3866d0fa2">operator/=</a> (float <a class="el" href="classcugl_1_1_rect.html#a872252960bcb53d2ed8aba02ca38acd2">scale</a>)</td></tr>
<tr class="separator:a12de08db5b162e3e31cca3d3866d0fa2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa26f7bf4d0b93e463d031fd4beeb79db"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classcugl_1_1_rect.html">Rect</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1_rect.html#aa26f7bf4d0b93e463d031fd4beeb79db">operator/=</a> (const <a class="el" href="classcugl_1_1_vec2.html">Vec2</a> <a class="el" href="classcugl_1_1_rect.html#a872252960bcb53d2ed8aba02ca38acd2">scale</a>)</td></tr>
<tr class="separator:aa26f7bf4d0b93e463d031fd4beeb79db"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad08a46588bf8dfdc60cff7c5cd572659"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classcugl_1_1_rect.html">Rect</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1_rect.html#ad08a46588bf8dfdc60cff7c5cd572659">operator+</a> (const <a class="el" href="classcugl_1_1_rect.html">Rect</a> rect)</td></tr>
<tr class="separator:ad08a46588bf8dfdc60cff7c5cd572659"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afbbea4a79e80b870d62c6c63f12ff711"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classcugl_1_1_rect.html">Rect</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1_rect.html#afbbea4a79e80b870d62c6c63f12ff711">operator+</a> (const <a class="el" href="classcugl_1_1_vec2.html">Vec2</a> vec) const</td></tr>
<tr class="separator:afbbea4a79e80b870d62c6c63f12ff711"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a476ba95c82b17483205a9172af7244ad"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classcugl_1_1_rect.html">Rect</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1_rect.html#a476ba95c82b17483205a9172af7244ad">operator-</a> (const <a class="el" href="classcugl_1_1_vec2.html">Vec2</a> vec) const</td></tr>
<tr class="separator:a476ba95c82b17483205a9172af7244ad"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaf9b6d5cd9277f17d67467ff6dcbcfe6"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classcugl_1_1_rect.html">Rect</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1_rect.html#aaf9b6d5cd9277f17d67467ff6dcbcfe6">operator*</a> (float <a class="el" href="classcugl_1_1_rect.html#a872252960bcb53d2ed8aba02ca38acd2">scale</a>) const</td></tr>
<tr class="separator:aaf9b6d5cd9277f17d67467ff6dcbcfe6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaa19b82d39dddf90eedefec69d4989a7"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classcugl_1_1_rect.html">Rect</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1_rect.html#aaa19b82d39dddf90eedefec69d4989a7">operator*</a> (const <a class="el" href="classcugl_1_1_vec2.html">Vec2</a> <a class="el" href="classcugl_1_1_rect.html#a872252960bcb53d2ed8aba02ca38acd2">scale</a>) const</td></tr>
<tr class="separator:aaa19b82d39dddf90eedefec69d4989a7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acfe2a25d131c04d39321df1a28085699"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classcugl_1_1_rect.html">Rect</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1_rect.html#acfe2a25d131c04d39321df1a28085699">operator*</a> (const <a class="el" href="classcugl_1_1_affine2.html">Affine2</a> &amp;transform) const</td></tr>
<tr class="separator:acfe2a25d131c04d39321df1a28085699"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa853fd558126dbc21dc065b42a4aef1e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classcugl_1_1_rect.html">Rect</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1_rect.html#aa853fd558126dbc21dc065b42a4aef1e">operator*</a> (const <a class="el" href="classcugl_1_1_mat4.html">Mat4</a> &amp;transform) const</td></tr>
<tr class="separator:aa853fd558126dbc21dc065b42a4aef1e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a73cd383e3c3e4446b106ae842b0d4d6f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classcugl_1_1_rect.html">Rect</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1_rect.html#a73cd383e3c3e4446b106ae842b0d4d6f">operator/</a> (float <a class="el" href="classcugl_1_1_rect.html#a872252960bcb53d2ed8aba02ca38acd2">scale</a>) const</td></tr>
<tr class="separator:a73cd383e3c3e4446b106ae842b0d4d6f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa216203063b639123f0e6b36dea55584"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classcugl_1_1_rect.html">Rect</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1_rect.html#aa216203063b639123f0e6b36dea55584">operator/</a> (const <a class="el" href="classcugl_1_1_vec2.html">Vec2</a> <a class="el" href="classcugl_1_1_rect.html#a872252960bcb53d2ed8aba02ca38acd2">scale</a>) const</td></tr>
<tr class="separator:aa216203063b639123f0e6b36dea55584"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8a58b8d1296201828b2f79e0a6254041"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classcugl_1_1_rect.html">Rect</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1_rect.html#a8a58b8d1296201828b2f79e0a6254041">translate</a> (const <a class="el" href="classcugl_1_1_vec2.html">Vec2</a> vec)</td></tr>
<tr class="separator:a8a58b8d1296201828b2f79e0a6254041"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adc5d6c66c10707a393dd4aefa0f366d8"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classcugl_1_1_rect.html">Rect</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1_rect.html#adc5d6c66c10707a393dd4aefa0f366d8">translate</a> (float x, float y)</td></tr>
<tr class="separator:adc5d6c66c10707a393dd4aefa0f366d8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a647f969200fca03ca9462d9f85e7c785"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classcugl_1_1_rect.html">Rect</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1_rect.html#a647f969200fca03ca9462d9f85e7c785">getTranslation</a> (const <a class="el" href="classcugl_1_1_vec2.html">Vec2</a> vec) const</td></tr>
<tr class="separator:a647f969200fca03ca9462d9f85e7c785"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af55de7d842825cc2deaf14238ed7c3cd"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classcugl_1_1_rect.html">Rect</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1_rect.html#af55de7d842825cc2deaf14238ed7c3cd">getTranslation</a> (float x, float y) const</td></tr>
<tr class="separator:af55de7d842825cc2deaf14238ed7c3cd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a872252960bcb53d2ed8aba02ca38acd2"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classcugl_1_1_rect.html">Rect</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1_rect.html#a872252960bcb53d2ed8aba02ca38acd2">scale</a> (float scale)</td></tr>
<tr class="separator:a872252960bcb53d2ed8aba02ca38acd2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a039f3b948de6ab2342bb683c239cf686"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classcugl_1_1_rect.html">Rect</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1_rect.html#a039f3b948de6ab2342bb683c239cf686">scale</a> (float sx, float sy)</td></tr>
<tr class="separator:a039f3b948de6ab2342bb683c239cf686"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa22399ddb73b89ca566b0101a704c9b7"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classcugl_1_1_rect.html">Rect</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1_rect.html#aa22399ddb73b89ca566b0101a704c9b7">scale</a> (const <a class="el" href="classcugl_1_1_vec2.html">Vec2</a> scale)</td></tr>
<tr class="separator:aa22399ddb73b89ca566b0101a704c9b7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7c07784bd642d78a6893e390e13f43e5"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classcugl_1_1_rect.html">Rect</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1_rect.html#a7c07784bd642d78a6893e390e13f43e5">scale</a> (const <a class="el" href="classcugl_1_1_vec2.html">Vec2</a> scale, const <a class="el" href="classcugl_1_1_vec2.html">Vec2</a> anchor)</td></tr>
<tr class="separator:a7c07784bd642d78a6893e390e13f43e5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a634c4dd06927be6f3dcd2e3d94bc8f1c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classcugl_1_1_rect.html">Rect</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1_rect.html#a634c4dd06927be6f3dcd2e3d94bc8f1c">getScale</a> (float <a class="el" href="classcugl_1_1_rect.html#a872252960bcb53d2ed8aba02ca38acd2">scale</a>) const</td></tr>
<tr class="separator:a634c4dd06927be6f3dcd2e3d94bc8f1c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7d2a6b45f0b13bd1d2ee314bd89eeeb5"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classcugl_1_1_rect.html">Rect</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1_rect.html#a7d2a6b45f0b13bd1d2ee314bd89eeeb5">getScale</a> (float sx, float sy) const</td></tr>
<tr class="separator:a7d2a6b45f0b13bd1d2ee314bd89eeeb5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac1ef89869b2a006764af38b83d954eb5"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classcugl_1_1_rect.html">Rect</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1_rect.html#ac1ef89869b2a006764af38b83d954eb5">getScale</a> (const <a class="el" href="classcugl_1_1_vec2.html">Vec2</a> <a class="el" href="classcugl_1_1_rect.html#a872252960bcb53d2ed8aba02ca38acd2">scale</a>) const</td></tr>
<tr class="separator:ac1ef89869b2a006764af38b83d954eb5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9096494d65ffac6243bb909f77da4f45"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classcugl_1_1_rect.html">Rect</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1_rect.html#a9096494d65ffac6243bb909f77da4f45">getScale</a> (const <a class="el" href="classcugl_1_1_vec2.html">Vec2</a> <a class="el" href="classcugl_1_1_rect.html#a872252960bcb53d2ed8aba02ca38acd2">scale</a>, const <a class="el" href="classcugl_1_1_vec2.html">Vec2</a> anchor) const</td></tr>
<tr class="separator:a9096494d65ffac6243bb909f77da4f45"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7592a85c8d4b155691d48fd373b1b005"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classcugl_1_1_rect.html">Rect</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1_rect.html#a7592a85c8d4b155691d48fd373b1b005">inscribe</a> (const <a class="el" href="classcugl_1_1_mat4.html">Mat4</a> &amp;transform, bool loose=false)</td></tr>
<tr class="separator:a7592a85c8d4b155691d48fd373b1b005"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1993fab1a5f419ff7b9548e7ab7643fe"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classcugl_1_1_rect.html">Rect</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1_rect.html#a1993fab1a5f419ff7b9548e7ab7643fe">inscribe</a> (const <a class="el" href="classcugl_1_1_affine2.html">Affine2</a> &amp;transform, bool loose=false)</td></tr>
<tr class="separator:a1993fab1a5f419ff7b9548e7ab7643fe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6f58c2f52f1d6bd76904fa9c7c036b05"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classcugl_1_1_rect.html">Rect</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1_rect.html#a6f58c2f52f1d6bd76904fa9c7c036b05">getInscription</a> (const <a class="el" href="classcugl_1_1_mat4.html">Mat4</a> &amp;transform, bool loose=false) const</td></tr>
<tr class="separator:a6f58c2f52f1d6bd76904fa9c7c036b05"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a68be09ab82d0aa41d72584a07533c41e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classcugl_1_1_rect.html">Rect</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1_rect.html#a68be09ab82d0aa41d72584a07533c41e">getInscription</a> (const <a class="el" href="classcugl_1_1_affine2.html">Affine2</a> &amp;transform, bool loose=false) const</td></tr>
<tr class="separator:a68be09ab82d0aa41d72584a07533c41e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6928fa37987f78f201220601b80aea81"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classcugl_1_1_rect.html">Rect</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1_rect.html#a6928fa37987f78f201220601b80aea81">circumscribe</a> (const <a class="el" href="classcugl_1_1_mat4.html">Mat4</a> &amp;transform, bool loose=false)</td></tr>
<tr class="separator:a6928fa37987f78f201220601b80aea81"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a724c40532d67057f174fa26ee5651d8c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classcugl_1_1_rect.html">Rect</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1_rect.html#a724c40532d67057f174fa26ee5651d8c">circumscribe</a> (const <a class="el" href="classcugl_1_1_affine2.html">Affine2</a> &amp;transform, bool loose=false)</td></tr>
<tr class="separator:a724c40532d67057f174fa26ee5651d8c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a14995e9ad51d2d62fdcec29602b761f0"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classcugl_1_1_rect.html">Rect</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1_rect.html#a14995e9ad51d2d62fdcec29602b761f0">getCircumscription</a> (const <a class="el" href="classcugl_1_1_mat4.html">Mat4</a> &amp;transform, bool loose=false) const</td></tr>
<tr class="separator:a14995e9ad51d2d62fdcec29602b761f0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1536f5ee1c8aae60ec6ff9f3598bde4c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classcugl_1_1_rect.html">Rect</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1_rect.html#a1536f5ee1c8aae60ec6ff9f3598bde4c">getCircumscription</a> (const <a class="el" href="classcugl_1_1_affine2.html">Affine2</a> &amp;transform, bool loose=false) const</td></tr>
<tr class="separator:a1536f5ee1c8aae60ec6ff9f3598bde4c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7f7949e8308f3d60859d4a68cb946723"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classcugl_1_1_rect.html">Rect</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1_rect.html#a7f7949e8308f3d60859d4a68cb946723">merge</a> (const <a class="el" href="classcugl_1_1_rect.html">Rect</a> &amp;rect)</td></tr>
<tr class="separator:a7f7949e8308f3d60859d4a68cb946723"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a92d517a910f0d454de1d5a5d41e2421d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classcugl_1_1_rect.html">Rect</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1_rect.html#a92d517a910f0d454de1d5a5d41e2421d">intersect</a> (const <a class="el" href="classcugl_1_1_rect.html">Rect</a> &amp;rect)</td></tr>
<tr class="separator:a92d517a910f0d454de1d5a5d41e2421d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac0d5f0fda252b9d9d41c9cc647a49cc0"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classcugl_1_1_rect.html">Rect</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1_rect.html#ac0d5f0fda252b9d9d41c9cc647a49cc0">expand</a> (float factor)</td></tr>
<tr class="separator:ac0d5f0fda252b9d9d41c9cc647a49cc0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a71e65e39312c191463ebd3636142335c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classcugl_1_1_rect.html">Rect</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1_rect.html#a71e65e39312c191463ebd3636142335c">expand</a> (const <a class="el" href="classcugl_1_1_vec2.html">Vec2</a> point)</td></tr>
<tr class="separator:a71e65e39312c191463ebd3636142335c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9a4917aee577052c4a0dcf3810c8549d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classcugl_1_1_rect.html">Rect</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1_rect.html#a9a4917aee577052c4a0dcf3810c8549d">getMerge</a> (const <a class="el" href="classcugl_1_1_rect.html">Rect</a> &amp;rect) const</td></tr>
<tr class="separator:a9a4917aee577052c4a0dcf3810c8549d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a012e47e0372ccc38c53779f7dbec6640"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classcugl_1_1_rect.html">Rect</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1_rect.html#a012e47e0372ccc38c53779f7dbec6640">getIntersection</a> (const <a class="el" href="classcugl_1_1_rect.html">Rect</a> &amp;rect) const</td></tr>
<tr class="separator:a012e47e0372ccc38c53779f7dbec6640"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0721f6e3cd806b283e534a25620ae7ee"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classcugl_1_1_rect.html">Rect</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1_rect.html#a0721f6e3cd806b283e534a25620ae7ee">getExpansion</a> (float factor) const</td></tr>
<tr class="separator:a0721f6e3cd806b283e534a25620ae7ee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa58293fbcf86c5fd7810ece87f6bc0a9"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classcugl_1_1_rect.html">Rect</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1_rect.html#aa58293fbcf86c5fd7810ece87f6bc0a9">getExpansion</a> (const <a class="el" href="classcugl_1_1_vec2.html">Vec2</a> point) const</td></tr>
<tr class="separator:aa58293fbcf86c5fd7810ece87f6bc0a9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ace3373513cb0fb47f3bb79a02cafd7a0"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1_rect.html#ace3373513cb0fb47f3bb79a02cafd7a0">toString</a> (bool verbose=false) const</td></tr>
<tr class="separator:ace3373513cb0fb47f3bb79a02cafd7a0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a39cb827dec1676d375b98aae005d0b13"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1_rect.html#a39cb827dec1676d375b98aae005d0b13">operator std::string</a> () const</td></tr>
<tr class="separator:a39cb827dec1676d375b98aae005d0b13"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-attribs"></a>
Public Attributes</h2></td></tr>
<tr class="memitem:a4606335d9ed1ed883cff5b744189ffb8"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classcugl_1_1_vec2.html">Vec2</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1_rect.html#a4606335d9ed1ed883cff5b744189ffb8">origin</a></td></tr>
<tr class="separator:a4606335d9ed1ed883cff5b744189ffb8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a31df80a6f5724aa0021e9458c6a18a1a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classcugl_1_1_size.html">Size</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1_rect.html#a31df80a6f5724aa0021e9458c6a18a1a">size</a></td></tr>
<tr class="separator:a31df80a6f5724aa0021e9458c6a18a1a"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-static-attribs"></a>
Static Public Attributes</h2></td></tr>
<tr class="memitem:ab9028106203488aff53e51f432d10c53"><td class="memItemLeft" align="right" valign="top">static const <a class="el" href="classcugl_1_1_rect.html">Rect</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1_rect.html#ab9028106203488aff53e51f432d10c53">ZERO</a></td></tr>
<tr class="separator:ab9028106203488aff53e51f432d10c53"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae537d1d3f77421755121be069e1d84c0"><td class="memItemLeft" align="right" valign="top">static const <a class="el" href="classcugl_1_1_rect.html">Rect</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1_rect.html#ae537d1d3f77421755121be069e1d84c0">UNIT</a></td></tr>
<tr class="separator:ae537d1d3f77421755121be069e1d84c0"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="friends"></a>
Friends</h2></td></tr>
<tr class="memitem:a5d92df22d5165f6c2d8fcf2e3485cac2"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classcugl_1_1_rect.html">Rect</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1_rect.html#a5d92df22d5165f6c2d8fcf2e3485cac2">operator+</a> (const <a class="el" href="classcugl_1_1_vec2.html">Vec2</a> vec, const <a class="el" href="classcugl_1_1_rect.html">Rect</a> rect)</td></tr>
<tr class="separator:a5d92df22d5165f6c2d8fcf2e3485cac2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5d61754bad1f023c823244ad098c7b26"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classcugl_1_1_rect.html">Rect</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1_rect.html#a5d61754bad1f023c823244ad098c7b26">operator-</a> (const <a class="el" href="classcugl_1_1_vec2.html">Vec2</a> vec, const <a class="el" href="classcugl_1_1_rect.html">Rect</a> rect)</td></tr>
<tr class="separator:a5d61754bad1f023c823244ad098c7b26"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab1748cda3d871802233327120db7e92c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classcugl_1_1_rect.html">Rect</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1_rect.html#ab1748cda3d871802233327120db7e92c">operator*</a> (float <a class="el" href="classcugl_1_1_rect.html#a872252960bcb53d2ed8aba02ca38acd2">scale</a>, const <a class="el" href="classcugl_1_1_rect.html">Rect</a> rect)</td></tr>
<tr class="separator:ab1748cda3d871802233327120db7e92c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a28dc04b897fac18291037244e362db8f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classcugl_1_1_rect.html">Rect</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1_rect.html#a28dc04b897fac18291037244e362db8f">operator*</a> (const <a class="el" href="classcugl_1_1_vec2.html">Vec2</a> <a class="el" href="classcugl_1_1_rect.html#a872252960bcb53d2ed8aba02ca38acd2">scale</a>, const <a class="el" href="classcugl_1_1_rect.html">Rect</a> rect)</td></tr>
<tr class="separator:a28dc04b897fac18291037244e362db8f"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>This class represents a rectangle area in 2D space.</p>
<p>It is generally safe to manipulate the fields directly. </p>
</div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="ae2e554ca518aebdb84caea2c6e506889"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae2e554ca518aebdb84caea2c6e506889">&#9670;&nbsp;</a></span>Rect() <span class="overload">[1/6]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">cugl::Rect::Rect </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Creates an empty <a class="el" href="classcugl_1_1_rect.html">Rect</a> at the origin </p>

</div>
</div>
<a id="ab1b707021f50d68a1734c78e5ba8a249"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab1b707021f50d68a1734c78e5ba8a249">&#9670;&nbsp;</a></span>Rect() <span class="overload">[2/6]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">cugl::Rect::Rect </td>
          <td>(</td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>width</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>height</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Creates a rect with the given origin and dimensions.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>The x-coordinate of the bottom left corner </td></tr>
    <tr><td class="paramname">y</td><td>The y-coordinate of the bottom left corner </td></tr>
    <tr><td class="paramname">width</td><td>The width of the rect </td></tr>
    <tr><td class="paramname">height</td><td>The width of the rect </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a797929231697d957432555f98a5d97eb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a797929231697d957432555f98a5d97eb">&#9670;&nbsp;</a></span>Rect() <span class="overload">[3/6]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">cugl::Rect::Rect </td>
          <td>(</td>
          <td class="paramtype">float *&#160;</td>
          <td class="paramname"><em>array</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Creates a rect from the given float array.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">array</td><td>An array containing the attributes in the order origin, size. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a16e0223b39fafd893ff049b92410b5b3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a16e0223b39fafd893ff049b92410b5b3">&#9670;&nbsp;</a></span>Rect() <span class="overload">[4/6]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">cugl::Rect::Rect </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classcugl_1_1_vec2.html">Vec2</a>&#160;</td>
          <td class="paramname"><em>pos</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classcugl_1_1_size.html">Size</a>&#160;</td>
          <td class="paramname"><em>dimen</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Creates a rect with the given origin and dimensions.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pos</td><td>The position the bottom left corner </td></tr>
    <tr><td class="paramname">dimen</td><td>The size of the rect </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a64404c88ab17545bac6a59b8653a39d1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a64404c88ab17545bac6a59b8653a39d1">&#9670;&nbsp;</a></span>Rect() <span class="overload">[5/6]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">cugl::Rect::Rect </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classcugl_1_1_rect.html">Rect</a> &amp;&#160;</td>
          <td class="paramname"><em>rect</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Creates a copy of the given rectangle.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">rect</td><td>The rectangle to copy </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a2bd9aa6cc25c56b13ff146a2df4f558d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2bd9aa6cc25c56b13ff146a2df4f558d">&#9670;&nbsp;</a></span>Rect() <span class="overload">[6/6]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">cugl::Rect::Rect </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classcugl_1_1_rect.html">Rect</a> &amp;&amp;&#160;</td>
          <td class="paramname"><em>rect</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Creates a copy of the given rectangle.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">rect</td><td>The rectangle to copy </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="a724c40532d67057f174fa26ee5651d8c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a724c40532d67057f174fa26ee5651d8c">&#9670;&nbsp;</a></span>circumscribe() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcugl_1_1_rect.html">Rect</a>&amp; cugl::Rect::circumscribe </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classcugl_1_1_affine2.html">Affine2</a> &amp;&#160;</td>
          <td class="paramname"><em>transform</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>loose</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Circumscribes this rectangle outside the transformed quadrilateral.</p>
<p>A rectangle must be axis-aligned, so transforming a rectangle does not necessarily produce a rectangle (particularly when the transform includes a rotation). Instead, it produces a quadrilateral polygon. The method sets this rectangle to be the unique circumscribing rectangle that shares the same center as the quadrilateral.</p>
<p>If circumscription is tight, this means the rectangle is the bounding box of the four vertices. If it is loose, then the circumscription will only contain two (opposing) vertices, picking the vertices that maximize the&#x2410; minimal axis distance. This creates a smaller rectangle that is still a reasonable fit for the transformed quadrilateral.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">transform</td><td>The affine transform </td></tr>
    <tr><td class="paramname">loose</td><td>Whether to loosen the circumscription</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>This circumscribing rectangle </dd></dl>

</div>
</div>
<a id="a6928fa37987f78f201220601b80aea81"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6928fa37987f78f201220601b80aea81">&#9670;&nbsp;</a></span>circumscribe() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcugl_1_1_rect.html">Rect</a>&amp; cugl::Rect::circumscribe </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classcugl_1_1_mat4.html">Mat4</a> &amp;&#160;</td>
          <td class="paramname"><em>transform</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>loose</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Circumscribes this rectangle outside the transformed quadrilateral.</p>
<p>A rectangle must be axis-aligned, so transforming a rectangle does not necessarily produce a rectangle (particularly when the transform includes a rotation). Instead, it produces a quadrilateral polygon. The method sets this rectangle to be the unique circumscribing rectangle that shares the same center as the quadrilateral.</p>
<p>If circumscription is tight, this means the rectangle is the bounding box of the four vertices. If it is loose, then the circumscription will only contain two (opposing) vertices, picking the vertices that maximize the&#x2410; minimal axis distance. This creates a smaller rectangle that is still a reasonable fit for the transformed quadrilateral.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">transform</td><td>The affine transform </td></tr>
    <tr><td class="paramname">loose</td><td>Whether to loosen the circumscription</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>This circumscribing rectangle </dd></dl>

</div>
</div>
<a id="a670cddafe1b4bd7ded122c57c814aa21"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a670cddafe1b4bd7ded122c57c814aa21">&#9670;&nbsp;</a></span>contains() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool cugl::Rect::contains </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classcugl_1_1_rect.html">Rect</a>&#160;</td>
          <td class="paramname"><em>rect</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns true if this rect can hold the given rect.</p>
<p>This method does not test for strict containment. To test for strict containment, use the comparison operator &gt;.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">rect</td><td>The potentially smaller rect</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if this rect can hold the given rect. </dd></dl>

</div>
</div>
<a id="adeb4a2a517299ef28d57c2c0da8087dc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adeb4a2a517299ef28d57c2c0da8087dc">&#9670;&nbsp;</a></span>contains() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool cugl::Rect::contains </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classcugl_1_1_vec2.html">Vec2</a>&#160;</td>
          <td class="paramname"><em>center</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>radius</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns true if this rect contains the given circle.</p>
<p>This method does not test for strict containment; it includes the boundary of both the circle and the rectangle.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">center</td><td>The center of the circle </td></tr>
    <tr><td class="paramname">radius</td><td>The radius of the circle</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if this rect contains the given circle. </dd></dl>

</div>
</div>
<a id="a4809129897780e0f4dfddb94a588534d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4809129897780e0f4dfddb94a588534d">&#9670;&nbsp;</a></span>contains() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool cugl::Rect::contains </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classcugl_1_1_vec2.html">Vec2</a>&#160;</td>
          <td class="paramname"><em>point</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns true if this rect contains the given point.</p>
<p>This method does not test for strict containment; it includes the boundardy. To test for strict containment, combine this with the method <a class="el" href="classcugl_1_1_rect.html#a86a012843b44b01777b193b90f8408f9">touches()</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">point</td><td>The point to test</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if this rect contains the given point. </dd></dl>

</div>
</div>
<a id="a3ea0683b5368e69e67a6ea90330f5fca"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3ea0683b5368e69e67a6ea90330f5fca">&#9670;&nbsp;</a></span>doesIntersect() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool cugl::Rect::doesIntersect </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classcugl_1_1_rect.html">Rect</a>&#160;</td>
          <td class="paramname"><em>rect</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns true if this rect intersects the other.</p>
<p>This method allows for intersections where the edges of the rects are touching. In this case, the size of the intersection is empty.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">rect</td><td>The rect to test</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if this rect intersects the other. </dd></dl>

</div>
</div>
<a id="a8ca7b042672337c3374af2389b15c8ab"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8ca7b042672337c3374af2389b15c8ab">&#9670;&nbsp;</a></span>doesIntersect() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool cugl::Rect::doesIntersect </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classcugl_1_1_vec2.html">Vec2</a>&#160;</td>
          <td class="paramname"><em>center</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>radius</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns true if this rect intersects the given circle.</p>
<p>This method allows for intersections where the edge of the rect simply touches the boundary of the circle.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">center</td><td>The center of the circle </td></tr>
    <tr><td class="paramname">radius</td><td>The radius of the circle</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if this rect intersects the given circle. </dd></dl>

</div>
</div>
<a id="a2741d5ad28d816b7ff4c193c0ff64b7a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2741d5ad28d816b7ff4c193c0ff64b7a">&#9670;&nbsp;</a></span>equals()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool cugl::Rect::equals </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classcugl_1_1_rect.html">Rect</a>&#160;</td>
          <td class="paramname"><em>rect</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>variance</em> = <code>5.0e-4f</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns true if the rects are within tolerance of each other.</p>
<p>The tolerance bound is on attribute independently.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">rect</td><td>The rect to compare against. </td></tr>
    <tr><td class="paramname">variance</td><td>The comparison tolerance.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if the rects are within tolerance of each other. </dd></dl>

</div>
</div>
<a id="a71e65e39312c191463ebd3636142335c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a71e65e39312c191463ebd3636142335c">&#9670;&nbsp;</a></span>expand() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcugl_1_1_rect.html">Rect</a>&amp; cugl::Rect::expand </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classcugl_1_1_vec2.html">Vec2</a>&#160;</td>
          <td class="paramname"><em>point</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Expands this rectangle to the minimal one containing the given point.</p>
<p>If the rectangle already contains the point, it is unchanged.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">point</td><td>The point to envelop</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>This rect, after the expansion. </dd></dl>

</div>
</div>
<a id="ac0d5f0fda252b9d9d41c9cc647a49cc0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac0d5f0fda252b9d9d41c9cc647a49cc0">&#9670;&nbsp;</a></span>expand() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcugl_1_1_rect.html">Rect</a>&amp; cugl::Rect::expand </td>
          <td>(</td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>factor</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Expands this rectangle uniformly from its center.</p>
<p>Each edge of the rectangle is adjusted factor away from the center point. As a result, this method changes both origin and size. The value factor can be negative, in which case the rect shrinks in size.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">factor</td><td>The amount to expand each edge from the center.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>This rect, after the expansion. </dd></dl>

</div>
</div>
<a id="a1536f5ee1c8aae60ec6ff9f3598bde4c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1536f5ee1c8aae60ec6ff9f3598bde4c">&#9670;&nbsp;</a></span>getCircumscription() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcugl_1_1_rect.html">Rect</a> cugl::Rect::getCircumscription </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classcugl_1_1_affine2.html">Affine2</a> &amp;&#160;</td>
          <td class="paramname"><em>transform</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>loose</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns the rectangle circumscribed inside the transformed quadrilateral.</p>
<p>A rectangle must be axis-aligned, so transforming a rectangle does not necessarily produce a rectangle (particularly when the transform includes a rotation). Instead, it produces a quadrilateral polygon. The method sets this rectangle to be the unique circumscribing rectangle that shares the same center as the quadrilateral.</p>
<p>If circumscription is tight, this means the rectangle is the bounding box of the four vertices. If it is loose, then the circumscription will only contain two (opposing) vertices, picking the vertices that maximize the&#x2410; minimal axis distance. This creates a smaller rectangle that is still a reasonable fit for the transformed quadrilateral.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">transform</td><td>The affine transform </td></tr>
    <tr><td class="paramname">loose</td><td>Whether to loosen the circumscription</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the rectangle circumscribed inside the transformed quadrilateral. </dd></dl>

</div>
</div>
<a id="a14995e9ad51d2d62fdcec29602b761f0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a14995e9ad51d2d62fdcec29602b761f0">&#9670;&nbsp;</a></span>getCircumscription() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcugl_1_1_rect.html">Rect</a> cugl::Rect::getCircumscription </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classcugl_1_1_mat4.html">Mat4</a> &amp;&#160;</td>
          <td class="paramname"><em>transform</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>loose</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns the rectangle circumscribed inside the transformed quadrilateral.</p>
<p>A rectangle must be axis-aligned, so transforming a rectangle does not necessarily produce a rectangle (particularly when the transform includes a rotation). Instead, it produces a quadrilateral polygon. The method sets this rectangle to be the unique circumscribing rectangle that shares the same center as the quadrilateral.</p>
<p>If circumscription is tight, this means the rectangle is the bounding box of the four vertices. If it is loose, then the circumscription will only contain two (opposing) vertices, picking the vertices that maximize the&#x2410; minimal axis distance. This creates a smaller rectangle that is still a reasonable fit for the transformed quadrilateral.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">transform</td><td>The affine transform </td></tr>
    <tr><td class="paramname">loose</td><td>Whether to loosen the circumscription</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the rectangle circumscribed inside the transformed quadrilateral. </dd></dl>

</div>
</div>
<a id="aa58293fbcf86c5fd7810ece87f6bc0a9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa58293fbcf86c5fd7810ece87f6bc0a9">&#9670;&nbsp;</a></span>getExpansion() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcugl_1_1_rect.html">Rect</a> cugl::Rect::getExpansion </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classcugl_1_1_vec2.html">Vec2</a>&#160;</td>
          <td class="paramname"><em>point</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns a copy of this rectangle, expanded to contain the given point.</p>
<p>If the rectangle already contains the point, the rect is the same as the original.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">point</td><td>The point to envelop</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a copy of this rect, expanded to contain the given point. </dd></dl>

</div>
</div>
<a id="a0721f6e3cd806b283e534a25620ae7ee"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0721f6e3cd806b283e534a25620ae7ee">&#9670;&nbsp;</a></span>getExpansion() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcugl_1_1_rect.html">Rect</a> cugl::Rect::getExpansion </td>
          <td>(</td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>factor</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns a copy of this rect, expanded uniformly from its center.</p>
<p>Each edge of the rectangle is adjusted factor away from the center point. As a result, this method changes both origin and size. The value factor can be negative, in which case the rect shrinks in size.</p>
<p>Note: This does not modify the rect.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">factor</td><td>The amount to expand each edge from the center.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a copy of this rect, expanded uniformly from its center. </dd></dl>

</div>
</div>
<a id="a68be09ab82d0aa41d72584a07533c41e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a68be09ab82d0aa41d72584a07533c41e">&#9670;&nbsp;</a></span>getInscription() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcugl_1_1_rect.html">Rect</a> cugl::Rect::getInscription </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classcugl_1_1_affine2.html">Affine2</a> &amp;&#160;</td>
          <td class="paramname"><em>transform</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>loose</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns the rectangle inscribed inside the transformed quadrilateral.</p>
<p>A rectangle must be axis-aligned, so transforming a rectangle does not necessarily produce a rectangle (particularly when the transform includes a rotation). Instead, it produces a quadrilateral polygon. The method sets this rectangle to be the unique inscribing rectangle that shares the same center as the quadrilateral.</p>
<p>If the inscription is loose, exactly one diagonal is inscribed in the rectangle (but not both). This creates a slightly larger rectangle that is still a reasonable fit for the transformed quadrilateral.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">transform</td><td>The affine transform </td></tr>
    <tr><td class="paramname">loose</td><td>Whether to loosen the inscription</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the rectangle inscribed inside the transformed quadrilateral. </dd></dl>

</div>
</div>
<a id="a6f58c2f52f1d6bd76904fa9c7c036b05"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6f58c2f52f1d6bd76904fa9c7c036b05">&#9670;&nbsp;</a></span>getInscription() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcugl_1_1_rect.html">Rect</a> cugl::Rect::getInscription </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classcugl_1_1_mat4.html">Mat4</a> &amp;&#160;</td>
          <td class="paramname"><em>transform</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>loose</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns the rectangle inscribed inside the transformed quadrilateral.</p>
<p>A rectangle must be axis-aligned, so transforming a rectangle does not necessarily produce a rectangle (particularly when the transform includes a rotation). Instead, it produces a quadrilateral polygon. The method returns the unique inscribing rectangle that shares the same center as the quadrilateral.</p>
<p>If the inscription is loose, exactly one diagonal is inscribed in the rectangle (but not both). This creates a slightly larger rectangle that is still a reasonable fit for the transformed quadrilateral.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">transform</td><td>The affine transform </td></tr>
    <tr><td class="paramname">loose</td><td>Whether to loosen the inscription</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the rectangle inscribed inside the transformed quadrilateral. </dd></dl>

</div>
</div>
<a id="a012e47e0372ccc38c53779f7dbec6640"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a012e47e0372ccc38c53779f7dbec6640">&#9670;&nbsp;</a></span>getIntersection()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcugl_1_1_rect.html">Rect</a> cugl::Rect::getIntersection </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classcugl_1_1_rect.html">Rect</a> &amp;&#160;</td>
          <td class="paramname"><em>rect</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns the intersection of this rect and the other.</p>
<p>If there is no intersection, this method returns the zero rectangle.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">rect</td><td>The rect to intersect with this one.</td></tr>
  </table>
  </dd>
</dl>
<p>Note: This does not modify the rect.</p>
<dl class="section return"><dt>Returns</dt><dd>the intersection of this rect and the other. </dd></dl>

</div>
</div>
<a id="ac389c5568f3ec9ed6c7e6753c3013bc5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac389c5568f3ec9ed6c7e6753c3013bc5">&#9670;&nbsp;</a></span>getMaxX()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">float cugl::Rect::getMaxX </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns the rightmost x-value of the rect.</p>
<dl class="section return"><dt>Returns</dt><dd>the rightmost x-value of the rect. </dd></dl>

</div>
</div>
<a id="a57de3d09215e9b8e965222517620e950"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a57de3d09215e9b8e965222517620e950">&#9670;&nbsp;</a></span>getMaxY()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">float cugl::Rect::getMaxY </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns the top y-value of the rect.</p>
<dl class="section return"><dt>Returns</dt><dd>the top y-value of the rect. </dd></dl>

</div>
</div>
<a id="a9a4917aee577052c4a0dcf3810c8549d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9a4917aee577052c4a0dcf3810c8549d">&#9670;&nbsp;</a></span>getMerge()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcugl_1_1_rect.html">Rect</a> cugl::Rect::getMerge </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classcugl_1_1_rect.html">Rect</a> &amp;&#160;</td>
          <td class="paramname"><em>rect</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns the union of this rect and the other.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">rect</td><td>The rect to union with this one.</td></tr>
  </table>
  </dd>
</dl>
<p>Note: This does not modify the rect.</p>
<dl class="section return"><dt>Returns</dt><dd>the union of this rect and the other. </dd></dl>

</div>
</div>
<a id="a0c2f842b441bd2ea524d4ca5b2e1e0b7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0c2f842b441bd2ea524d4ca5b2e1e0b7">&#9670;&nbsp;</a></span>getMidX()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">float cugl::Rect::getMidX </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns the center x-value of the rect.</p>
<dl class="section return"><dt>Returns</dt><dd>the center x-value of the rect. </dd></dl>

</div>
</div>
<a id="af7f143d2faea2ceab609b422ac085062"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af7f143d2faea2ceab609b422ac085062">&#9670;&nbsp;</a></span>getMidY()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">float cugl::Rect::getMidY </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns the center y-value of the rect.</p>
<dl class="section return"><dt>Returns</dt><dd>the center y-value of the rect. </dd></dl>

</div>
</div>
<a id="a5ab49d71586a65c2d962ca690e5c0316"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5ab49d71586a65c2d962ca690e5c0316">&#9670;&nbsp;</a></span>getMinX()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">float cugl::Rect::getMinX </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns the leftmost x-value of the rect.</p>
<dl class="section return"><dt>Returns</dt><dd>the leftmost x-value of the rect. </dd></dl>

</div>
</div>
<a id="a1f768e5eb4f2238a6c283261027d9acd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1f768e5eb4f2238a6c283261027d9acd">&#9670;&nbsp;</a></span>getMinY()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">float cugl::Rect::getMinY </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns the bottom y-value of the rect.</p>
<dl class="section return"><dt>Returns</dt><dd>the bottom y-value of the rect. </dd></dl>

</div>
</div>
<a id="ac1ef89869b2a006764af38b83d954eb5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac1ef89869b2a006764af38b83d954eb5">&#9670;&nbsp;</a></span>getScale() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcugl_1_1_rect.html">Rect</a> cugl::Rect::getScale </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classcugl_1_1_vec2.html">Vec2</a>&#160;</td>
          <td class="paramname"><em>scale</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns the non-uniform scale of this rectangle.</p>
<p>The origin of the rectangle is unaffected. To move the origin, translate the rectangle.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">scale</td><td>The non-uniform scaling factor</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the non-uniform scale of this rectangle. </dd></dl>

</div>
</div>
<a id="a9096494d65ffac6243bb909f77da4f45"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9096494d65ffac6243bb909f77da4f45">&#9670;&nbsp;</a></span>getScale() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcugl_1_1_rect.html">Rect</a> cugl::Rect::getScale </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classcugl_1_1_vec2.html">Vec2</a>&#160;</td>
          <td class="paramname"><em>scale</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classcugl_1_1_vec2.html">Vec2</a>&#160;</td>
          <td class="paramname"><em>anchor</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns the non-uniform scale of this rectangle.</p>
<p>The origin scale is the given anchor point, which is a percentage of the rectangle. (0,0) is the origin (bottom left corner) of the rectangle, while (1,1) is the top right corner of the rectangle.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">scale</td><td>The non-uniform scaling factor </td></tr>
    <tr><td class="paramname">anchor</td><td>The anchor for the scale origin point.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the non-uniform scale of this rectangle. </dd></dl>

</div>
</div>
<a id="a634c4dd06927be6f3dcd2e3d94bc8f1c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a634c4dd06927be6f3dcd2e3d94bc8f1c">&#9670;&nbsp;</a></span>getScale() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcugl_1_1_rect.html">Rect</a> cugl::Rect::getScale </td>
          <td>(</td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>scale</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns the uniform scale of this rectangle.</p>
<p>The origin of the rectangle is unaffected. To move the origin, translate the rectangle.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">scale</td><td>The uniform scaling factor</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the uniform scale of this rectangle. </dd></dl>

</div>
</div>
<a id="a7d2a6b45f0b13bd1d2ee314bd89eeeb5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7d2a6b45f0b13bd1d2ee314bd89eeeb5">&#9670;&nbsp;</a></span>getScale() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcugl_1_1_rect.html">Rect</a> cugl::Rect::getScale </td>
          <td>(</td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>sx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>sy</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns the non-uniform scale of this rectangle.</p>
<p>The origin of the rectangle is unaffected. To move the origin, translate the rectangle.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">sx</td><td>The x-axis scale factor </td></tr>
    <tr><td class="paramname">sy</td><td>The y-axis scale factor</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the non-uniform scale of this rectangle. </dd></dl>

</div>
</div>
<a id="a647f969200fca03ca9462d9f85e7c785"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a647f969200fca03ca9462d9f85e7c785">&#9670;&nbsp;</a></span>getTranslation() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcugl_1_1_rect.html">Rect</a> cugl::Rect::getTranslation </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classcugl_1_1_vec2.html">Vec2</a>&#160;</td>
          <td class="paramname"><em>vec</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns the translation of this rectangle by the given vector.</p>
<p>The size of the rectangle is unaffected. To alter the rectangle size, scale the rectangle.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">vec</td><td>The translation vector</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the translation of this rectangle by the given vector. </dd></dl>

</div>
</div>
<a id="af55de7d842825cc2deaf14238ed7c3cd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af55de7d842825cc2deaf14238ed7c3cd">&#9670;&nbsp;</a></span>getTranslation() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcugl_1_1_rect.html">Rect</a> cugl::Rect::getTranslation </td>
          <td>(</td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>y</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns the translation of this rectangle by the given vector.</p>
<p>The size of the rectangle is unaffected. To alter the rectangle size, scale the rectangle.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>The translation x amount </td></tr>
    <tr><td class="paramname">y</td><td>The translation y amount</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the translation of this rectangle by the given vector. </dd></dl>

</div>
</div>
<a id="a1993fab1a5f419ff7b9548e7ab7643fe"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1993fab1a5f419ff7b9548e7ab7643fe">&#9670;&nbsp;</a></span>inscribe() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcugl_1_1_rect.html">Rect</a>&amp; cugl::Rect::inscribe </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classcugl_1_1_affine2.html">Affine2</a> &amp;&#160;</td>
          <td class="paramname"><em>transform</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>loose</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Inscribes this rectangle inside the transformed quadrilateral.</p>
<p>A rectangle must be axis-aligned, so transforming a rectangle does not necessarily produce a rectangle (particularly when the transform includes a rotation). Instead, it produces a quadrilateral polygon. The method sets this rectangle to be the unique inscribing rectangle that shares the same center as the quadrilateral.</p>
<p>If the inscription is loose, exactly one diagonal is inscribed in the rectangle (but not both). This creates a slightly larger rectangle that is still a reasonable fit for the transformed quadrilateral.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">transform</td><td>The affine transform </td></tr>
    <tr><td class="paramname">loose</td><td>Whether to loosen the inscription</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>This inscribing rectangle </dd></dl>

</div>
</div>
<a id="a7592a85c8d4b155691d48fd373b1b005"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7592a85c8d4b155691d48fd373b1b005">&#9670;&nbsp;</a></span>inscribe() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcugl_1_1_rect.html">Rect</a>&amp; cugl::Rect::inscribe </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classcugl_1_1_mat4.html">Mat4</a> &amp;&#160;</td>
          <td class="paramname"><em>transform</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>loose</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Inscribes this rectangle inside the transformed quadrilateral.</p>
<p>A rectangle must be axis-aligned, so transforming a rectangle does not necessarily produce a rectangle (particularly when the transform includes a rotation). Instead, it produces a quadrilateral polygon. The method sets this rectangle to be the unique inscribing rectangle that shares the same center as the quadrilateral.</p>
<p>If the inscription is loose, exactly one diagonal is inscribed in the rectangle (but not both). This creates a slightly larger rectangle that is still a reasonable fit for the transformed quadrilateral.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">transform</td><td>The affine transform </td></tr>
    <tr><td class="paramname">loose</td><td>Whether to loosen the inscription</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>This inscribing rectangle </dd></dl>

</div>
</div>
<a id="adeb28a7dd36edf38288ecee4ff1aaca5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adeb28a7dd36edf38288ecee4ff1aaca5">&#9670;&nbsp;</a></span>inside()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool cugl::Rect::inside </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classcugl_1_1_rect.html">Rect</a>&#160;</td>
          <td class="paramname"><em>rect</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns true if this rect fits inside of the given rect.</p>
<p>This method does not test for strict containment. To test for strict containment, use the comparison operator &lt;.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">rect</td><td>The potentially larger rect</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if this rect fits inside of the given rect. </dd></dl>

</div>
</div>
<a id="a92d517a910f0d454de1d5a5d41e2421d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a92d517a910f0d454de1d5a5d41e2421d">&#9670;&nbsp;</a></span>intersect()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcugl_1_1_rect.html">Rect</a>&amp; cugl::Rect::intersect </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classcugl_1_1_rect.html">Rect</a> &amp;&#160;</td>
          <td class="paramname"><em>rect</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Computes the intersection of this rect and the other, assigning it in place.</p>
<p>If there is no intersection, this rect becomes the zero rectangle.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">rect</td><td>The rect to intersect with this one.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>This rect, after the intersection operation. </dd></dl>

</div>
</div>
<a id="a88d643bfe0eaad58bbec55e4c2d70c4f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a88d643bfe0eaad58bbec55e4c2d70c4f">&#9670;&nbsp;</a></span>isDegenerate()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">float cugl::Rect::isDegenerate </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns true if the rectangle has non-positive size.</p>
<dl class="section return"><dt>Returns</dt><dd>true if the rectangle has non-positive size. </dd></dl>

</div>
</div>
<a id="a7f7949e8308f3d60859d4a68cb946723"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7f7949e8308f3d60859d4a68cb946723">&#9670;&nbsp;</a></span>merge()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcugl_1_1_rect.html">Rect</a>&amp; cugl::Rect::merge </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classcugl_1_1_rect.html">Rect</a> &amp;&#160;</td>
          <td class="paramname"><em>rect</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Computes the union of this rect and the other, assigning it in place.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">rect</td><td>The rect to union with this one.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>This rect, after the union operation. </dd></dl>

</div>
</div>
<a id="a39cb827dec1676d375b98aae005d0b13"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a39cb827dec1676d375b98aae005d0b13">&#9670;&nbsp;</a></span>operator std::string()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">cugl::Rect::operator std::string </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Cast from <a class="el" href="classcugl_1_1_rect.html">Rect</a> to a string. </p>

</div>
</div>
<a id="a7a7d4d96f5b517462ebbd5c953ba76b9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7a7d4d96f5b517462ebbd5c953ba76b9">&#9670;&nbsp;</a></span>operator!=()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool cugl::Rect::operator!= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classcugl_1_1_rect.html">Rect</a>&#160;</td>
          <td class="paramname"><em>rect</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns true if the rects are not equal to each other.</p>
<p>This operator uses exact equality and may fail due to round-off error.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">rect</td><td>The rect to compare against.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if the rects are not equal to each other. </dd></dl>

</div>
</div>
<a id="acfe2a25d131c04d39321df1a28085699"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acfe2a25d131c04d39321df1a28085699">&#9670;&nbsp;</a></span>operator*() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcugl_1_1_rect.html">Rect</a> cugl::Rect::operator* </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classcugl_1_1_affine2.html">Affine2</a> &amp;&#160;</td>
          <td class="paramname"><em>transform</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns the bounding box of the transformed quadrilateral.</p>
<p>A rectangle must be axis-aligned, so transforming a rectangle does not necessarily produce a rectangle (particularly when the transform includes a rotation). Instead, it produces a quadrilateral polygon. The method returns the unique circumscribing rectangle that shares the same center as the quadrilateral.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">transform</td><td>The affine transform</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the bounding box of the transformed quadrilateral. </dd></dl>

</div>
</div>
<a id="aa853fd558126dbc21dc065b42a4aef1e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa853fd558126dbc21dc065b42a4aef1e">&#9670;&nbsp;</a></span>operator*() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcugl_1_1_rect.html">Rect</a> cugl::Rect::operator* </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classcugl_1_1_mat4.html">Mat4</a> &amp;&#160;</td>
          <td class="paramname"><em>transform</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns the bounding box of the transformed quadrilateral.</p>
<p>A rectangle must be axis-aligned, so transforming a rectangle does not necessarily produce a rectangle (particularly when the transform includes a rotation). Instead, it produces a quadrilateral polygon. The method returns the unique circumscribing rectangle that shares the same center as the quadrilateral.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">transform</td><td>The affine transform</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the bounding box of the transformed quadrilateral. </dd></dl>

</div>
</div>
<a id="aaa19b82d39dddf90eedefec69d4989a7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaa19b82d39dddf90eedefec69d4989a7">&#9670;&nbsp;</a></span>operator*() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcugl_1_1_rect.html">Rect</a> cugl::Rect::operator* </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classcugl_1_1_vec2.html">Vec2</a>&#160;</td>
          <td class="paramname"><em>scale</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns the non-uniform scale of this rectangle.</p>
<p>The origin of the rectangle is unaffected. To move the origin, translate the rectangle.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">scale</td><td>The uniform scaling factor</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the non-uniform scale of this rectangle. </dd></dl>

</div>
</div>
<a id="aaf9b6d5cd9277f17d67467ff6dcbcfe6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaf9b6d5cd9277f17d67467ff6dcbcfe6">&#9670;&nbsp;</a></span>operator*() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcugl_1_1_rect.html">Rect</a> cugl::Rect::operator* </td>
          <td>(</td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>scale</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns the uniform scale of this rectangle.</p>
<p>The origin of the rectangle is unaffected. To move the origin, translate the rectangle.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">scale</td><td>The uniform scaling factor</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the uniform scale of this rectangle. </dd></dl>

</div>
</div>
<a id="a7c48b11fafbb9691fbdff5e7e79b7457"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7c48b11fafbb9691fbdff5e7e79b7457">&#9670;&nbsp;</a></span>operator*=() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcugl_1_1_rect.html">Rect</a>&amp; cugl::Rect::operator*= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classcugl_1_1_affine2.html">Affine2</a> &amp;&#160;</td>
          <td class="paramname"><em>transform</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Sets this rectangle to the bounding box of the transformed quadrilateral.</p>
<p>A rectangle must be axis-aligned, so transforming a rectangle does not necessarily produce a rectangle (particularly when the transform includes a rotation). Instead, it produces a quadrilateral polygon. The method sets this rectangle to be the unique circumscribing rectangle that shares the same center as the quadrilateral.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">transform</td><td>The affine transform</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>This rectangle, as the bounding box of the transformed quadrilateral. </dd></dl>

</div>
</div>
<a id="a0e91f416a0d5a25b7c3d8423119b7c02"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0e91f416a0d5a25b7c3d8423119b7c02">&#9670;&nbsp;</a></span>operator*=() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcugl_1_1_rect.html">Rect</a>&amp; cugl::Rect::operator*= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classcugl_1_1_mat4.html">Mat4</a> &amp;&#160;</td>
          <td class="paramname"><em>transform</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Sets this rectangle to the bounding box of the transformed quadrilateral.</p>
<p>A rectangle must be axis-aligned, so transforming a rectangle does not necessarily produce a rectangle (particularly when the transform includes a rotation). Instead, it produces a quadrilateral polygon. The method sets this rectangle to be the unique circumscribing rectangle that shares the same center as the quadrilateral.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">transform</td><td>The affine transform</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>This rectangle, as the bounding box of the transformed quadrilateral. </dd></dl>

</div>
</div>
<a id="af918b6f3de7abc3dc20e23619a43dffb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af918b6f3de7abc3dc20e23619a43dffb">&#9670;&nbsp;</a></span>operator*=() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcugl_1_1_rect.html">Rect</a>&amp; cugl::Rect::operator*= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classcugl_1_1_vec2.html">Vec2</a>&#160;</td>
          <td class="paramname"><em>scale</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Nonuniformly scales the size of this rectangle.</p>
<p>The origin of the rectangle is unaffected. To move the origin, translate the rectangle.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">scale</td><td>The non-uniform scaling factor</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>This rectangle, scaled non-uniformly. </dd></dl>

</div>
</div>
<a id="a63216dc69d543d6f67caeaad3bca13b1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a63216dc69d543d6f67caeaad3bca13b1">&#9670;&nbsp;</a></span>operator*=() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcugl_1_1_rect.html">Rect</a>&amp; cugl::Rect::operator*= </td>
          <td>(</td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>scale</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Uniformly the scales the size of this rectangle.</p>
<p>The origin of the rectangle is unaffected. To move the origin, translate the rectangle.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">scale</td><td>The uniform scaling factor</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>This rectangle, scaled uniformly. </dd></dl>

</div>
</div>
<a id="ad08a46588bf8dfdc60cff7c5cd572659"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad08a46588bf8dfdc60cff7c5cd572659">&#9670;&nbsp;</a></span>operator+() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcugl_1_1_rect.html">Rect</a> cugl::Rect::operator+ </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classcugl_1_1_rect.html">Rect</a>&#160;</td>
          <td class="paramname"><em>rect</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns the union of this rect and the other.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">rect</td><td>The rect to union with this one.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the union of this rect and the other. </dd></dl>

</div>
</div>
<a id="afbbea4a79e80b870d62c6c63f12ff711"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afbbea4a79e80b870d62c6c63f12ff711">&#9670;&nbsp;</a></span>operator+() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcugl_1_1_rect.html">Rect</a> cugl::Rect::operator+ </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classcugl_1_1_vec2.html">Vec2</a>&#160;</td>
          <td class="paramname"><em>vec</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns the translation of this rectangle by the given vector.</p>
<p>The size of the rectangle is unaffected. To alter the rectangle size, scale the rectangle.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">vec</td><td>The translation vector</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the translation of this rectangle by the given vector. </dd></dl>

</div>
</div>
<a id="a92657408615c2e7585595303cd91336c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a92657408615c2e7585595303cd91336c">&#9670;&nbsp;</a></span>operator+=() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcugl_1_1_rect.html">Rect</a>&amp; cugl::Rect::operator+= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classcugl_1_1_rect.html">Rect</a>&#160;</td>
          <td class="paramname"><em>rect</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Computes the union of this rect and the other, assigning it in place.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">rect</td><td>The rect to union with this one.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>This rect, after the union operation. </dd></dl>

</div>
</div>
<a id="ab3e66a2be478b2608a224cbfce57ee20"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab3e66a2be478b2608a224cbfce57ee20">&#9670;&nbsp;</a></span>operator+=() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcugl_1_1_rect.html">Rect</a>&amp; cugl::Rect::operator+= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classcugl_1_1_vec2.html">Vec2</a>&#160;</td>
          <td class="paramname"><em>vec</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Translates this rectangle by the given vector.</p>
<p>The size of the rectangle is unaffected. To alter the rectangle size, scale the rectangle.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">vec</td><td>The translation vector</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>This rectangle, translated. </dd></dl>

</div>
</div>
<a id="a476ba95c82b17483205a9172af7244ad"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a476ba95c82b17483205a9172af7244ad">&#9670;&nbsp;</a></span>operator-()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcugl_1_1_rect.html">Rect</a> cugl::Rect::operator- </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classcugl_1_1_vec2.html">Vec2</a>&#160;</td>
          <td class="paramname"><em>vec</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns the translation of this rectangle by subtracting the given vector.</p>
<p>The size of the rectangle is unaffected. To alter the rectangle size, scale the rectangle.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">vec</td><td>The inverse of the translation vector</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the translation of this rectangle by subtracting the given vector. </dd></dl>

</div>
</div>
<a id="ad33a6c7417a97c6271b1b9707d6a29ab"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad33a6c7417a97c6271b1b9707d6a29ab">&#9670;&nbsp;</a></span>operator-=()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcugl_1_1_rect.html">Rect</a>&amp; cugl::Rect::operator-= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classcugl_1_1_vec2.html">Vec2</a>&#160;</td>
          <td class="paramname"><em>vec</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Translates this rectangle by subtracting the given vector.</p>
<p>The size of the rectangle is unaffected. To alter the rectangle size, scale the rectangle.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">vec</td><td>The inverse of the translation vector</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>This rectangle, translated. </dd></dl>

</div>
</div>
<a id="aa216203063b639123f0e6b36dea55584"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa216203063b639123f0e6b36dea55584">&#9670;&nbsp;</a></span>operator/() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcugl_1_1_rect.html">Rect</a> cugl::Rect::operator/ </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classcugl_1_1_vec2.html">Vec2</a>&#160;</td>
          <td class="paramname"><em>scale</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns the non-uniform scale of this rectangle by the inverse of scale.</p>
<p>The origin of the rectangle is unaffected. To move the origin, translate the rectangle.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">scale</td><td>The inverse of the uniform scaling factor</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the non-uniform scale of this rectangle by the inverse of scale. </dd></dl>

</div>
</div>
<a id="a73cd383e3c3e4446b106ae842b0d4d6f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a73cd383e3c3e4446b106ae842b0d4d6f">&#9670;&nbsp;</a></span>operator/() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcugl_1_1_rect.html">Rect</a> cugl::Rect::operator/ </td>
          <td>(</td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>scale</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns the uniform scale of this rectangle by the inverse of scale.</p>
<p>The origin of the rectangle is unaffected. To move the origin, translate the rectangle.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">scale</td><td>The inverse of the uniform scaling factor</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the uniform scale of this rectangle by the inverse of scale. </dd></dl>

</div>
</div>
<a id="aa26f7bf4d0b93e463d031fd4beeb79db"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa26f7bf4d0b93e463d031fd4beeb79db">&#9670;&nbsp;</a></span>operator/=() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcugl_1_1_rect.html">Rect</a>&amp; cugl::Rect::operator/= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classcugl_1_1_vec2.html">Vec2</a>&#160;</td>
          <td class="paramname"><em>scale</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Nonuniformly scales the size of this rectangle by the inverse of scale.</p>
<p>The origin of the rectangle is unaffected. To move the origin, translate the rectangle.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">scale</td><td>The inverse of the non-uniform scaling factor</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>This rectangle, scaled non-uniformly. </dd></dl>

</div>
</div>
<a id="a12de08db5b162e3e31cca3d3866d0fa2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a12de08db5b162e3e31cca3d3866d0fa2">&#9670;&nbsp;</a></span>operator/=() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcugl_1_1_rect.html">Rect</a>&amp; cugl::Rect::operator/= </td>
          <td>(</td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>scale</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Uniformly scales the size of this rectangle by the inverse of scale.</p>
<p>The origin of the rectangle is unaffected. To move the origin, translate the rectangle.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">scale</td><td>The inverse of the uniform scaling factor</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>This rectangle, scaled uniformly. </dd></dl>

</div>
</div>
<a id="adfdafde79197420b30a8d221b89a1fd8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adfdafde79197420b30a8d221b89a1fd8">&#9670;&nbsp;</a></span>operator&lt;()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool cugl::Rect::operator&lt; </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classcugl_1_1_rect.html">Rect</a>&#160;</td>
          <td class="paramname"><em>rect</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns true if this rect properly fits inside of the given rect.</p>
<p>Proper containment means that no edges of the two rects touch.</p>
<p>This operator is provided for convenience. However, this does not provide a total order, making it unsafe for std::sort.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">rect</td><td>The potentially larger rect</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if this rect properly fits inside of the given rect. </dd></dl>

</div>
</div>
<a id="ace2c5235b60c5064b1104e7e989598cc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ace2c5235b60c5064b1104e7e989598cc">&#9670;&nbsp;</a></span>operator&lt;=()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool cugl::Rect::operator&lt;= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classcugl_1_1_rect.html">Rect</a>&#160;</td>
          <td class="paramname"><em>rect</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns true if this rect fits inside of the given rect.</p>
<p>This operator is provided for convenience. However, this does not provide a total order, making it unsafe for std::sort.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">rect</td><td>The potentially larger rect</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if this rect fits inside of the given rect. </dd></dl>

</div>
</div>
<a id="a4d2d1a262d1b5a45d2acd8aa27268a57"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4d2d1a262d1b5a45d2acd8aa27268a57">&#9670;&nbsp;</a></span>operator=() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcugl_1_1_rect.html">Rect</a>&amp; cugl::Rect::operator= </td>
          <td>(</td>
          <td class="paramtype">const float *&#160;</td>
          <td class="paramname"><em>array</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Sets the elements of this rect from the values in the specified array.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">array</td><td>An array containing the elements in the order origin, size.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>This rectangle, after assignment </dd></dl>

</div>
</div>
<a id="a28888db224ac5e165b2b47a63907476a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a28888db224ac5e165b2b47a63907476a">&#9670;&nbsp;</a></span>operator=() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcugl_1_1_rect.html">Rect</a>&amp; cugl::Rect::operator= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classcugl_1_1_rect.html">Rect</a> &amp;&amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Sets this rectangle to be a copy of the given one.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">other</td><td>The rectangle to copy</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>This rectangle, returned for chaining </dd></dl>

</div>
</div>
<a id="a617646f173594ce0884d6554d0982a20"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a617646f173594ce0884d6554d0982a20">&#9670;&nbsp;</a></span>operator=() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcugl_1_1_rect.html">Rect</a>&amp; cugl::Rect::operator= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classcugl_1_1_rect.html">Rect</a> &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Sets this rectangle to be a copy of the given one.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">other</td><td>The rectangle to copy</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>This rectangle, returned for chaining </dd></dl>

</div>
</div>
<a id="a4d9f00296d915bf4c2230280cec6db99"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4d9f00296d915bf4c2230280cec6db99">&#9670;&nbsp;</a></span>operator==()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool cugl::Rect::operator== </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classcugl_1_1_rect.html">Rect</a>&#160;</td>
          <td class="paramname"><em>rect</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns true if the rects are equal to each other.</p>
<p>This operator uses exact equality and may fail due to round-off error.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">rect</td><td>The rect to compare against.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if the rects are equal to each other. </dd></dl>

</div>
</div>
<a id="a6b18c7034936bd55067bb9ffeaffe623"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6b18c7034936bd55067bb9ffeaffe623">&#9670;&nbsp;</a></span>operator&gt;()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool cugl::Rect::operator&gt; </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classcugl_1_1_rect.html">Rect</a>&#160;</td>
          <td class="paramname"><em>rect</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns true if this rect can properly hold the given rect.</p>
<p>Proper containment means that no edges of the two rects touch.</p>
<p>This operator is provided for convenience. However, this does not provide a total order, making it unsafe for std::sort.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">rect</td><td>The potentially smaller rect</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if this rect can properly hold the given rect. </dd></dl>

</div>
</div>
<a id="af075c774b56a45268e6bf8ddb4cf40a8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af075c774b56a45268e6bf8ddb4cf40a8">&#9670;&nbsp;</a></span>operator&gt;=()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool cugl::Rect::operator&gt;= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classcugl_1_1_rect.html">Rect</a>&#160;</td>
          <td class="paramname"><em>rect</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns true if this rect can hold the given rect.</p>
<p>This operator is provided for convenience. However, this does not provide a total order, making it unsafe for std::sort.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">rect</td><td>The potentially smaller rect</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if this rect can hold the given rect. </dd></dl>

</div>
</div>
<a id="aa22399ddb73b89ca566b0101a704c9b7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa22399ddb73b89ca566b0101a704c9b7">&#9670;&nbsp;</a></span>scale() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcugl_1_1_rect.html">Rect</a>&amp; cugl::Rect::scale </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classcugl_1_1_vec2.html">Vec2</a>&#160;</td>
          <td class="paramname"><em>scale</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Nonuniformly scales the size of this rectangle.</p>
<p>The origin of the rectangle is unaffected. To move the origin, translate the rectangle.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">scale</td><td>The non-uniform scaling factor</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>This polygon, scaled non-uniformly. </dd></dl>

</div>
</div>
<a id="a7c07784bd642d78a6893e390e13f43e5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7c07784bd642d78a6893e390e13f43e5">&#9670;&nbsp;</a></span>scale() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcugl_1_1_rect.html">Rect</a>&amp; cugl::Rect::scale </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classcugl_1_1_vec2.html">Vec2</a>&#160;</td>
          <td class="paramname"><em>scale</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classcugl_1_1_vec2.html">Vec2</a>&#160;</td>
          <td class="paramname"><em>anchor</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Nonuniformly scales this rectangle.</p>
<p>The origin scale is the given anchor point, which is a percentage of the rectangle. (0,0) is the origin (bottom left corner) of the rectangle, while (1,1) is the top right corner of the rectangle.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">scale</td><td>The non-uniform scaling factor </td></tr>
    <tr><td class="paramname">anchor</td><td>The anchor for the scale origin point.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>This polygon, scaled non-uniformly. </dd></dl>

</div>
</div>
<a id="a872252960bcb53d2ed8aba02ca38acd2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a872252960bcb53d2ed8aba02ca38acd2">&#9670;&nbsp;</a></span>scale() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcugl_1_1_rect.html">Rect</a>&amp; cugl::Rect::scale </td>
          <td>(</td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>scale</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Uniformly the scales the size of this rectangle.</p>
<p>The origin of the rectangle is unaffected. To move the origin, translate the rectangle.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">scale</td><td>The uniform scaling factor</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>This rectangle, scaled uniformly. </dd></dl>

</div>
</div>
<a id="a039f3b948de6ab2342bb683c239cf686"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a039f3b948de6ab2342bb683c239cf686">&#9670;&nbsp;</a></span>scale() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcugl_1_1_rect.html">Rect</a>&amp; cugl::Rect::scale </td>
          <td>(</td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>sx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>sy</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Nonuniformly scales the size of this rectangle.</p>
<p>The origin of the rectangle is unaffected. To move the origin, translate the rectangle.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">sx</td><td>The x-axis scale factor </td></tr>
    <tr><td class="paramname">sy</td><td>The y-axis scale factor</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>This polygon, scaled non-uniformly. </dd></dl>

</div>
</div>
<a id="ac09f1a65d0f78b011efc48d47ab1df5f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac09f1a65d0f78b011efc48d47ab1df5f">&#9670;&nbsp;</a></span>set() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcugl_1_1_rect.html">Rect</a>&amp; cugl::Rect::set </td>
          <td>(</td>
          <td class="paramtype">const float *&#160;</td>
          <td class="paramname"><em>array</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Sets the elements of this rect from the values in the specified array.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">array</td><td>An array containing the elements in the order origin, size.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>This rectangle, after assignment </dd></dl>

</div>
</div>
<a id="a47ca4509267a79f9ad5b812d45e3e3b6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a47ca4509267a79f9ad5b812d45e3e3b6">&#9670;&nbsp;</a></span>set() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcugl_1_1_rect.html">Rect</a>&amp; cugl::Rect::set </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classcugl_1_1_rect.html">Rect</a> &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Assigns this rect to be a copy of the given rectangle.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">other</td><td>The rectangle to copy</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>This rectangle, after assignment </dd></dl>

</div>
</div>
<a id="ad7eef24a78f8682405c07c080b68859b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad7eef24a78f8682405c07c080b68859b">&#9670;&nbsp;</a></span>set() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcugl_1_1_rect.html">Rect</a>&amp; cugl::Rect::set </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classcugl_1_1_vec2.html">Vec2</a>&#160;</td>
          <td class="paramname"><em>pos</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classcugl_1_1_size.html">Size</a>&#160;</td>
          <td class="paramname"><em>dimen</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Assigns this rect to have the given position and dimensions.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pos</td><td>The position the bottom left corner </td></tr>
    <tr><td class="paramname">dimen</td><td>The size of the rect</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>This rectangle, after assignment </dd></dl>

</div>
</div>
<a id="a1bb518c79e126297ed8dc1522d171322"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1bb518c79e126297ed8dc1522d171322">&#9670;&nbsp;</a></span>set() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcugl_1_1_rect.html">Rect</a>&amp; cugl::Rect::set </td>
          <td>(</td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>width</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>height</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Assigns this rect to have the given position and dimensions.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>The x-coordinate of the bottom left corner </td></tr>
    <tr><td class="paramname">y</td><td>The y-coordinate of the bottom left corner </td></tr>
    <tr><td class="paramname">width</td><td>The width of the rect </td></tr>
    <tr><td class="paramname">height</td><td>The width of the rect</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>This rectangle, after assignment </dd></dl>

</div>
</div>
<a id="ace3373513cb0fb47f3bb79a02cafd7a0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ace3373513cb0fb47f3bb79a02cafd7a0">&#9670;&nbsp;</a></span>toString()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string cugl::Rect::toString </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>verbose</em> = <code>false</code></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns a string representation of this rectangle for debugging purposes.</p>
<p>If verbose is true, the string will include class information. This allows us to unambiguously identify the class.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">verbose</td><td>Whether to include class information</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a string representation of this rectangle for debuggging purposes. </dd></dl>

</div>
</div>
<a id="a86a012843b44b01777b193b90f8408f9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a86a012843b44b01777b193b90f8408f9">&#9670;&nbsp;</a></span>touches()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool cugl::Rect::touches </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classcugl_1_1_vec2.html">Vec2</a>&#160;</td>
          <td class="paramname"><em>point</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns true if the given point is on the boundar of this rect.</p>
<p>Combining this method with <a class="el" href="classcugl_1_1_rect.html#a670cddafe1b4bd7ded122c57c814aa21">contains()</a> allows you to test for strict containment.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">point</td><td>The point to test</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if the given point is on the boundar of this rect. </dd></dl>

</div>
</div>
<a id="a8a58b8d1296201828b2f79e0a6254041"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8a58b8d1296201828b2f79e0a6254041">&#9670;&nbsp;</a></span>translate() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcugl_1_1_rect.html">Rect</a>&amp; cugl::Rect::translate </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classcugl_1_1_vec2.html">Vec2</a>&#160;</td>
          <td class="paramname"><em>vec</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Translates this rectangle by the given vector.</p>
<p>The size of the rectangle is unaffected. To alter the rectangle size, scale the rectangle.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">vec</td><td>The translation vector</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>This rectangle, translated. </dd></dl>

</div>
</div>
<a id="adc5d6c66c10707a393dd4aefa0f366d8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adc5d6c66c10707a393dd4aefa0f366d8">&#9670;&nbsp;</a></span>translate() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcugl_1_1_rect.html">Rect</a>&amp; cugl::Rect::translate </td>
          <td>(</td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>y</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Translates this rectangle by the given vector.</p>
<p>The size of the rectangle is unaffected. To alter the rectangle size, scale the rectangle.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>The translation x amount </td></tr>
    <tr><td class="paramname">y</td><td>The translation y amount</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>This rectangle, translated. </dd></dl>

</div>
</div>
<h2 class="groupheader">Friends And Related Function Documentation</h2>
<a id="a28dc04b897fac18291037244e362db8f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a28dc04b897fac18291037244e362db8f">&#9670;&nbsp;</a></span>operator* <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcugl_1_1_rect.html">Rect</a> operator* </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classcugl_1_1_vec2.html">Vec2</a>&#160;</td>
          <td class="paramname"><em>scale</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classcugl_1_1_rect.html">Rect</a>&#160;</td>
          <td class="paramname"><em>rect</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">friend</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns the non-uniform scale of the rectangle.</p>
<p>The origin of the rectangle is unaffected. To move the origin, translate the rectangle.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">scale</td><td>The non-uniform scaling factor </td></tr>
    <tr><td class="paramname">rect</td><td>The rectangle to scale</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the non-uniform scale of the rectangle. </dd></dl>

</div>
</div>
<a id="ab1748cda3d871802233327120db7e92c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab1748cda3d871802233327120db7e92c">&#9670;&nbsp;</a></span>operator* <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcugl_1_1_rect.html">Rect</a> operator* </td>
          <td>(</td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>scale</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classcugl_1_1_rect.html">Rect</a>&#160;</td>
          <td class="paramname"><em>rect</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">friend</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns the uniform scale of the rectangle.</p>
<p>The origin of the rectangle is unaffected. To move the origin, translate the rectangle.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">scale</td><td>The uniform scaling factor </td></tr>
    <tr><td class="paramname">rect</td><td>The rectangle to scale</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the uniform scale of the rectangle. </dd></dl>

</div>
</div>
<a id="a5d92df22d5165f6c2d8fcf2e3485cac2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5d92df22d5165f6c2d8fcf2e3485cac2">&#9670;&nbsp;</a></span>operator+</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcugl_1_1_rect.html">Rect</a> operator+ </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classcugl_1_1_vec2.html">Vec2</a>&#160;</td>
          <td class="paramname"><em>vec</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classcugl_1_1_rect.html">Rect</a>&#160;</td>
          <td class="paramname"><em>rect</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">friend</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns the translation of the rectangle by the given vector.</p>
<p>The size of the rectangle is unaffected. To alter the rectangle size, scale the rectangle.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">vec</td><td>The translation vector </td></tr>
    <tr><td class="paramname">rect</td><td>The rectangle to translate</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the translation of the rectangle by the given vector. </dd></dl>

</div>
</div>
<a id="a5d61754bad1f023c823244ad098c7b26"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5d61754bad1f023c823244ad098c7b26">&#9670;&nbsp;</a></span>operator-</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcugl_1_1_rect.html">Rect</a> operator- </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classcugl_1_1_vec2.html">Vec2</a>&#160;</td>
          <td class="paramname"><em>vec</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classcugl_1_1_rect.html">Rect</a>&#160;</td>
          <td class="paramname"><em>rect</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">friend</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns the translation of the rectangle by subtracting the given vector.</p>
<p>The size of the rectangle is unaffected. To alter the rectangle size, scale the rectangle.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">vec</td><td>The inverse of the translation vector </td></tr>
    <tr><td class="paramname">rect</td><td>The rectangle to translate</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the translation of the rectangle by subtracting the given vector. </dd></dl>

</div>
</div>
<h2 class="groupheader">Member Data Documentation</h2>
<a id="a4606335d9ed1ed883cff5b744189ffb8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4606335d9ed1ed883cff5b744189ffb8">&#9670;&nbsp;</a></span>origin</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcugl_1_1_vec2.html">Vec2</a> cugl::Rect::origin</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>The bottom left point of rect. <br  />
 </p>

</div>
</div>
<a id="a31df80a6f5724aa0021e9458c6a18a1a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a31df80a6f5724aa0021e9458c6a18a1a">&#9670;&nbsp;</a></span>size</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcugl_1_1_size.html">Size</a> cugl::Rect::size</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>The width and height of the rect. <br  />
 </p>

</div>
</div>
<a id="ae537d1d3f77421755121be069e1d84c0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae537d1d3f77421755121be069e1d84c0">&#9670;&nbsp;</a></span>UNIT</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classcugl_1_1_rect.html">Rect</a> cugl::Rect::UNIT</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>The unit square. </p>

</div>
</div>
<a id="ab9028106203488aff53e51f432d10c53"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab9028106203488aff53e51f432d10c53">&#9670;&nbsp;</a></span>ZERO</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classcugl_1_1_rect.html">Rect</a> cugl::Rect::ZERO</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>The empty <a class="el" href="classcugl_1_1_rect.html">Rect</a>. </p>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>include/cugl/math/<a class="el" href="_c_u_rect_8h_source.html">CURect.h</a></li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.1
</small></address>
</body>
</html>
