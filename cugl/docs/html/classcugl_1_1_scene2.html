<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.9.1"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>CUGL 2.0: cugl::Scene2 Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">CUGL 2.0
   </div>
   <div id="projectbrief">Cornell University Game Library</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.1 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search','.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespacecugl.html">cugl</a></li><li class="navelem"><a class="el" href="classcugl_1_1_scene2.html">Scene2</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-static-methods">Static Public Member Functions</a> &#124;
<a href="#pro-attribs">Protected Attributes</a> &#124;
<a href="#friends">Friends</a> &#124;
<a href="classcugl_1_1_scene2-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">cugl::Scene2 Class Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p><code>#include &lt;<a class="el" href="_c_u_scene2_8h_source.html">CUScene2.h</a>&gt;</code></p>
<div class="dynheader">
Inheritance diagram for cugl::Scene2:</div>
<div class="dyncontent">
 <div class="center">
  <img src="classcugl_1_1_scene2.png" usemap="#cugl::Scene2_map" alt=""/>
  <map id="cugl::Scene2_map" name="cugl::Scene2_map">
<area href="classcugl_1_1_scene2_texture.html" alt="cugl::Scene2Texture" shape="rect" coords="0,56,127,80"/>
  </map>
</div></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a2f3e26b2e1524ce2adcad5a438a70e06"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1_scene2.html#a2f3e26b2e1524ce2adcad5a438a70e06">Scene2</a> ()</td></tr>
<tr class="separator:a2f3e26b2e1524ce2adcad5a438a70e06"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aff034ac0d0d50ed6a3e119de55c8ba1e"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1_scene2.html#aff034ac0d0d50ed6a3e119de55c8ba1e">~Scene2</a> ()</td></tr>
<tr class="separator:aff034ac0d0d50ed6a3e119de55c8ba1e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad284d2230ab8f6505a63f8c2ef67430e"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1_scene2.html#ad284d2230ab8f6505a63f8c2ef67430e">dispose</a> ()</td></tr>
<tr class="separator:ad284d2230ab8f6505a63f8c2ef67430e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:add0b8628986cba8ffc6bda8383495e9e"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1_scene2.html#add0b8628986cba8ffc6bda8383495e9e">init</a> (const <a class="el" href="classcugl_1_1_size.html">Size</a> size)</td></tr>
<tr class="separator:add0b8628986cba8ffc6bda8383495e9e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6cd4d844884924681be3dd09a3a81602"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1_scene2.html#a6cd4d844884924681be3dd09a3a81602">init</a> (float width, float height)</td></tr>
<tr class="separator:a6cd4d844884924681be3dd09a3a81602"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a877a018e1bf54e490fd4b51d3f0d50d4"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1_scene2.html#a877a018e1bf54e490fd4b51d3f0d50d4">init</a> (const <a class="el" href="classcugl_1_1_rect.html">Rect</a> rect)</td></tr>
<tr class="separator:a877a018e1bf54e490fd4b51d3f0d50d4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a19bb797c0f28b47127aebbe22aab9ffb"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1_scene2.html#a19bb797c0f28b47127aebbe22aab9ffb">init</a> (const <a class="el" href="classcugl_1_1_vec2.html">Vec2</a> origin, const <a class="el" href="classcugl_1_1_size.html">Size</a> size)</td></tr>
<tr class="separator:a19bb797c0f28b47127aebbe22aab9ffb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a01dfdd6f3fa09fed3400c34d5b53ffd9"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1_scene2.html#a01dfdd6f3fa09fed3400c34d5b53ffd9">init</a> (float x, float y, float width, float height)</td></tr>
<tr class="separator:a01dfdd6f3fa09fed3400c34d5b53ffd9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a98de99622cb4fed50a5e659032cf99fa"><td class="memItemLeft" align="right" valign="top">const std::string &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1_scene2.html#a98de99622cb4fed50a5e659032cf99fa">getName</a> () const</td></tr>
<tr class="separator:a98de99622cb4fed50a5e659032cf99fa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a485f08832836b2f989161627b525f32e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1_scene2.html#a485f08832836b2f989161627b525f32e">setName</a> (const std::string &amp;name)</td></tr>
<tr class="separator:a485f08832836b2f989161627b525f32e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8a99d54a29bd3621abbb90f97cd0d646"><td class="memItemLeft" align="right" valign="top">std::shared_ptr&lt; <a class="el" href="classcugl_1_1_camera.html">Camera</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1_scene2.html#a8a99d54a29bd3621abbb90f97cd0d646">getCamera</a> ()</td></tr>
<tr class="separator:a8a99d54a29bd3621abbb90f97cd0d646"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5e7886b497a05bcdffaf8d0b15a07a56"><td class="memItemLeft" align="right" valign="top">const std::shared_ptr&lt; <a class="el" href="classcugl_1_1_camera.html">Camera</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1_scene2.html#a5e7886b497a05bcdffaf8d0b15a07a56">getCamera</a> () const</td></tr>
<tr class="separator:a5e7886b497a05bcdffaf8d0b15a07a56"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1021ef348f028bf65e9c2049a0c4e26a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classcugl_1_1_color4.html">Color4</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1_scene2.html#a1021ef348f028bf65e9c2049a0c4e26a">getColor</a> ()</td></tr>
<tr class="separator:a1021ef348f028bf65e9c2049a0c4e26a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5bd96c871c155e47ddbf60b07faf73e9"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1_scene2.html#a5bd96c871c155e47ddbf60b07faf73e9">setColor</a> (<a class="el" href="classcugl_1_1_color4.html">Color4</a> color)</td></tr>
<tr class="separator:a5bd96c871c155e47ddbf60b07faf73e9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad64115f12bac3f2d4b2a3459555362ed"><td class="memItemLeft" align="right" valign="top">virtual std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1_scene2.html#ad64115f12bac3f2d4b2a3459555362ed">toString</a> (bool verbose=false) const</td></tr>
<tr class="separator:ad64115f12bac3f2d4b2a3459555362ed"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a146a47bc0011e0eec147b3a38256b6bc"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1_scene2.html#a146a47bc0011e0eec147b3a38256b6bc">operator std::string</a> () const</td></tr>
<tr class="separator:a146a47bc0011e0eec147b3a38256b6bc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6fed2dabcea7c43b184558a2b2a660b5"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classcugl_1_1_size.html">Size</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1_scene2.html#a6fed2dabcea7c43b184558a2b2a660b5">getSize</a> () const</td></tr>
<tr class="separator:a6fed2dabcea7c43b184558a2b2a660b5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7047647d54fc4baf5ef658d9e3bc951a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1_scene2.html#a7047647d54fc4baf5ef658d9e3bc951a">setSize</a> (const <a class="el" href="classcugl_1_1_size.html">Size</a> size)</td></tr>
<tr class="separator:a7047647d54fc4baf5ef658d9e3bc951a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0b7d821c69fc5af2a92bf525a226a974"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1_scene2.html#a0b7d821c69fc5af2a92bf525a226a974">setSize</a> (float width, float height)</td></tr>
<tr class="separator:a0b7d821c69fc5af2a92bf525a226a974"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acb859cec6e45d2ab52792cccdda493ad"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1_scene2.html#acb859cec6e45d2ab52792cccdda493ad">setWidth</a> (float width)</td></tr>
<tr class="separator:acb859cec6e45d2ab52792cccdda493ad"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7fff235fe3813031c082e6633f9b1132"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1_scene2.html#a7fff235fe3813031c082e6633f9b1132">setHeight</a> (float height)</td></tr>
<tr class="separator:a7fff235fe3813031c082e6633f9b1132"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a40386ee443042d53a0d387f59c3aebce"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classcugl_1_1_rect.html">Rect</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1_scene2.html#a40386ee443042d53a0d387f59c3aebce">getBounds</a> () const</td></tr>
<tr class="separator:a40386ee443042d53a0d387f59c3aebce"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a05e487c77271b5a8cb31902f2edcf62b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1_scene2.html#a05e487c77271b5a8cb31902f2edcf62b">setBounds</a> (const <a class="el" href="classcugl_1_1_rect.html">Rect</a> rect)</td></tr>
<tr class="separator:a05e487c77271b5a8cb31902f2edcf62b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad998bb703cc04f0de1ba106d178b3e10"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1_scene2.html#ad998bb703cc04f0de1ba106d178b3e10">setBounds</a> (const <a class="el" href="classcugl_1_1_vec2.html">Vec2</a> origin, const <a class="el" href="classcugl_1_1_size.html">Size</a> size)</td></tr>
<tr class="separator:ad998bb703cc04f0de1ba106d178b3e10"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a715c3c0965351f5ad7f3c7ac6916751b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1_scene2.html#a715c3c0965351f5ad7f3c7ac6916751b">setBounds</a> (float x, float y, float width, float height)</td></tr>
<tr class="separator:a715c3c0965351f5ad7f3c7ac6916751b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a420e683310f071ed26a17e1c57e121c5"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1_scene2.html#a420e683310f071ed26a17e1c57e121c5">setOffset</a> (const <a class="el" href="classcugl_1_1_vec2.html">Vec2</a> origin)</td></tr>
<tr class="separator:a420e683310f071ed26a17e1c57e121c5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acd13274a7c9ccccdb274e4b5acb27c66"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classcugl_1_1_vec3.html">Vec3</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1_scene2.html#acd13274a7c9ccccdb274e4b5acb27c66">screenToWorldCoords</a> (const <a class="el" href="classcugl_1_1_vec2.html">Vec2</a> screenCoords) const</td></tr>
<tr class="separator:acd13274a7c9ccccdb274e4b5acb27c66"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a62a3f1d9c9dbcc2a276c234b4b30b502"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classcugl_1_1_vec2.html">Vec2</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1_scene2.html#a62a3f1d9c9dbcc2a276c234b4b30b502">worldToScreenCoords</a> (const <a class="el" href="classcugl_1_1_vec3.html">Vec3</a> worldCoords) const</td></tr>
<tr class="separator:a62a3f1d9c9dbcc2a276c234b4b30b502"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a180919f109805cd95f134b49f7fb47f5"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1_scene2.html#a180919f109805cd95f134b49f7fb47f5">getChildCount</a> () const</td></tr>
<tr class="separator:a180919f109805cd95f134b49f7fb47f5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9dc6a9a62be9b158b62499d81c994662"><td class="memItemLeft" align="right" valign="top">std::shared_ptr&lt; <a class="el" href="classcugl_1_1scene2_1_1_scene_node.html">scene2::SceneNode</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1_scene2.html#a9dc6a9a62be9b158b62499d81c994662">getChild</a> (unsigned int pos)</td></tr>
<tr class="separator:a9dc6a9a62be9b158b62499d81c994662"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a05ccd41554e379bd486e716a3396ef5c"><td class="memItemLeft" align="right" valign="top">const std::shared_ptr&lt; <a class="el" href="classcugl_1_1scene2_1_1_scene_node.html">scene2::SceneNode</a> &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1_scene2.html#a05ccd41554e379bd486e716a3396ef5c">getChild</a> (unsigned int pos) const</td></tr>
<tr class="separator:a05ccd41554e379bd486e716a3396ef5c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a22a4d34a355ba391a9280b56d59a750d"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a22a4d34a355ba391a9280b56d59a750d"><td class="memTemplItemLeft" align="right" valign="top">std::shared_ptr&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classcugl_1_1_scene2.html#a22a4d34a355ba391a9280b56d59a750d">getChild</a> (unsigned int pos) const</td></tr>
<tr class="separator:a22a4d34a355ba391a9280b56d59a750d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9b95db447c6fa24c2e53cfcc16e37c50"><td class="memItemLeft" align="right" valign="top">std::shared_ptr&lt; <a class="el" href="classcugl_1_1scene2_1_1_scene_node.html">scene2::SceneNode</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1_scene2.html#a9b95db447c6fa24c2e53cfcc16e37c50">getChildByTag</a> (unsigned int tag) const</td></tr>
<tr class="separator:a9b95db447c6fa24c2e53cfcc16e37c50"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aabf53569fb36368c61fe3f77f702d1b6"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:aabf53569fb36368c61fe3f77f702d1b6"><td class="memTemplItemLeft" align="right" valign="top">std::shared_ptr&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classcugl_1_1_scene2.html#aabf53569fb36368c61fe3f77f702d1b6">getChildByTag</a> (unsigned int tag) const</td></tr>
<tr class="separator:aabf53569fb36368c61fe3f77f702d1b6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af5066e9623bdc3c5e15d540912ec009d"><td class="memItemLeft" align="right" valign="top">std::shared_ptr&lt; <a class="el" href="classcugl_1_1scene2_1_1_scene_node.html">scene2::SceneNode</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1_scene2.html#af5066e9623bdc3c5e15d540912ec009d">getChildByName</a> (const std::string name) const</td></tr>
<tr class="separator:af5066e9623bdc3c5e15d540912ec009d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab4b2a5ef65ebe6699b783b053d742db4"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ab4b2a5ef65ebe6699b783b053d742db4"><td class="memTemplItemLeft" align="right" valign="top">std::shared_ptr&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classcugl_1_1_scene2.html#ab4b2a5ef65ebe6699b783b053d742db4">getChildByName</a> (const std::string name) const</td></tr>
<tr class="separator:ab4b2a5ef65ebe6699b783b053d742db4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1587c2af2107f24a5c63fd9fa3f8a71f"><td class="memItemLeft" align="right" valign="top">std::vector&lt; std::shared_ptr&lt; <a class="el" href="classcugl_1_1scene2_1_1_scene_node.html">scene2::SceneNode</a> &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1_scene2.html#a1587c2af2107f24a5c63fd9fa3f8a71f">getChildren</a> ()</td></tr>
<tr class="separator:a1587c2af2107f24a5c63fd9fa3f8a71f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeea0e15f504ac1aa8deb20637b4231fe"><td class="memItemLeft" align="right" valign="top">const std::vector&lt; std::shared_ptr&lt; <a class="el" href="classcugl_1_1scene2_1_1_scene_node.html">scene2::SceneNode</a> &gt; &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1_scene2.html#aeea0e15f504ac1aa8deb20637b4231fe">getChildren</a> () const</td></tr>
<tr class="separator:aeea0e15f504ac1aa8deb20637b4231fe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afbe7ff2e598cf53f8673ee48095787a3"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1_scene2.html#afbe7ff2e598cf53f8673ee48095787a3">addChild</a> (std::shared_ptr&lt; <a class="el" href="classcugl_1_1scene2_1_1_scene_node.html">scene2::SceneNode</a> &gt; child)</td></tr>
<tr class="separator:afbe7ff2e598cf53f8673ee48095787a3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aebee2f2c59981f1bebf83362b3cb6346"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1_scene2.html#aebee2f2c59981f1bebf83362b3cb6346">addChild</a> (const std::shared_ptr&lt; <a class="el" href="classcugl_1_1scene2_1_1_scene_node.html">scene2::SceneNode</a> &gt; &amp;child, int zval)</td></tr>
<tr class="separator:aebee2f2c59981f1bebf83362b3cb6346"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae90f74af566bc200dfdab22dd93a9a40"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1_scene2.html#ae90f74af566bc200dfdab22dd93a9a40">addChildWithTag</a> (const std::shared_ptr&lt; <a class="el" href="classcugl_1_1scene2_1_1_scene_node.html">scene2::SceneNode</a> &gt; &amp;child, unsigned int tag)</td></tr>
<tr class="separator:ae90f74af566bc200dfdab22dd93a9a40"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a213094c639de38cb20ef10f1facb8175"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1_scene2.html#a213094c639de38cb20ef10f1facb8175">addChildWithTag</a> (const std::shared_ptr&lt; <a class="el" href="classcugl_1_1scene2_1_1_scene_node.html">scene2::SceneNode</a> &gt; &amp;child, unsigned int tag, int zval)</td></tr>
<tr class="separator:a213094c639de38cb20ef10f1facb8175"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acd41edb9c0f157d4bae2b814534339e6"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1_scene2.html#acd41edb9c0f157d4bae2b814534339e6">addChildWithName</a> (const std::shared_ptr&lt; <a class="el" href="classcugl_1_1scene2_1_1_scene_node.html">scene2::SceneNode</a> &gt; &amp;child, const std::string name)</td></tr>
<tr class="separator:acd41edb9c0f157d4bae2b814534339e6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a75eb334607d01433fe5b4401a83af62a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1_scene2.html#a75eb334607d01433fe5b4401a83af62a">addChildWithName</a> (const std::shared_ptr&lt; <a class="el" href="classcugl_1_1scene2_1_1_scene_node.html">scene2::SceneNode</a> &gt; &amp;child, const std::string name, int zval)</td></tr>
<tr class="separator:a75eb334607d01433fe5b4401a83af62a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae91fa0b6f56074612b603b43c16a3759"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1_scene2.html#ae91fa0b6f56074612b603b43c16a3759">swapChild</a> (const std::shared_ptr&lt; <a class="el" href="classcugl_1_1scene2_1_1_scene_node.html">scene2::SceneNode</a> &gt; &amp;child1, const std::shared_ptr&lt; <a class="el" href="classcugl_1_1scene2_1_1_scene_node.html">scene2::SceneNode</a> &gt; &amp;child2, bool inherit=false)</td></tr>
<tr class="separator:ae91fa0b6f56074612b603b43c16a3759"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a723b1df1693bf6ac24caa6ef0f392a7c"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1_scene2.html#a723b1df1693bf6ac24caa6ef0f392a7c">removeChild</a> (unsigned int pos)</td></tr>
<tr class="separator:a723b1df1693bf6ac24caa6ef0f392a7c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a71868d8867435e1fdeeb0cf3571183f2"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1_scene2.html#a71868d8867435e1fdeeb0cf3571183f2">removeChild</a> (const std::shared_ptr&lt; <a class="el" href="classcugl_1_1scene2_1_1_scene_node.html">scene2::SceneNode</a> &gt; &amp;child)</td></tr>
<tr class="separator:a71868d8867435e1fdeeb0cf3571183f2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adad59ad487100cd5860db647f4df48a9"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1_scene2.html#adad59ad487100cd5860db647f4df48a9">removeChildByTag</a> (unsigned int tag)</td></tr>
<tr class="separator:adad59ad487100cd5860db647f4df48a9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae9adab1b5d6ac92ee136b16eb9607dfe"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1_scene2.html#ae9adab1b5d6ac92ee136b16eb9607dfe">removeChildByName</a> (const std::string name)</td></tr>
<tr class="separator:ae9adab1b5d6ac92ee136b16eb9607dfe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8f4a8ae1f0edf0cc9f37cf5dcc5e9e5e"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1_scene2.html#a8f4a8ae1f0edf0cc9f37cf5dcc5e9e5e">removeAllChildren</a> ()</td></tr>
<tr class="separator:a8f4a8ae1f0edf0cc9f37cf5dcc5e9e5e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8b097594743f64d91ed1e91d503a910a"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1_scene2.html#a8b097594743f64d91ed1e91d503a910a">isZAutoSort</a> ()</td></tr>
<tr class="separator:a8b097594743f64d91ed1e91d503a910a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a449125b339eb01438927d19cafbe2ebb"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1_scene2.html#a449125b339eb01438927d19cafbe2ebb">setZAutoSort</a> (bool value)</td></tr>
<tr class="separator:a449125b339eb01438927d19cafbe2ebb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae74dc2dd307a286188d842f6019baf4e"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1_scene2.html#ae74dc2dd307a286188d842f6019baf4e">isZDirty</a> () const</td></tr>
<tr class="separator:ae74dc2dd307a286188d842f6019baf4e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac47fd35c42b4fa2cad384251ecc012a1"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1_scene2.html#ac47fd35c42b4fa2cad384251ecc012a1">sortZOrder</a> ()</td></tr>
<tr class="separator:ac47fd35c42b4fa2cad384251ecc012a1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a43ccc21633c20925d51a8a727898da9b"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1_scene2.html#a43ccc21633c20925d51a8a727898da9b">isActive</a> () const</td></tr>
<tr class="separator:a43ccc21633c20925d51a8a727898da9b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abe3b22f2d391d543aa1be6b53234daab"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1_scene2.html#abe3b22f2d391d543aa1be6b53234daab">setActive</a> (bool value)</td></tr>
<tr class="separator:abe3b22f2d391d543aa1be6b53234daab"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a685ca119e276d566376f8757d6c991d7"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1_scene2.html#a685ca119e276d566376f8757d6c991d7">update</a> (float timestep)</td></tr>
<tr class="separator:a685ca119e276d566376f8757d6c991d7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adedbfc7a55d4eca78ae1c59b0cdd5296"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1_scene2.html#adedbfc7a55d4eca78ae1c59b0cdd5296">reset</a> ()</td></tr>
<tr class="separator:adedbfc7a55d4eca78ae1c59b0cdd5296"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adecdb73ddcdf7be9dc617f1c2f25736c"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1_scene2.html#adecdb73ddcdf7be9dc617f1c2f25736c">render</a> (const std::shared_ptr&lt; <a class="el" href="classcugl_1_1_sprite_batch.html">SpriteBatch</a> &gt; &amp;batch)</td></tr>
<tr class="separator:adecdb73ddcdf7be9dc617f1c2f25736c"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-static-methods"></a>
Static Public Member Functions</h2></td></tr>
<tr class="memitem:a35110b8f311ec4682ec4d77ec685bdea"><td class="memItemLeft" align="right" valign="top">static std::shared_ptr&lt; <a class="el" href="classcugl_1_1_scene2.html">Scene2</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1_scene2.html#a35110b8f311ec4682ec4d77ec685bdea">alloc</a> (const <a class="el" href="classcugl_1_1_size.html">Size</a> size)</td></tr>
<tr class="separator:a35110b8f311ec4682ec4d77ec685bdea"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:addea666bc2f469670a7d5d59b9992d14"><td class="memItemLeft" align="right" valign="top">static std::shared_ptr&lt; <a class="el" href="classcugl_1_1_scene2.html">Scene2</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1_scene2.html#addea666bc2f469670a7d5d59b9992d14">alloc</a> (float width, float height)</td></tr>
<tr class="separator:addea666bc2f469670a7d5d59b9992d14"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a29b8a871f9baddbbcf471ec8ef21eb1f"><td class="memItemLeft" align="right" valign="top">static std::shared_ptr&lt; <a class="el" href="classcugl_1_1_scene2.html">Scene2</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1_scene2.html#a29b8a871f9baddbbcf471ec8ef21eb1f">alloc</a> (const <a class="el" href="classcugl_1_1_rect.html">Rect</a> rect)</td></tr>
<tr class="separator:a29b8a871f9baddbbcf471ec8ef21eb1f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5ba897b40cdb62928d401dce1bc141a1"><td class="memItemLeft" align="right" valign="top">static std::shared_ptr&lt; <a class="el" href="classcugl_1_1_scene2.html">Scene2</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1_scene2.html#a5ba897b40cdb62928d401dce1bc141a1">alloc</a> (const <a class="el" href="classcugl_1_1_vec2.html">Vec2</a> origin, const <a class="el" href="classcugl_1_1_size.html">Size</a> size)</td></tr>
<tr class="separator:a5ba897b40cdb62928d401dce1bc141a1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac592bed21c77716bd2997d0a8be6780d"><td class="memItemLeft" align="right" valign="top">static std::shared_ptr&lt; <a class="el" href="classcugl_1_1_scene2.html">Scene2</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1_scene2.html#ac592bed21c77716bd2997d0a8be6780d">alloc</a> (float x, float y, float width, float height)</td></tr>
<tr class="separator:ac592bed21c77716bd2997d0a8be6780d"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pro-attribs"></a>
Protected Attributes</h2></td></tr>
<tr class="memitem:a5cfbff4429040319e5635536a7730017"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1_scene2.html#a5cfbff4429040319e5635536a7730017">_name</a></td></tr>
<tr class="separator:a5cfbff4429040319e5635536a7730017"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afb4d7b1eb5f70a162b3fdbcdd1c7fc4e"><td class="memItemLeft" align="right" valign="top">std::shared_ptr&lt; <a class="el" href="classcugl_1_1_orthographic_camera.html">OrthographicCamera</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1_scene2.html#afb4d7b1eb5f70a162b3fdbcdd1c7fc4e">_camera</a></td></tr>
<tr class="separator:afb4d7b1eb5f70a162b3fdbcdd1c7fc4e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab225bcb5ef394b7dc8c5814bcd1f03d4"><td class="memItemLeft" align="right" valign="top">std::vector&lt; std::shared_ptr&lt; <a class="el" href="classcugl_1_1scene2_1_1_scene_node.html">scene2::SceneNode</a> &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1_scene2.html#ab225bcb5ef394b7dc8c5814bcd1f03d4">_children</a></td></tr>
<tr class="separator:ab225bcb5ef394b7dc8c5814bcd1f03d4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abef303013c630c349a98dd67edd4f93c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classcugl_1_1_color4.html">Color4</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1_scene2.html#abef303013c630c349a98dd67edd4f93c">_color</a></td></tr>
<tr class="separator:abef303013c630c349a98dd67edd4f93c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6619e7b99ae38ec14925aa4ba6b3334c"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1_scene2.html#a6619e7b99ae38ec14925aa4ba6b3334c">_zDirty</a></td></tr>
<tr class="separator:a6619e7b99ae38ec14925aa4ba6b3334c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae68e900ab42a1e4db6588fe8f83f29b0"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1_scene2.html#ae68e900ab42a1e4db6588fe8f83f29b0">_zSort</a></td></tr>
<tr class="separator:ae68e900ab42a1e4db6588fe8f83f29b0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1e046894be3fffc7f975c7eec1db8e56"><td class="memItemLeft" align="right" valign="top">GLenum&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1_scene2.html#a1e046894be3fffc7f975c7eec1db8e56">_blendEquation</a></td></tr>
<tr class="separator:a1e046894be3fffc7f975c7eec1db8e56"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a943b869ecdbad4988a6973c7e959bfda"><td class="memItemLeft" align="right" valign="top">GLenum&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1_scene2.html#a943b869ecdbad4988a6973c7e959bfda">_srcFactor</a></td></tr>
<tr class="separator:a943b869ecdbad4988a6973c7e959bfda"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a13d48aae17238795cd8e0e064e627f6d"><td class="memItemLeft" align="right" valign="top">GLenum&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1_scene2.html#a13d48aae17238795cd8e0e064e627f6d">_dstFactor</a></td></tr>
<tr class="separator:a13d48aae17238795cd8e0e064e627f6d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afa830b449e840bde845e7e8d83a842cb"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcugl_1_1_scene2.html#afa830b449e840bde845e7e8d83a842cb">_active</a></td></tr>
<tr class="separator:afa830b449e840bde845e7e8d83a842cb"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="friends"></a>
Friends</h2></td></tr>
<tr class="memitem:aa4cc9f3adf8b315b15537400743ca541"><td class="memItemLeft" align="right" valign="top"><a id="aa4cc9f3adf8b315b15537400743ca541"></a>
class&#160;</td><td class="memItemRight" valign="bottom"><b>scene2::SceneNode</b></td></tr>
<tr class="separator:aa4cc9f3adf8b315b15537400743ca541"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>This class provides the root node of a two-dimensional scene graph.</p>
<p>The <a class="el" href="classcugl_1_1_scene2.html">Scene2</a> class is very similar to <a class="el" href="classcugl_1_1scene2_1_1_scene_node.html">scene2::SceneNode</a> and shares many methods in common. The major differences are that it has no parent and it has no position (so it cannot be transformed). Instead, the <a class="el" href="classcugl_1_1_scene2.html">Scene2</a> is defined by an attached <a class="el" href="classcugl_1_1_orthographic_camera.html">OrthographicCamera</a>.</p>
<p>Rendering happens by traversing the the scene graph using an "Pre-Order" tree traversal algorithm ( <a href="https://en.wikipedia.org/wiki/Tree_traversal#Pre-order">https://en.wikipedia.org/wiki/Tree_traversal#Pre-order</a> ). That means that parents are always draw before (and behind children). The children of each sub tree are ordered sequentially.</p>
<p>Scenes do support optional z-ordering. This is not a true depth value, as depth filtering is incompatible with alpha compositing. However, it does provide a way to dynamically reorder how siblings are composed. </p>
</div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="a2f3e26b2e1524ce2adcad5a438a70e06"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2f3e26b2e1524ce2adcad5a438a70e06">&#9670;&nbsp;</a></span>Scene2()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">cugl::Scene2::Scene2 </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Creates a new degenerate <a class="el" href="classcugl_1_1_scene2.html">Scene2</a> on the stack.</p>
<p>The scene has no camera and must be initialized.</p>
<p>NEVER USE A CONSTRUCTOR WITH NEW. If you want to allocate an object on the heap, use one of the static constructors instead. </p>

</div>
</div>
<a id="aff034ac0d0d50ed6a3e119de55c8ba1e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aff034ac0d0d50ed6a3e119de55c8ba1e">&#9670;&nbsp;</a></span>~Scene2()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">cugl::Scene2::~Scene2 </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Deletes this scene, disposing all resources </p>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="aebee2f2c59981f1bebf83362b3cb6346"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aebee2f2c59981f1bebf83362b3cb6346">&#9670;&nbsp;</a></span>addChild() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void cugl::Scene2::addChild </td>
          <td>(</td>
          <td class="paramtype">const std::shared_ptr&lt; <a class="el" href="classcugl_1_1scene2_1_1_scene_node.html">scene2::SceneNode</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>child</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>zval</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Adds a child to this scene with the given z-order.</p>
<p>Children are not necessarily enumerated in the order that they are added. For example, they may be resorted by their z-order. Hence you should generally attempt to retrieve a child by tag or by name instead.</p>
<p>The z-order overrides what z-value was previously in the child node.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">child</td><td>A child node. </td></tr>
    <tr><td class="paramname">zval</td><td>The (new) child z-order. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="afbe7ff2e598cf53f8673ee48095787a3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afbe7ff2e598cf53f8673ee48095787a3">&#9670;&nbsp;</a></span>addChild() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void cugl::Scene2::addChild </td>
          <td>(</td>
          <td class="paramtype">std::shared_ptr&lt; <a class="el" href="classcugl_1_1scene2_1_1_scene_node.html">scene2::SceneNode</a> &gt;&#160;</td>
          <td class="paramname"><em>child</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Adds a child to this scene.</p>
<p>Children are not necessarily enumerated in the order that they are added. For example, they may be resorted by their z-order. Hence you should generally attempt to retrieve a child by tag or by name instead.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">child</td><td>A child node. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="acd41edb9c0f157d4bae2b814534339e6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acd41edb9c0f157d4bae2b814534339e6">&#9670;&nbsp;</a></span>addChildWithName() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void cugl::Scene2::addChildWithName </td>
          <td>(</td>
          <td class="paramtype">const std::shared_ptr&lt; <a class="el" href="classcugl_1_1scene2_1_1_scene_node.html">scene2::SceneNode</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>child</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string&#160;</td>
          <td class="paramname"><em>name</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Adds a child to this scene with the given name.</p>
<p>Children are not necessarily enumerated in the order that they are added. For example, they may be resorted by their z-order. Hence you should generally attempt to retrieve a child by tag or by name instead.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">child</td><td>A child node. </td></tr>
    <tr><td class="paramname">name</td><td>A string to identify the node. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a75eb334607d01433fe5b4401a83af62a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a75eb334607d01433fe5b4401a83af62a">&#9670;&nbsp;</a></span>addChildWithName() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void cugl::Scene2::addChildWithName </td>
          <td>(</td>
          <td class="paramtype">const std::shared_ptr&lt; <a class="el" href="classcugl_1_1scene2_1_1_scene_node.html">scene2::SceneNode</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>child</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>zval</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Adds a child to this scene with the given name and z-order</p>
<p>Children are not necessarily enumerated in the order that they are added. For example, they may be resorted by their z-order. Hence you should generally attempt to retrieve a child by tag or by name instead.</p>
<p>The z-order overrides what z-value was previously in the child node.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">child</td><td>A child node. </td></tr>
    <tr><td class="paramname">name</td><td>A string to identify the node. </td></tr>
    <tr><td class="paramname">zval</td><td>The (new) child z-order. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ae90f74af566bc200dfdab22dd93a9a40"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae90f74af566bc200dfdab22dd93a9a40">&#9670;&nbsp;</a></span>addChildWithTag() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void cugl::Scene2::addChildWithTag </td>
          <td>(</td>
          <td class="paramtype">const std::shared_ptr&lt; <a class="el" href="classcugl_1_1scene2_1_1_scene_node.html">scene2::SceneNode</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>child</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>tag</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Adds a child to this scene with the given tag.</p>
<p>Children are not necessarily enumerated in the order that they are added. For example, they may be resorted by their z-order. Hence you should generally attempt to retrieve a child by tag or by name instead.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">child</td><td>A child node. </td></tr>
    <tr><td class="paramname">tag</td><td>An integer to identify the node easily. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a213094c639de38cb20ef10f1facb8175"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a213094c639de38cb20ef10f1facb8175">&#9670;&nbsp;</a></span>addChildWithTag() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void cugl::Scene2::addChildWithTag </td>
          <td>(</td>
          <td class="paramtype">const std::shared_ptr&lt; <a class="el" href="classcugl_1_1scene2_1_1_scene_node.html">scene2::SceneNode</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>child</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>tag</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>zval</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Adds a child to this scene with the given tag and z-order</p>
<p>Children are not necessarily enumerated in the order that they are added. For example, they may be resorted by their z-order. Hence you should generally attempt to retrieve a child by tag or by name instead.</p>
<p>The z-order overrides what z-value was previously in the child node.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">child</td><td>A child node. </td></tr>
    <tr><td class="paramname">tag</td><td>An integer to identify the node easily. </td></tr>
    <tr><td class="paramname">zval</td><td>The (new) child z-order. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a29b8a871f9baddbbcf471ec8ef21eb1f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a29b8a871f9baddbbcf471ec8ef21eb1f">&#9670;&nbsp;</a></span>alloc() <span class="overload">[1/5]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static std::shared_ptr&lt;<a class="el" href="classcugl_1_1_scene2.html">Scene2</a>&gt; cugl::Scene2::alloc </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classcugl_1_1_rect.html">Rect</a>&#160;</td>
          <td class="paramname"><em>rect</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns a newly allocated <a class="el" href="classcugl_1_1_scene2.html">Scene2</a> for the given viewport.</p>
<p>Offseting the viewport origin has little affect on the Scene in general. It only affects the coordinate conversion methods <a class="el" href="classcugl_1_1_camera.html#a0c0eca401bf088d6e756eb9e1c7e9d76">Camera#project()</a> and <a class="el" href="classcugl_1_1_camera.html#a67ec4ef4003e6f6b11819d6f272f3d1f">Camera#unproject()</a>. It is supposed to represent the offset</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">rect</td><td>The viewport bounding box</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a newly allocated Scene for the given viewport. </dd></dl>

</div>
</div>
<a id="a35110b8f311ec4682ec4d77ec685bdea"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a35110b8f311ec4682ec4d77ec685bdea">&#9670;&nbsp;</a></span>alloc() <span class="overload">[2/5]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static std::shared_ptr&lt;<a class="el" href="classcugl_1_1_scene2.html">Scene2</a>&gt; cugl::Scene2::alloc </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classcugl_1_1_size.html">Size</a>&#160;</td>
          <td class="paramname"><em>size</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns a newly allocated <a class="el" href="classcugl_1_1_scene2.html">Scene2</a> for the given viewport.</p>
<p>The viewport origin is assumed to be (0,0).</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">size</td><td>The viewport size</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a newly allocated Scene for the given viewport. </dd></dl>

</div>
</div>
<a id="a5ba897b40cdb62928d401dce1bc141a1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5ba897b40cdb62928d401dce1bc141a1">&#9670;&nbsp;</a></span>alloc() <span class="overload">[3/5]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static std::shared_ptr&lt;<a class="el" href="classcugl_1_1_scene2.html">Scene2</a>&gt; cugl::Scene2::alloc </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classcugl_1_1_vec2.html">Vec2</a>&#160;</td>
          <td class="paramname"><em>origin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classcugl_1_1_size.html">Size</a>&#160;</td>
          <td class="paramname"><em>size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns a newly allocated <a class="el" href="classcugl_1_1_scene2.html">Scene2</a> for the given viewport.</p>
<p>Offseting the viewport origin has little affect on the Scene in general. It only affects the coordinate conversion methods <a class="el" href="classcugl_1_1_camera.html#a0c0eca401bf088d6e756eb9e1c7e9d76">Camera#project()</a> and <a class="el" href="classcugl_1_1_camera.html#a67ec4ef4003e6f6b11819d6f272f3d1f">Camera#unproject()</a>. It is supposed to represent the offset</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">origin</td><td>The viewport offset </td></tr>
    <tr><td class="paramname">size</td><td>The viewport size</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a newly allocated Scene for the given viewport. </dd></dl>

</div>
</div>
<a id="addea666bc2f469670a7d5d59b9992d14"></a>
<h2 class="memtitle"><span class="permalink"><a href="#addea666bc2f469670a7d5d59b9992d14">&#9670;&nbsp;</a></span>alloc() <span class="overload">[4/5]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static std::shared_ptr&lt;<a class="el" href="classcugl_1_1_scene2.html">Scene2</a>&gt; cugl::Scene2::alloc </td>
          <td>(</td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>width</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>height</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns a newly allocated <a class="el" href="classcugl_1_1_scene2.html">Scene2</a> for the given viewport.</p>
<p>The viewport origin is assumed to be (0,0).</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">width</td><td>The viewport width </td></tr>
    <tr><td class="paramname">height</td><td>The viewport height</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a newly allocated Scene for the given viewport. </dd></dl>

</div>
</div>
<a id="ac592bed21c77716bd2997d0a8be6780d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac592bed21c77716bd2997d0a8be6780d">&#9670;&nbsp;</a></span>alloc() <span class="overload">[5/5]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static std::shared_ptr&lt;<a class="el" href="classcugl_1_1_scene2.html">Scene2</a>&gt; cugl::Scene2::alloc </td>
          <td>(</td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>width</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>height</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns a newly allocated <a class="el" href="classcugl_1_1_scene2.html">Scene2</a> for the given viewport.</p>
<p>Offseting the viewport origin has little affect on the Scene in general. It only affects the coordinate conversion methods <a class="el" href="classcugl_1_1_camera.html#a0c0eca401bf088d6e756eb9e1c7e9d76">Camera#project()</a> and <a class="el" href="classcugl_1_1_camera.html#a67ec4ef4003e6f6b11819d6f272f3d1f">Camera#unproject()</a>. It is supposed to represent the offset</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>The viewport x offset </td></tr>
    <tr><td class="paramname">y</td><td>The viewport y offset </td></tr>
    <tr><td class="paramname">width</td><td>The viewport width </td></tr>
    <tr><td class="paramname">height</td><td>The viewport height</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a newly allocated Scene for the given viewport. </dd></dl>

</div>
</div>
<a id="ad284d2230ab8f6505a63f8c2ef67430e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad284d2230ab8f6505a63f8c2ef67430e">&#9670;&nbsp;</a></span>dispose()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void cugl::Scene2::dispose </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Disposes all of the resources used by this scene.</p>
<p>A disposed <a class="el" href="classcugl_1_1_scene2.html">Scene2</a> can be safely reinitialized. Any children owned by this scene will be released. They will be deleted if no other object owns them. </p>

<p>Reimplemented in <a class="el" href="classcugl_1_1_scene2_texture.html#a28626bda38d0ac12df798686ce719714">cugl::Scene2Texture</a>.</p>

</div>
</div>
<a id="a40386ee443042d53a0d387f59c3aebce"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a40386ee443042d53a0d387f59c3aebce">&#9670;&nbsp;</a></span>getBounds()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classcugl_1_1_rect.html">Rect</a> cugl::Scene2::getBounds </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns the viewport of this <a class="el" href="classcugl_1_1_scene2.html">Scene2</a>.</p>
<dl class="section return"><dt>Returns</dt><dd>the viewport of this <a class="el" href="classcugl_1_1_scene2.html">Scene2</a>. </dd></dl>

</div>
</div>
<a id="a8a99d54a29bd3621abbb90f97cd0d646"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8a99d54a29bd3621abbb90f97cd0d646">&#9670;&nbsp;</a></span>getCamera() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::shared_ptr&lt;<a class="el" href="classcugl_1_1_camera.html">Camera</a>&gt; cugl::Scene2::getCamera </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns the camera for this scene.</p>
<dl class="section return"><dt>Returns</dt><dd>the camera for this scene. </dd></dl>

</div>
</div>
<a id="a5e7886b497a05bcdffaf8d0b15a07a56"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5e7886b497a05bcdffaf8d0b15a07a56">&#9670;&nbsp;</a></span>getCamera() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const std::shared_ptr&lt;<a class="el" href="classcugl_1_1_camera.html">Camera</a>&gt; cugl::Scene2::getCamera </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns the camera for this scene.</p>
<dl class="section return"><dt>Returns</dt><dd>the camera for this scene. </dd></dl>

</div>
</div>
<a id="a9dc6a9a62be9b158b62499d81c994662"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9dc6a9a62be9b158b62499d81c994662">&#9670;&nbsp;</a></span>getChild() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::shared_ptr&lt;<a class="el" href="classcugl_1_1scene2_1_1_scene_node.html">scene2::SceneNode</a>&gt; cugl::Scene2::getChild </td>
          <td>(</td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>pos</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns the child at the given position.</p>
<p>Children are not necessarily enumerated in the order that they are added. For example, they may be resorted by their z-order. Hence you should generally attempt to retrieve a child by tag or by name instead.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pos</td><td>The child position.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the child at the given position. </dd></dl>

</div>
</div>
<a id="a05ccd41554e379bd486e716a3396ef5c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a05ccd41554e379bd486e716a3396ef5c">&#9670;&nbsp;</a></span>getChild() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const std::shared_ptr&lt;<a class="el" href="classcugl_1_1scene2_1_1_scene_node.html">scene2::SceneNode</a>&gt;&amp; cugl::Scene2::getChild </td>
          <td>(</td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>pos</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns the child at the given position.</p>
<p>Children are not necessarily enumerated in the order that they are added. For example, they may be resorted by their z-order. Hence you should generally attempt to retrieve a child by tag or by name instead.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pos</td><td>The child position.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the child at the given position. </dd></dl>

</div>
</div>
<a id="a22a4d34a355ba391a9280b56d59a750d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a22a4d34a355ba391a9280b56d59a750d">&#9670;&nbsp;</a></span>getChild() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::shared_ptr&lt;T&gt; cugl::Scene2::getChild </td>
          <td>(</td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>pos</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns the child at the given position, typecast to a shared T pointer.</p>
<p>This method is provided to simplify the polymorphism of a scene graph. While all children are a subclass of type Node, you may want to access them by their specific subclass. If the child is not an instance of type T (or a subclass), this method returns nullptr.</p>
<p>Children are not necessarily enumerated in the order that they are added. For example, they may be resorted by their z-order. Hence you should generally attempt to retrieve a child by tag or by name instead.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pos</td><td>The child position.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the child at the given position, typecast to a shared T pointer. </dd></dl>

</div>
</div>
<a id="af5066e9623bdc3c5e15d540912ec009d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af5066e9623bdc3c5e15d540912ec009d">&#9670;&nbsp;</a></span>getChildByName() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::shared_ptr&lt;<a class="el" href="classcugl_1_1scene2_1_1_scene_node.html">scene2::SceneNode</a>&gt; cugl::Scene2::getChildByName </td>
          <td>(</td>
          <td class="paramtype">const std::string&#160;</td>
          <td class="paramname"><em>name</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns the (first) child with the given name.</p>
<p>If there is more than one child of the given name, it returns the first one that is found. Children are not necessarily enumerated in the order that they are added. For example, they may be resorted by their z-order. Hence it is very important that names be unique.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">name</td><td>An identifier to find the child node.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the (first) child with the given name. </dd></dl>

</div>
</div>
<a id="ab4b2a5ef65ebe6699b783b053d742db4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab4b2a5ef65ebe6699b783b053d742db4">&#9670;&nbsp;</a></span>getChildByName() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::shared_ptr&lt;T&gt; cugl::Scene2::getChildByName </td>
          <td>(</td>
          <td class="paramtype">const std::string&#160;</td>
          <td class="paramname"><em>name</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns the (first) child with the given name, typecast to a shared T pointer.</p>
<p>This method is provided to simplify the polymorphism of a scene graph. While all children are a subclass of type Node, you may want to access them by their specific subclass. If the child is not an instance of type T (or a subclass), this method returns nullptr.</p>
<p>If there is more than one child of the given name, it returns the first one that is found. Children are not necessarily enumerated in the order that they are added. For example, they may be resorted by their z-order. Hence it is very important that names be unique.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">name</td><td>An identifier to find the child node.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the (first) child with the given name, typecast to a shared T pointer. </dd></dl>

</div>
</div>
<a id="a9b95db447c6fa24c2e53cfcc16e37c50"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9b95db447c6fa24c2e53cfcc16e37c50">&#9670;&nbsp;</a></span>getChildByTag() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::shared_ptr&lt;<a class="el" href="classcugl_1_1scene2_1_1_scene_node.html">scene2::SceneNode</a>&gt; cugl::Scene2::getChildByTag </td>
          <td>(</td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>tag</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns the (first) child with the given tag.</p>
<p>If there is more than one child of the given tag, it returns the first one that is found. Children are not necessarily enumerated in the order that they are added. For example, they may be resorted by their z-order. Hence it is very important that tags be unique.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">tag</td><td>An identifier to find the child node.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the (first) child with the given tag. </dd></dl>

</div>
</div>
<a id="aabf53569fb36368c61fe3f77f702d1b6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aabf53569fb36368c61fe3f77f702d1b6">&#9670;&nbsp;</a></span>getChildByTag() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::shared_ptr&lt;T&gt; cugl::Scene2::getChildByTag </td>
          <td>(</td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>tag</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns the (first) child with the given tag, typecast to a shared T pointer.</p>
<p>This method is provided to simplify the polymorphism of a scene graph. While all children are a subclass of type Node, you may want to access them by their specific subclass. If the child is not an instance of type T (or a subclass), this method returns nullptr.</p>
<p>If there is more than one child of the given tag, it returns the first one that is found. Children are not necessarily enumerated in the order that they are added. For example, they may be resorted by their z-order. Hence it is very important that tags be unique.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">tag</td><td>An identifier to find the child node.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the (first) child with the given tag, typecast to a shared T pointer. </dd></dl>

</div>
</div>
<a id="a180919f109805cd95f134b49f7fb47f5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a180919f109805cd95f134b49f7fb47f5">&#9670;&nbsp;</a></span>getChildCount()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_t cugl::Scene2::getChildCount </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns the number of immediate children of this scene.</p>
<dl class="section return"><dt>Returns</dt><dd>The number of immediate children of this scene. </dd></dl>

</div>
</div>
<a id="a1587c2af2107f24a5c63fd9fa3f8a71f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1587c2af2107f24a5c63fd9fa3f8a71f">&#9670;&nbsp;</a></span>getChildren() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;std::shared_ptr&lt;<a class="el" href="classcugl_1_1scene2_1_1_scene_node.html">scene2::SceneNode</a>&gt; &gt; cugl::Scene2::getChildren </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns the list of the scene's immediate children.</p>
<dl class="section return"><dt>Returns</dt><dd>the list of the scene's immediate children. </dd></dl>

</div>
</div>
<a id="aeea0e15f504ac1aa8deb20637b4231fe"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aeea0e15f504ac1aa8deb20637b4231fe">&#9670;&nbsp;</a></span>getChildren() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const std::vector&lt;std::shared_ptr&lt;<a class="el" href="classcugl_1_1scene2_1_1_scene_node.html">scene2::SceneNode</a>&gt; &gt;&amp; cugl::Scene2::getChildren </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns the list of the scene's immediate children.</p>
<dl class="section return"><dt>Returns</dt><dd>the list of the scene's immediate children. </dd></dl>

</div>
</div>
<a id="a1021ef348f028bf65e9c2049a0c4e26a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1021ef348f028bf65e9c2049a0c4e26a">&#9670;&nbsp;</a></span>getColor()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcugl_1_1_color4.html">Color4</a> cugl::Scene2::getColor </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns the tint color for this scene.</p>
<p>During the render phase, this color will be applied to any child for which hasRelativeColor() is true.</p>
<dl class="section return"><dt>Returns</dt><dd>the tint color for this scene. </dd></dl>

</div>
</div>
<a id="a98de99622cb4fed50a5e659032cf99fa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a98de99622cb4fed50a5e659032cf99fa">&#9670;&nbsp;</a></span>getName()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const std::string&amp; cugl::Scene2::getName </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns a string that is used to identify the scene.</p>
<dl class="section return"><dt>Returns</dt><dd>a string that is used to identify the scene. </dd></dl>

</div>
</div>
<a id="a6fed2dabcea7c43b184558a2b2a660b5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6fed2dabcea7c43b184558a2b2a660b5">&#9670;&nbsp;</a></span>getSize()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classcugl_1_1_size.html">Size</a> cugl::Scene2::getSize </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns the viewport size of this <a class="el" href="classcugl_1_1_scene2.html">Scene2</a>.</p>
<dl class="section return"><dt>Returns</dt><dd>the viewport size of this <a class="el" href="classcugl_1_1_scene2.html">Scene2</a>. </dd></dl>

</div>
</div>
<a id="a877a018e1bf54e490fd4b51d3f0d50d4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a877a018e1bf54e490fd4b51d3f0d50d4">&#9670;&nbsp;</a></span>init() <span class="overload">[1/5]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool cugl::Scene2::init </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classcugl_1_1_rect.html">Rect</a>&#160;</td>
          <td class="paramname"><em>rect</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Initializes a <a class="el" href="classcugl_1_1_scene2.html">Scene2</a> with the given viewport.</p>
<p>Offseting the viewport origin has little affect on the Scene in general. It only affects the coordinate conversion methods <a class="el" href="classcugl_1_1_camera.html#a0c0eca401bf088d6e756eb9e1c7e9d76">Camera#project()</a> and <a class="el" href="classcugl_1_1_camera.html#a67ec4ef4003e6f6b11819d6f272f3d1f">Camera#unproject()</a>. It is supposed to represent the offset of the viewport in a larger canvas.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">rect</td><td>The viewport bounding box</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if initialization was successful. </dd></dl>

</div>
</div>
<a id="add0b8628986cba8ffc6bda8383495e9e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#add0b8628986cba8ffc6bda8383495e9e">&#9670;&nbsp;</a></span>init() <span class="overload">[2/5]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool cugl::Scene2::init </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classcugl_1_1_size.html">Size</a>&#160;</td>
          <td class="paramname"><em>size</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Initializes a <a class="el" href="classcugl_1_1_scene2.html">Scene2</a> with the given viewport.</p>
<p>The viewport origin is assumed to be (0,0).</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">size</td><td>The viewport size</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if initialization was successful. </dd></dl>

</div>
</div>
<a id="a19bb797c0f28b47127aebbe22aab9ffb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a19bb797c0f28b47127aebbe22aab9ffb">&#9670;&nbsp;</a></span>init() <span class="overload">[3/5]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool cugl::Scene2::init </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classcugl_1_1_vec2.html">Vec2</a>&#160;</td>
          <td class="paramname"><em>origin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classcugl_1_1_size.html">Size</a>&#160;</td>
          <td class="paramname"><em>size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Initializes a <a class="el" href="classcugl_1_1_scene2.html">Scene2</a> with the given viewport.</p>
<p>Offseting the viewport origin has little affect on the Scene in general. It only affects the coordinate conversion methods <a class="el" href="classcugl_1_1_camera.html#a0c0eca401bf088d6e756eb9e1c7e9d76">Camera#project()</a> and <a class="el" href="classcugl_1_1_camera.html#a67ec4ef4003e6f6b11819d6f272f3d1f">Camera#unproject()</a>. It is supposed to represent the offset of the viewport in a larger canvas.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">origin</td><td>The viewport offset </td></tr>
    <tr><td class="paramname">size</td><td>The viewport size</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if initialization was successful. </dd></dl>

</div>
</div>
<a id="a6cd4d844884924681be3dd09a3a81602"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6cd4d844884924681be3dd09a3a81602">&#9670;&nbsp;</a></span>init() <span class="overload">[4/5]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool cugl::Scene2::init </td>
          <td>(</td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>width</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>height</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Initializes a <a class="el" href="classcugl_1_1_scene2.html">Scene2</a> with the given viewport.</p>
<p>The viewport origin is assumed to be (0,0).</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">width</td><td>The viewport width </td></tr>
    <tr><td class="paramname">height</td><td>The viewport height</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if initialization was successful. </dd></dl>

</div>
</div>
<a id="a01dfdd6f3fa09fed3400c34d5b53ffd9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a01dfdd6f3fa09fed3400c34d5b53ffd9">&#9670;&nbsp;</a></span>init() <span class="overload">[5/5]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool cugl::Scene2::init </td>
          <td>(</td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>width</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>height</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Initializes a <a class="el" href="classcugl_1_1_scene2.html">Scene2</a> with the given viewport.</p>
<p>Offseting the viewport origin has little affect on the Scene in general. It only affects the coordinate conversion methods <a class="el" href="classcugl_1_1_camera.html#a0c0eca401bf088d6e756eb9e1c7e9d76">Camera#project()</a> and <a class="el" href="classcugl_1_1_camera.html#a67ec4ef4003e6f6b11819d6f272f3d1f">Camera#unproject()</a>. It is supposed to represent the offset of the viewport in a larger canvas.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>The viewport x offset </td></tr>
    <tr><td class="paramname">y</td><td>The viewport y offset </td></tr>
    <tr><td class="paramname">width</td><td>The viewport width </td></tr>
    <tr><td class="paramname">height</td><td>The viewport height</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if initialization was successful. </dd></dl>

<p>Reimplemented in <a class="el" href="classcugl_1_1_scene2_texture.html#a896bec8e2cc854e748ffcf02a9127721">cugl::Scene2Texture</a>.</p>

</div>
</div>
<a id="a43ccc21633c20925d51a8a727898da9b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a43ccc21633c20925d51a8a727898da9b">&#9670;&nbsp;</a></span>isActive()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool cugl::Scene2::isActive </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns true if the scene is currently active</p>
<dl class="section return"><dt>Returns</dt><dd>true if the scene is currently active </dd></dl>

</div>
</div>
<a id="a8b097594743f64d91ed1e91d503a910a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8b097594743f64d91ed1e91d503a910a">&#9670;&nbsp;</a></span>isZAutoSort()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool cugl::Scene2::isZAutoSort </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns true if this scene automatically sorts children by z-value.</p>
<p>If this value is true, the scene graph will be resorted every time that <a class="el" href="classcugl_1_1_scene2.html#adecdb73ddcdf7be9dc617f1c2f25736c">render()</a> is called. Because of our invariant with dirty nodes, sorting will be avoided if it is not necessary.</p>
<p>Sorting only happens automatically is this value it true. Otherwise, you will need to call <a class="el" href="classcugl_1_1_scene2.html#ac47fd35c42b4fa2cad384251ecc012a1">sortZOrder()</a> if you wish to guarantee that the sceen graph is in z-order.</p>
<dl class="section return"><dt>Returns</dt><dd>true if this scene automatically sorts children by z-value. </dd></dl>

</div>
</div>
<a id="ae74dc2dd307a286188d842f6019baf4e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae74dc2dd307a286188d842f6019baf4e">&#9670;&nbsp;</a></span>isZDirty()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool cugl::Scene2::isZDirty </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns whether the children of this Scene needs resorting.</p>
<p>The children of a scene may need to be resorted whenever a child is added, or whenever the z-value of a child is changed.</p>
<p>This value satisfies the following invariant: if a Node is dirty and needs resorting, then so are all of its ancestors (including this associated <a class="el" href="classcugl_1_1_scene2.html">Scene2</a>). Our methods guarantee this invariant, so that the method <a class="el" href="classcugl_1_1_scene2.html#ae74dc2dd307a286188d842f6019baf4e">isZDirty()</a> always returns the correct value.</p>
<p>Sorting only happens automatically is <a class="el" href="classcugl_1_1_scene2.html#a8b097594743f64d91ed1e91d503a910a">isZAutoSort()</a> it true. Otherwise, you will need to call <a class="el" href="classcugl_1_1_scene2.html#ac47fd35c42b4fa2cad384251ecc012a1">sortZOrder()</a> if you wish to guarantee that the sceen graph is in z-order.</p>
<dl class="section return"><dt>Returns</dt><dd>whether the children of this node needs resorting. </dd></dl>

</div>
</div>
<a id="a146a47bc0011e0eec147b3a38256b6bc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a146a47bc0011e0eec147b3a38256b6bc">&#9670;&nbsp;</a></span>operator std::string()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">cugl::Scene2::operator std::string </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Cast from a Scene to a string. </p>

</div>
</div>
<a id="a8f4a8ae1f0edf0cc9f37cf5dcc5e9e5e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8f4a8ae1f0edf0cc9f37cf5dcc5e9e5e">&#9670;&nbsp;</a></span>removeAllChildren()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void cugl::Scene2::removeAllChildren </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Removes all children from this Node. </p>

</div>
</div>
<a id="a71868d8867435e1fdeeb0cf3571183f2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a71868d8867435e1fdeeb0cf3571183f2">&#9670;&nbsp;</a></span>removeChild() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void cugl::Scene2::removeChild </td>
          <td>(</td>
          <td class="paramtype">const std::shared_ptr&lt; <a class="el" href="classcugl_1_1scene2_1_1_scene_node.html">scene2::SceneNode</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>child</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Removes a child from this Scene.</p>
<p>Removing a child alters the position of every child after it. Hence it is unsafe to cache child positions.</p>
<p>If the child is not in this node, nothing happens.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">child</td><td>The child node which will be removed. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a723b1df1693bf6ac24caa6ef0f392a7c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a723b1df1693bf6ac24caa6ef0f392a7c">&#9670;&nbsp;</a></span>removeChild() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void cugl::Scene2::removeChild </td>
          <td>(</td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>pos</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Removes the child at the given position from this Scene.</p>
<p>Removing a child alters the position of every child after it. Hence it is unsafe to cache child positions.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pos</td><td>The position of the child node which will be removed. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ae9adab1b5d6ac92ee136b16eb9607dfe"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae9adab1b5d6ac92ee136b16eb9607dfe">&#9670;&nbsp;</a></span>removeChildByName()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void cugl::Scene2::removeChildByName </td>
          <td>(</td>
          <td class="paramtype">const std::string&#160;</td>
          <td class="paramname"><em>name</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Removes a child from the Scene by name.</p>
<p>If there is more than one child of the given name, it removes the first one that is found. Children are not necessarily enumerated in the order that they are added. For example, they may be resorted by their z-order. Hence it is very important that names be unique.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">name</td><td>A string to identify the node. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="adad59ad487100cd5860db647f4df48a9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adad59ad487100cd5860db647f4df48a9">&#9670;&nbsp;</a></span>removeChildByTag()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void cugl::Scene2::removeChildByTag </td>
          <td>(</td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>tag</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Removes a child from the Scene by tag value.</p>
<p>If there is more than one child of the given tag, it removes the first one that is found. Children are not necessarily enumerated in the order that they are added. For example, they may be resorted by their z-order. Hence it is very important that tags be unique.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">tag</td><td>An integer to identify the node easily. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="adecdb73ddcdf7be9dc617f1c2f25736c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adecdb73ddcdf7be9dc617f1c2f25736c">&#9670;&nbsp;</a></span>render()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void cugl::Scene2::render </td>
          <td>(</td>
          <td class="paramtype">const std::shared_ptr&lt; <a class="el" href="classcugl_1_1_sprite_batch.html">SpriteBatch</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>batch</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Draws all of the children in this scene with the given <a class="el" href="classcugl_1_1_sprite_batch.html">SpriteBatch</a>.</p>
<p>This method assumes that the sprite batch is not actively drawing. It will call both begin() and end().</p>
<p>Rendering happens by traversing the the scene graph using an "Pre-Order" tree traversal algorithm ( <a href="https://en.wikipedia.org/wiki/Tree_traversal#Pre-order">https://en.wikipedia.org/wiki/Tree_traversal#Pre-order</a> ). That means that parents are always draw before (and behind children). To override this draw order, scene nodes do support a z-axis offset.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">batch</td><td>The <a class="el" href="classcugl_1_1_sprite_batch.html">SpriteBatch</a> to draw with. </td></tr>
  </table>
  </dd>
</dl>

<p>Reimplemented in <a class="el" href="classcugl_1_1_scene2_texture.html#a7de7ec605152bff9eb293b032be9f305">cugl::Scene2Texture</a>.</p>

</div>
</div>
<a id="adedbfc7a55d4eca78ae1c59b0cdd5296"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adedbfc7a55d4eca78ae1c59b0cdd5296">&#9670;&nbsp;</a></span>reset()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void cugl::Scene2::reset </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Resets the status of the scene to its original configuration. </p>

</div>
</div>
<a id="acd13274a7c9ccccdb274e4b5acb27c66"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acd13274a7c9ccccdb274e4b5acb27c66">&#9670;&nbsp;</a></span>screenToWorldCoords()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcugl_1_1_vec3.html">Vec3</a> cugl::Scene2::screenToWorldCoords </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classcugl_1_1_vec2.html">Vec2</a>&#160;</td>
          <td class="paramname"><em>screenCoords</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns the world space equivalent of a point in screen coordinates.</p>
<p>Ideally, window space and screen space would be the same space. They are both defined by the viewport and have the same offset and dimension. However, screen coordinates have the origin in the top left while window coordinates have the origin in the bottom left.</p>
<p>In computing the world space coordinates, this method assumes that the z-value of the original vector is the same as near, which is the closest it can be the screen.</p>
<p>This method is important for converting event coordinates (such as a mouse click) to world coordinates.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">screenCoords</td><td>The point in screen coordinates</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the world space equivalent of a point in screen coordinates. </dd></dl>

</div>
</div>
<a id="abe3b22f2d391d543aa1be6b53234daab"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abe3b22f2d391d543aa1be6b53234daab">&#9670;&nbsp;</a></span>setActive()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void cugl::Scene2::setActive </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>value</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Sets whether the scene is currently active</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">value</td><td>whether the scene is currently active </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a05e487c77271b5a8cb31902f2edcf62b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a05e487c77271b5a8cb31902f2edcf62b">&#9670;&nbsp;</a></span>setBounds() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void cugl::Scene2::setBounds </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classcugl_1_1_rect.html">Rect</a>&#160;</td>
          <td class="paramname"><em>rect</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Sets this <a class="el" href="classcugl_1_1_scene2.html">Scene2</a> to have the given viewport.</p>
<p>Offseting the viewport origin has little affect on the Scene in general. It only affects the coordinate conversion methods <a class="el" href="classcugl_1_1_camera.html#a0c0eca401bf088d6e756eb9e1c7e9d76">Camera#project()</a> and <a class="el" href="classcugl_1_1_camera.html#a67ec4ef4003e6f6b11819d6f272f3d1f">Camera#unproject()</a>. It is supposed to represent the offset</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">rect</td><td>The viewport bounding box </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ad998bb703cc04f0de1ba106d178b3e10"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad998bb703cc04f0de1ba106d178b3e10">&#9670;&nbsp;</a></span>setBounds() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void cugl::Scene2::setBounds </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classcugl_1_1_vec2.html">Vec2</a>&#160;</td>
          <td class="paramname"><em>origin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classcugl_1_1_size.html">Size</a>&#160;</td>
          <td class="paramname"><em>size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Sets this <a class="el" href="classcugl_1_1_scene2.html">Scene2</a> to have the given viewport.</p>
<p>Offseting the viewport origin has little affect on the Scene in general. It only affects the coordinate conversion methods <a class="el" href="classcugl_1_1_camera.html#a0c0eca401bf088d6e756eb9e1c7e9d76">Camera#project()</a> and <a class="el" href="classcugl_1_1_camera.html#a67ec4ef4003e6f6b11819d6f272f3d1f">Camera#unproject()</a>. It is supposed to represent the offset</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">origin</td><td>The viewport offset </td></tr>
    <tr><td class="paramname">size</td><td>The viewport size </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a715c3c0965351f5ad7f3c7ac6916751b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a715c3c0965351f5ad7f3c7ac6916751b">&#9670;&nbsp;</a></span>setBounds() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void cugl::Scene2::setBounds </td>
          <td>(</td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>width</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>height</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Sets this <a class="el" href="classcugl_1_1_scene2.html">Scene2</a> to have the given viewport.</p>
<p>Offseting the viewport origin has little affect on the Scene in general. It only affects the coordinate conversion methods <a class="el" href="classcugl_1_1_camera.html#a0c0eca401bf088d6e756eb9e1c7e9d76">Camera#project()</a> and <a class="el" href="classcugl_1_1_camera.html#a67ec4ef4003e6f6b11819d6f272f3d1f">Camera#unproject()</a>. It is supposed to represent the offset</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>The viewport x offset </td></tr>
    <tr><td class="paramname">y</td><td>The viewport y offset </td></tr>
    <tr><td class="paramname">width</td><td>The viewport width </td></tr>
    <tr><td class="paramname">height</td><td>The viewport height </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a5bd96c871c155e47ddbf60b07faf73e9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5bd96c871c155e47ddbf60b07faf73e9">&#9670;&nbsp;</a></span>setColor()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void cugl::Scene2::setColor </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classcugl_1_1_color4.html">Color4</a>&#160;</td>
          <td class="paramname"><em>color</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Sets the tint color for this scene.</p>
<p>During the render phase, this color will be applied to any child for which hasRelativeColor() is true.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">color</td><td>The tint color for this scene. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a7fff235fe3813031c082e6633f9b1132"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7fff235fe3813031c082e6633f9b1132">&#9670;&nbsp;</a></span>setHeight()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void cugl::Scene2::setHeight </td>
          <td>(</td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>height</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Sets this <a class="el" href="classcugl_1_1_scene2.html">Scene2</a> to have the given viewport height.</p>
<p>The viewport origin is assumed to be (0,0).</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">height</td><td>The viewport height </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a485f08832836b2f989161627b525f32e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a485f08832836b2f989161627b525f32e">&#9670;&nbsp;</a></span>setName()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void cugl::Scene2::setName </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>name</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns the string that is used to identify the scene.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">name</td><td>A string that is used to identify the scene. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a420e683310f071ed26a17e1c57e121c5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a420e683310f071ed26a17e1c57e121c5">&#9670;&nbsp;</a></span>setOffset()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void cugl::Scene2::setOffset </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classcugl_1_1_vec2.html">Vec2</a>&#160;</td>
          <td class="paramname"><em>origin</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Offsets the viewport origin by the given amount.</p>
<p>Offseting the viewport origin has little affect on the Scene in general. It only affects the coordinate conversion methods <a class="el" href="classcugl_1_1_camera.html#a0c0eca401bf088d6e756eb9e1c7e9d76">Camera#project()</a> and <a class="el" href="classcugl_1_1_camera.html#a67ec4ef4003e6f6b11819d6f272f3d1f">Camera#unproject()</a>. It is supposed to represent the offset</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">origin</td><td>The offset of the viewport origin </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a7047647d54fc4baf5ef658d9e3bc951a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7047647d54fc4baf5ef658d9e3bc951a">&#9670;&nbsp;</a></span>setSize() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void cugl::Scene2::setSize </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classcugl_1_1_size.html">Size</a>&#160;</td>
          <td class="paramname"><em>size</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Sets this <a class="el" href="classcugl_1_1_scene2.html">Scene2</a> to have the given viewport.</p>
<p>The viewport origin is assumed to be (0,0).</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">size</td><td>The viewport size </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a0b7d821c69fc5af2a92bf525a226a974"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0b7d821c69fc5af2a92bf525a226a974">&#9670;&nbsp;</a></span>setSize() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void cugl::Scene2::setSize </td>
          <td>(</td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>width</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>height</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Sets this <a class="el" href="classcugl_1_1_scene2.html">Scene2</a> to have the given viewport.</p>
<p>The viewport origin is assumed to be (0,0).</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">width</td><td>The viewport width </td></tr>
    <tr><td class="paramname">height</td><td>The viewport height </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="acb859cec6e45d2ab52792cccdda493ad"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acb859cec6e45d2ab52792cccdda493ad">&#9670;&nbsp;</a></span>setWidth()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void cugl::Scene2::setWidth </td>
          <td>(</td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>width</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Sets this <a class="el" href="classcugl_1_1_scene2.html">Scene2</a> to have the given viewport width.</p>
<p>The viewport origin is assumed to be (0,0).</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">width</td><td>The viewport width </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a449125b339eb01438927d19cafbe2ebb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a449125b339eb01438927d19cafbe2ebb">&#9670;&nbsp;</a></span>setZAutoSort()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void cugl::Scene2::setZAutoSort </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>value</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Sets whether this scene automatically sorts children by z-value.</p>
<p>If this value is true, the scene graph will be resorted every time that <a class="el" href="classcugl_1_1_scene2.html#adecdb73ddcdf7be9dc617f1c2f25736c">render()</a> is called. Because of our invariant with dirty nodes, sorting will be avoided if it is not necessary.</p>
<p>Sorting only happens automatically is this value it true. Otherwise, you will need to call <a class="el" href="classcugl_1_1_scene2.html#ac47fd35c42b4fa2cad384251ecc012a1">sortZOrder()</a> if you wish to guarantee that the sceen graph is in z-order.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">value</td><td>Whether this scene automatically sorts children by z-value. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ac47fd35c42b4fa2cad384251ecc012a1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac47fd35c42b4fa2cad384251ecc012a1">&#9670;&nbsp;</a></span>sortZOrder()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void cugl::Scene2::sortZOrder </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Resorts the children of this Scene according to z-value.</p>
<p>If two children have the same z-value, their relative order is preserved to what it was before the sort. This method should be called before rendering.</p>
<p>Resorting is done recursively down a tree for each child that is dirty and needs resorting. We guarantee that Nodes will not be resorted unless necessary, because of the following invariant: if a Node is dirty and needs resorting, then so are all of its ancestors (including this associated <a class="el" href="classcugl_1_1_scene2.html">Scene2</a>).</p>
<p>Sorting only happens automatically is <a class="el" href="classcugl_1_1_scene2.html#a8b097594743f64d91ed1e91d503a910a">isZAutoSort()</a> it true. Otherwise, you will need to call <a class="el" href="classcugl_1_1_scene2.html#ac47fd35c42b4fa2cad384251ecc012a1">sortZOrder()</a> if you wish to guarantee that the sceen graph is in z-order. </p>

</div>
</div>
<a id="ae91fa0b6f56074612b603b43c16a3759"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae91fa0b6f56074612b603b43c16a3759">&#9670;&nbsp;</a></span>swapChild()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void cugl::Scene2::swapChild </td>
          <td>(</td>
          <td class="paramtype">const std::shared_ptr&lt; <a class="el" href="classcugl_1_1scene2_1_1_scene_node.html">scene2::SceneNode</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>child1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::shared_ptr&lt; <a class="el" href="classcugl_1_1scene2_1_1_scene_node.html">scene2::SceneNode</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>child2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>inherit</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Swaps the current child child1 with the new child child2.</p>
<p>If inherit is true, the children of child1 are assigned to child2 after the swap; this value is false by default. The purpose of this value is to allow transitions in the scene graph.</p>
<p>This method is undefined if child1 is not a child of this scene.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">child1</td><td>The current child of this node </td></tr>
    <tr><td class="paramname">child2</td><td>The child to swap it with. </td></tr>
    <tr><td class="paramname">inherit</td><td>Whether the new child should inherit the children of child1. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ad64115f12bac3f2d4b2a3459555362ed"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad64115f12bac3f2d4b2a3459555362ed">&#9670;&nbsp;</a></span>toString()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual std::string cugl::Scene2::toString </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>verbose</em> = <code>false</code></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns a string representation of this scene for debugging purposes.</p>
<p>If verbose is true, the string will include class information. This allows us to unambiguously identify the class.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">verbose</td><td>Whether to include class information</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a string representation of this scene for debuggging purposes. </dd></dl>

</div>
</div>
<a id="a685ca119e276d566376f8757d6c991d7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a685ca119e276d566376f8757d6c991d7">&#9670;&nbsp;</a></span>update()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void cugl::Scene2::update </td>
          <td>(</td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>timestep</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>The method called to update the scene.</p>
<p>This method should be overridden with the specific scene logic.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">timestep</td><td>The amount of time (in seconds) since the last frame </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a62a3f1d9c9dbcc2a276c234b4b30b502"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a62a3f1d9c9dbcc2a276c234b4b30b502">&#9670;&nbsp;</a></span>worldToScreenCoords()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcugl_1_1_vec2.html">Vec2</a> cugl::Scene2::worldToScreenCoords </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classcugl_1_1_vec3.html">Vec3</a>&#160;</td>
          <td class="paramname"><em>worldCoords</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns the screen space equivalent of a point in world coordinates.</p>
<p>Ideally, window space and screen space would be the same space. They are both defined by the viewport and have the same offset and dimension. However, screen coordinates have the origin in the top left while window coordinates have the origin in the bottom left.</p>
<p>This method is important for converting world coordinates to event coordinates (such as a mouse click).</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">worldCoords</td><td>The point in wprld coordinates</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the screen space equivalent of a point in world coordinates. </dd></dl>

</div>
</div>
<h2 class="groupheader">Member Data Documentation</h2>
<a id="afa830b449e840bde845e7e8d83a842cb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afa830b449e840bde845e7e8d83a842cb">&#9670;&nbsp;</a></span>_active</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool cugl::Scene2::_active</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Whether or note this scene is still active </p>

</div>
</div>
<a id="a1e046894be3fffc7f975c7eec1db8e56"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1e046894be3fffc7f975c7eec1db8e56">&#9670;&nbsp;</a></span>_blendEquation</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">GLenum cugl::Scene2::_blendEquation</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>The blending equation for this scene </p>

</div>
</div>
<a id="afb4d7b1eb5f70a162b3fdbcdd1c7fc4e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afb4d7b1eb5f70a162b3fdbcdd1c7fc4e">&#9670;&nbsp;</a></span>_camera</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::shared_ptr&lt;<a class="el" href="classcugl_1_1_orthographic_camera.html">OrthographicCamera</a>&gt; cugl::Scene2::_camera</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>The camera for this scene </p>

</div>
</div>
<a id="ab225bcb5ef394b7dc8c5814bcd1f03d4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab225bcb5ef394b7dc8c5814bcd1f03d4">&#9670;&nbsp;</a></span>_children</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;std::shared_ptr&lt;<a class="el" href="classcugl_1_1scene2_1_1_scene_node.html">scene2::SceneNode</a>&gt; &gt; cugl::Scene2::_children</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>The array of internal nodes </p>

</div>
</div>
<a id="abef303013c630c349a98dd67edd4f93c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abef303013c630c349a98dd67edd4f93c">&#9670;&nbsp;</a></span>_color</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcugl_1_1_color4.html">Color4</a> cugl::Scene2::_color</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>The default tint for this scene </p>

</div>
</div>
<a id="a13d48aae17238795cd8e0e064e627f6d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a13d48aae17238795cd8e0e064e627f6d">&#9670;&nbsp;</a></span>_dstFactor</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">GLenum cugl::Scene2::_dstFactor</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>The destination factor for the blend function </p>

</div>
</div>
<a id="a5cfbff4429040319e5635536a7730017"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5cfbff4429040319e5635536a7730017">&#9670;&nbsp;</a></span>_name</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::string cugl::Scene2::_name</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>The name of this scene </p>

</div>
</div>
<a id="a943b869ecdbad4988a6973c7e959bfda"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a943b869ecdbad4988a6973c7e959bfda">&#9670;&nbsp;</a></span>_srcFactor</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">GLenum cugl::Scene2::_srcFactor</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>The source factor for the blend function </p>

</div>
</div>
<a id="a6619e7b99ae38ec14925aa4ba6b3334c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6619e7b99ae38ec14925aa4ba6b3334c">&#9670;&nbsp;</a></span>_zDirty</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool cugl::Scene2::_zDirty</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Indicates whether the z-order is currently violated </p>

</div>
</div>
<a id="ae68e900ab42a1e4db6588fe8f83f29b0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae68e900ab42a1e4db6588fe8f83f29b0">&#9670;&nbsp;</a></span>_zSort</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool cugl::Scene2::_zSort</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Indicates whether auto-sorting is active </p>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>include/cugl/scene2/<a class="el" href="_c_u_scene2_8h_source.html">CUScene2.h</a></li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.1
</small></address>
</body>
</html>
